declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	Tooltip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static GetDefaultObject(): BrushBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject | any): BrushBuilder;
	Build(InWorld: World,InBrush: Brush): boolean;
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	Type: number;
	index: number;
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject | any): GeomSelection;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bDisplayShadedVolume: boolean;
	ShadedVolumeOpacityValue: number;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	static GetDefaultObject(): Brush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject | any): Brush;
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
}

declare class Volume extends Brush { 
	static GetDefaultObject(): Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject | any): Volume;
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	static GetDefaultObject(): PhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject | any): PhysicsVolume;
}

declare type EDetachmentRule = 'KeepRelative' | 'KeepWorld' | 'EDetachmentRule_MAX';
declare var EDetachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',EDetachmentRule_MAX:'EDetachmentRule_MAX', };
declare type EMoveComponentAction = 'Move' | 'Stop' | 'Return' | 'EMoveComponentAction_MAX';
declare var EMoveComponentAction : { Move:'Move',Stop:'Stop',Return:'Return',EMoveComponentAction_MAX:'EMoveComponentAction_MAX', };
declare class ARPin extends UObject { 
	TrackedGeometry: ARTrackedGeometry;
	PinnedComponent: SceneComponent;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	OnARTrackingStateChanged: UnrealEngineMulticastDelegate<(NewTrackingState: EARTrackingState) => void>;
	OnARTransformUpdated: UnrealEngineMulticastDelegate<(OldToNewTransform: Transform) => void>;
	static Load(ResourceName: string): ARPin;
	static Find(Outer: UObject, ResourceName: string): ARPin;
	static GetDefaultObject(): ARPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPin;
	GetTrackingState(): EARTrackingState;
	GetTrackedGeometry(): ARTrackedGeometry;
	GetPinnedComponent(): SceneComponent;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetDebugName(): string;
	DebugDraw(World: World,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static C(Other: UObject | any): ARPin;
	DebugDrawPin(WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	RemovePin(): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static RemovePin(PinToRemove: ARPin): void;
}

declare class SceneComponent extends ActorComponent { 
	PhysicsVolume: any;
	AttachParent: SceneComponent;
	AttachSocketName: string;
	AttachChildren: SceneComponent[];
	ClientAttachedChildren: SceneComponent[];
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	ComponentVelocity: Vector;
	bComponentToWorldUpdated: boolean;
	bAbsoluteLocation: boolean;
	bAbsoluteRotation: boolean;
	bAbsoluteScale: boolean;
	bVisible: boolean;
	bShouldBeAttached: boolean;
	bShouldSnapLocationWhenAttached: boolean;
	bShouldSnapRotationWhenAttached: boolean;
	bShouldUpdatePhysicsVolume: boolean;
	bHiddenInGame: boolean;
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	bUseAttachParentBound: boolean;
	bComputeFastLocalBounds: boolean;
	bComputeBoundsOnceForGame: boolean;
	bComputedBoundsOnceForGame: boolean;
	bVisualizeComponent: boolean;
	Mobility: EComponentMobility;
	DetailMode: EDetailMode;
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	ReplacementSceneComponent: SceneComponent;
	static Load(ResourceName: string): SceneComponent;
	static Find(Outer: UObject, ResourceName: string): SceneComponent;
	static GetDefaultObject(): SceneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	ToggleVisibility(bPropagateToChildren: boolean): void;
	SetWorldScale3D(NewScale: Vector): void;
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean): void;
	SetRelativeScale3D(NewScale3D: Vector): void;
	SetMobility(NewMobility: EComponentMobility): void;
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	ResetRelativeTransform(): void;
	OnRep_Visibility(OldValue: boolean): void;
	OnRep_Transform(): void;
	OnRep_AttachSocketName(): void;
	OnRep_AttachParent(): void;
	OnRep_AttachChildren(): void;
	K2_SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_GetComponentToWorld(): Transform;
	K2_GetComponentScale(): Vector;
	K2_GetComponentRotation(): Rotator;
	K2_GetComponentLocation(): Vector;
	K2_DetachFromComponent(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule,bCallModify: boolean): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): boolean;
	K2_AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): boolean;
	K2_AddWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsVisible(): boolean;
	IsSimulatingPhysics(BoneName: string): boolean;
	IsAnySimulatingPhysics(): boolean;
	GetUpVector(): Vector;
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	GetSocketRotation(InSocketName: string): Rotator;
	GetSocketQuaternion(InSocketName: string): Quat;
	GetSocketLocation(InSocketName: string): Vector;
	GetShouldUpdatePhysicsVolume(): boolean;
	GetRightVector(): Vector;
	GetRelativeTransform(): Transform;
	GetPhysicsVolume(): PhysicsVolume;
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	GetNumChildrenComponents(): number;
	GetForwardVector(): Vector;
	GetComponentVelocity(): Vector;
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	GetChildComponent(ChildIndex: number): SceneComponent;
	GetAttachSocketName(): string;
	GetAttachParent(): SceneComponent;
	GetAllSocketNames(): string[];
	DoesSocketExist(InSocketName: string): boolean;
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
	static C(Other: UObject | any): SceneComponent;
	SetMobile(): void;
	SetMobility(Type: EComponentMobility): void;
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	PinComponent(PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	PinComponentToARPin(Pin: ARPin): boolean;
	PinComponentToTraceResult(TraceResult: ARTraceResult,DebugName: string): ARPin;
	UnpinComponent(): void;
	static SetMobile(SceneComponent: SceneComponent): void;
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
}

declare type ESceneDepthPriorityGroup = 'SDPG_World' | 'SDPG_Foreground' | 'SDPG_MAX';
declare var ESceneDepthPriorityGroup : { SDPG_World:'SDPG_World',SDPG_Foreground:'SDPG_Foreground',SDPG_MAX:'SDPG_MAX', };
declare type EIndirectLightingCacheQuality = 'ILCQ_Off' | 'ILCQ_Point' | 'ILCQ_Volume' | 'ILCQ_MAX';
declare var EIndirectLightingCacheQuality : { ILCQ_Off:'ILCQ_Off',ILCQ_Point:'ILCQ_Point',ILCQ_Volume:'ILCQ_Volume',ILCQ_MAX:'ILCQ_MAX', };
declare type ELightmapType = 'Default' | 'ForceSurface' | 'ForceVolumetric' | 'ELightmapType_MAX';
declare var ELightmapType : { Default:'Default',ForceSurface:'ForceSurface',ForceVolumetric:'ForceVolumetric',ELightmapType_MAX:'ELightmapType_MAX', };
declare type EHLODBatchingPolicy = 'None' | 'MeshSection' | 'Instancing' | 'EHLODBatchingPolicy_MAX';
declare var EHLODBatchingPolicy : { None:'None',MeshSection:'MeshSection',Instancing:'Instancing',EHLODBatchingPolicy_MAX:'EHLODBatchingPolicy_MAX', };
declare type EHasCustomNavigableGeometry = 'No' | 'Yes' | 'EvenIfNotCollidable' | 'DontExport' | 'EHasCustomNavigableGeometry_MAX';
declare var EHasCustomNavigableGeometry : { No:'No',Yes:'Yes',EvenIfNotCollidable:'EvenIfNotCollidable',DontExport:'DontExport',EHasCustomNavigableGeometry_MAX:'EHasCustomNavigableGeometry_MAX', };
declare type EHitProxyPriority = 'HPP_World' | 'HPP_Wireframe' | 'HPP_Foreground' | 'HPP_UI' | 'HPP_MAX';
declare var EHitProxyPriority : { HPP_World:'HPP_World',HPP_Wireframe:'HPP_Wireframe',HPP_Foreground:'HPP_Foreground',HPP_UI:'HPP_UI',HPP_MAX:'HPP_MAX', };
declare type ECanBeCharacterBase = 'ECB_No' | 'ECB_Yes' | 'ECB_Owner' | 'ECB_MAX';
declare var ECanBeCharacterBase : { ECB_No:'ECB_No',ECB_Yes:'ECB_Yes',ECB_Owner:'ECB_Owner',ECB_MAX:'ECB_MAX', };
declare class LightingChannels { 
	bChannel0: boolean;
	bChannel1: boolean;
	bChannel2: boolean;
	clone() : LightingChannels;
	static C(Other: UObject | any): LightingChannels;
}

declare class CustomPrimitiveData { 
	Data: number[];
	clone() : CustomPrimitiveData;
	static C(Other: UObject | any): CustomPrimitiveData;
}

declare type ERuntimeVirtualTextureMainPassType = 'Never' | 'Exclusive' | 'Always' | 'ERuntimeVirtualTextureMainPassType_MAX';
declare var ERuntimeVirtualTextureMainPassType : { Never:'Never',Exclusive:'Exclusive',Always:'Always',ERuntimeVirtualTextureMainPassType_MAX:'ERuntimeVirtualTextureMainPassType_MAX', };
declare type ERayTracingGroupCullingPriority = 'CP_0_NEVER_CULL' | 'CP_1' | 'CP_2' | 'CP_3' | 'CP_4_DEFAULT' | 'CP_5' | 'CP_6' | 'CP_7' | 'CP_8_QUICKLY_CULL' | 'CP_MAX';
declare var ERayTracingGroupCullingPriority : { CP_0_NEVER_CULL:'CP_0_NEVER_CULL',CP_1:'CP_1',CP_2:'CP_2',CP_3:'CP_3',CP_4_DEFAULT:'CP_4_DEFAULT',CP_5:'CP_5',CP_6:'CP_6',CP_7:'CP_7',CP_8_QUICKLY_CULL:'CP_8_QUICKLY_CULL',CP_MAX:'CP_MAX', };
declare type ERadialImpulseFalloff = 'RIF_Constant' | 'RIF_Linear' | 'RIF_MAX';
declare var ERadialImpulseFalloff : { RIF_Constant:'RIF_Constant',RIF_Linear:'RIF_Linear',RIF_MAX:'RIF_MAX', };
declare class PrimitiveComponent extends SceneComponent { 
	MinDrawDistance: number;
	LDMaxDrawDistance: number;
	CachedMaxDrawDistance: number;
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	LightmapType: ELightmapType;
	bEnableAutoLODGeneration: boolean;
	ExcludeForSpecificHLODLevels: number[];
	HLODBatchingPolicy: EHLODBatchingPolicy;
	bIsActorTextureStreamingBuiltData: boolean;
	bIsValidTextureStreamingBuiltData: boolean;
	bNeverDistanceCull: boolean;
	bAlwaysCreatePhysicsState: boolean;
	bGenerateOverlapEvents: boolean;
	bMultiBodyOverlap: boolean;
	bTraceComplexOnMove: boolean;
	bReturnMaterialOnMove: boolean;
	bUseViewOwnerDepthPriorityGroup: boolean;
	bAllowCullDistanceVolume: boolean;
	bHasMotionBlurVelocityMeshes: boolean;
	bVisibleInReflectionCaptures: boolean;
	bVisibleInRealTimeSkyCaptures: boolean;
	bVisibleInRayTracing: boolean;
	bRenderInMainPass: boolean;
	bRenderInDepthPass: boolean;
	bReceivesDecals: boolean;
	bOwnerNoSee: boolean;
	bOnlyOwnerSee: boolean;
	bTreatAsBackgroundForOcclusion: boolean;
	bUseAsOccluder: boolean;
	bSelectable: boolean;
	bConsiderForActorPlacementWhenHidden: boolean;
	bForceMipStreaming: boolean;
	bHasPerInstanceHitProxies: boolean;
	CastShadow: boolean;
	bEmissiveLightSource: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastVolumetricTranslucentShadow: boolean;
	bCastContactShadow: boolean;
	bSelfShadowOnly: boolean;
	bCastFarShadow: boolean;
	bCastInsetShadow: boolean;
	bCastCinematicShadow: boolean;
	bCastHiddenShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bLightAsIfStatic: boolean;
	bLightAttachmentsAsGroup: boolean;
	bExcludeFromLightAttachmentGroup: boolean;
	bReceiveMobileCSMShadows: boolean;
	bSingleSampleShadowFromStationaryLights: boolean;
	bIgnoreRadialImpulse: boolean;
	bIgnoreRadialForce: boolean;
	bApplyImpulseOnDamage: boolean;
	bReplicatePhysicsToAutonomousProxy: boolean;
	bFillCollisionUnderneathForNavmesh: boolean;
	AlwaysLoadOnClient: boolean;
	AlwaysLoadOnServer: boolean;
	bUseEditorCompositing: boolean;
	bIsBeingMovedByEditor: boolean;
	bRenderCustomDepth: boolean;
	bVisibleInSceneCaptureOnly: boolean;
	bHiddenInSceneCapture: boolean;
	bRayTracingFarField: boolean;
	bHasNoStreamableTextures: boolean;
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	HitProxyPriority: EHitProxyPriority;
	CanBeCharacterBase: ECanBeCharacterBase;
	bUseMaxLODAsImposter: boolean;
	bBatchImpostersAsInstances: boolean;
	CanCharacterStepUpOn: ECanBeCharacterBase;
	LightingChannels: LightingChannels;
	RayTracingGroupId: number;
	VisibilityId: number;
	CustomDepthStencilValue: number;
	CustomPrimitiveData: CustomPrimitiveData;
	CustomPrimitiveDataInternal: CustomPrimitiveData;
	TranslucencySortPriority: number;
	TranslucencySortDistanceOffset: number;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureLodBias: any;
	VirtualTextureCullMips: any;
	VirtualTextureMinCoverage: any;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	BoundsScale: number;
	MoveIgnoreActors: Actor[];
	MoveIgnoreComponents: PrimitiveComponent[];
	BodyInstance: BodyInstance;
	OnComponentHit: UnrealEngineMulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	OnComponentWake: UnrealEngineMulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnComponentSleep: UnrealEngineMulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	RayTracingGroupCullingPriority: ERayTracingGroupCullingPriority;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	LODParentPrimitive: PrimitiveComponent;
	static Load(ResourceName: string): PrimitiveComponent;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponent;
	static GetDefaultObject(): PrimitiveComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	WasRecentlyRendered(Tolerance: number): boolean;
	WakeRigidBody(BoneName: string): void;
	WakeAllRigidBodies(): void;
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	SetVisibleInSceneCaptureOnly(bValue: boolean): void;
	SetVisibleInRayTracing(bNewVisibleInRayTracing: boolean): void;
	SetVectorParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetVectorParameterForCustomPrimitiveData(ParameterName: string,Value: Vector4): void;
	SetUseCCD(InUseCCD: boolean,BoneName: string): void;
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	SetTranslucencySortDistanceOffset(NewTranslucencySortDistanceOffset: number): void;
	SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;
	SetSimulatePhysics(bSimulate: boolean): void;
	SetScalarParameterForDefaultCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetScalarParameterForCustomPrimitiveData(ParameterName: string,Value: number): void;
	SetRenderInMainPass(bValue: boolean): void;
	SetRenderInDepthPass(bValue: boolean): void;
	SetRenderCustomDepth(bValue: boolean): void;
	SetReceivesDecals(bNewReceivesDecals: boolean): void;
	SetPhysMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	SetMaterialByName(MaterialSlotName: string,Material: MaterialInterface): void;
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	SetMassScale(BoneName: string,InMassScale: number): void;
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	SetLinearDamping(InDamping: number): void;
	SetLightingChannels(bChannel0: boolean,bChannel1: boolean,bChannel2: boolean): void;
	SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean): void;
	SetHiddenInSceneCapture(bValue: boolean): void;
	SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean): void;
	SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean): void;
	SetEnableGravity(bGravityEnabled: boolean): void;
	SetEmissiveLightSource(NewEmissiveLightSource: boolean): void;
	SetDefaultCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetDefaultCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetDefaultCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetDefaultCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomPrimitiveDataVector4(DataIndex: number,Value: Vector4): void;
	SetCustomPrimitiveDataVector3(DataIndex: number,Value: Vector): void;
	SetCustomPrimitiveDataVector2(DataIndex: number,Value: Vector2D): void;
	SetCustomPrimitiveDataFloat(DataIndex: number,Value: number): void;
	SetCustomDepthStencilWriteMask(WriteMaskBit: ERendererStencilMask): void;
	SetCustomDepthStencilValue(Value: number): void;
	SetCullDistance(NewCullDistance: number): void;
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	SetCollisionProfileName(InCollisionProfileName: string,bUpdateOverlaps: boolean): void;
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	SetCastShadow(NewCastShadow: boolean): void;
	SetCastInsetShadow(bInCastInsetShadow: boolean): void;
	SetCastHiddenShadow(NewCastHiddenShadow: boolean): void;
	SetCastContactShadow(bInCastContactShadow: boolean): void;
	SetBoundsScale(NewBoundsScale: number): void;
	SetAngularDamping(InDamping: number): void;
	SetAllUseCCD(InUseCCD: boolean): void;
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector,bAddToCurrent: boolean): void;
	SetAllMassScale(InMassScale: number): void;
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	PutRigidBodyToSleep(BoneName: string): void;
	K2_SphereTraceComponent(TraceStart: Vector,TraceEnd: Vector,SphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_SphereOverlapComponent(InSphereCentre: Vector,InSphereRadius: number,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	K2_IsQueryCollisionEnabled(): boolean;
	K2_IsPhysicsCollisionEnabled(): boolean;
	K2_IsCollisionEnabled(): boolean;
	K2_BoxOverlapComponent(InBoxCentre: Vector,InBox: Box,bTraceComplex: boolean,bShowTrace: boolean,bPersistentShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string,OutHit?: HitResult): {HitLocation: Vector, HitNormal: Vector, BoneName: string, OutHit: HitResult, $: boolean};
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsGravityEnabled(): boolean;
	IsAnyRigidBodyAwake(): boolean;
	IgnoreComponentWhenMoving(Component: PrimitiveComponent,bShouldIgnore: boolean): void;
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	GetPhysicsAngularVelocityInRadians(BoneName: string): Vector;
	GetPhysicsAngularVelocityInDegrees(BoneName: string): Vector;
	GetOverlappingComponents(OutOverlappingComponents?: PrimitiveComponent[]): {OutOverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetNumMaterials(): number;
	GetMaterialFromCollisionFaceIndex(FaceIndex: number,SectionIndex?: number): {SectionIndex: number, $: MaterialInterface};
	GetMaterial(ElementIndex: number): MaterialInterface;
	GetMassScale(BoneName: string): number;
	GetMass(): number;
	GetLinearDamping(): number;
	GetInertiaTensor(BoneName: string): Vector;
	GetGenerateOverlapEvents(): boolean;
	GetCustomPrimitiveDataIndexForVectorParameter(ParameterName: string): number;
	GetCustomPrimitiveDataIndexForScalarParameter(ParameterName: string): number;
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	GetCollisionProfileName(): string;
	GetCollisionObjectType(): ECollisionChannel;
	GetCollisionEnabled(): ECollisionEnabled;
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	GetCenterOfMass(BoneName: string): Vector;
	GetAngularDamping(): number;
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface,OptionalName: string): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;
	CopyArrayOfMoveIgnoreComponents(): PrimitiveComponent[];
	CopyArrayOfMoveIgnoreActors(): Actor[];
	ClearMoveIgnoreComponents(): void;
	ClearMoveIgnoreActors(): void;
	CanCharacterStepUp(Pawn: Pawn): boolean;
	AddVelocityChangeImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddTorqueInRadians(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddTorqueInDegrees(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddForceAtLocationLocal(Force: Vector,Location: Vector,BoneName: string): void;
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	AddAngularImpulseInRadians(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	AddAngularImpulseInDegrees(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	static C(Other: UObject | any): PrimitiveComponent;
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	SetCastInsetShadowForAllAttachments(bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent,bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
}

declare class MRMeshBodyHolder extends UObject { 
	BodySetup: BodySetup;
	BodyInstance: BodyInstance;
	static Load(ResourceName: string): MRMeshBodyHolder;
	static Find(Outer: UObject, ResourceName: string): MRMeshBodyHolder;
	static GetDefaultObject(): MRMeshBodyHolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshBodyHolder;
	static C(Other: UObject | any): MRMeshBodyHolder;
}

declare class MRMeshComponent extends PrimitiveComponent { 
	Material: MaterialInterface;
	WireframeMaterial: MaterialInterface;
	bCreateMeshProxySections: boolean;
	bUpdateNavMeshOnMeshUpdate: boolean;
	bNeverCreateCollisionMesh: boolean;
	BodyHolders: MRMeshBodyHolder[];
	static Load(ResourceName: string): MRMeshComponent;
	static Find(Outer: UObject, ResourceName: string): MRMeshComponent;
	static GetDefaultObject(): MRMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MRMeshComponent;
	SetWireframeMaterial(InMaterial: MaterialInterface): void;
	SetWireframeColor(InColor: LinearColor): void;
	SetUseWireframe(bUseWireframe: boolean): void;
	SetEnableMeshOcclusion(bEnable: boolean): void;
	RequestNavMeshUpdate(): void;
	IsConnected(): boolean;
	GetWireframeColor(): LinearColor;
	GetUseWireframe(): boolean;
	GetEnableMeshOcclusion(): boolean;
	ForceNavMeshUpdate(): void;
	Clear(): void;
	static C(Other: UObject | any): MRMeshComponent;
}

declare type EARObjectClassification = 'NotApplicable' | 'Unknown' | 'Wall' | 'Ceiling' | 'Floor' | 'Table' | 'Seat' | 'Face' | 'Image' | 'World' | 'SceneObject' | 'HandMesh' | 'Door' | 'Window' | 'EARObjectClassification_MAX';
declare var EARObjectClassification : { NotApplicable:'NotApplicable',Unknown:'Unknown',Wall:'Wall',Ceiling:'Ceiling',Floor:'Floor',Table:'Table',Seat:'Seat',Face:'Face',Image:'Image',World:'World',SceneObject:'SceneObject',HandMesh:'HandMesh',Door:'Door',Window:'Window',EARObjectClassification_MAX:'EARObjectClassification_MAX', };
declare type EARSpatialMeshUsageFlags = 'NotApplicable' | 'Visible' | 'Collision' | 'EARSpatialMeshUsageFlags_MAX';
declare var EARSpatialMeshUsageFlags : { NotApplicable:'NotApplicable',Visible:'Visible',Collision:'Collision',EARSpatialMeshUsageFlags_MAX:'EARSpatialMeshUsageFlags_MAX', };
declare class ARTrackedGeometry extends UObject { 
	UniqueId: Guid;
	LocalToTrackingTransform: Transform;
	LocalToAlignedTrackingTransform: Transform;
	TrackingState: EARTrackingState;
	UnderlyingMesh: MRMeshComponent;
	ObjectClassification: EARObjectClassification;
	SpatialMeshUsageFlags: EARSpatialMeshUsageFlags;
	LastUpdateFrameNumber: number;
	DebugName: string;
	static Load(ResourceName: string): ARTrackedGeometry;
	static Find(Outer: UObject, ResourceName: string): ARTrackedGeometry;
	static GetDefaultObject(): ARTrackedGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedGeometry;
	IsTracked(): boolean;
	HasSpatialMeshUsageFlag(InFlag: EARSpatialMeshUsageFlags): boolean;
	GetUnderlyingMesh(): MRMeshComponent;
	GetTrackingState(): EARTrackingState;
	GetObjectClassification(): EARObjectClassification;
	GetName(): string;
	GetLocalToWorldTransform(): Transform;
	GetLocalToTrackingTransform(): Transform;
	GetLastUpdateTimestamp(): number;
	GetLastUpdateFrameNumber(): number;
	GetDebugName(): string;
	static C(Other: UObject | any): ARTrackedGeometry;
	DebugDrawTrackedGeometry(WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
}

declare class ARTraceResult { 
	DistanceFromCamera: number;
	TraceChannel: EARLineTraceChannels;
	LocalTransform: Transform;
	TrackedGeometry: ARTrackedGeometry;
	clone() : ARTraceResult;
	static C(Other: UObject | any): ARTraceResult;
	GetDistanceFromCamera(): number;
	GetLocalToTrackingTransform(): Transform;
	GetLocalToWorldTransform(): Transform;
	GetLocalTransform(): Transform;
	GetTraceChannel(): EARLineTraceChannels;
	GetTrackedGeometry(): ARTrackedGeometry;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
}

declare type EHMDTrackingOrigin = 'Floor' | 'Eye' | 'Stage' | 'EHMDTrackingOrigin_MAX';
declare var EHMDTrackingOrigin : { Floor:'Floor',Eye:'Eye',Stage:'Stage',EHMDTrackingOrigin_MAX:'EHMDTrackingOrigin_MAX', };
declare class Vector2D { 
	X: any;
	Y: any;
	clone() : Vector2D;
	static C(Other: UObject | any): Vector2D;
	Conv_Vector2dToText(): string;
	Conv_Vector2dToString(): string;
	Add_Vector2DFloat(B: any): Vector2D;
	Add_Vector2DVector2D(B: Vector2D): Vector2D;
	BreakVector2D(X?: any,Y?: any): {X: any, Y: any};
	ClampAxes2D(MinAxisVal: any,MaxAxisVal: any): Vector2D;
	Conv_Vector2DToIntPoint(): IntPoint;
	Conv_Vector2DToVector(Z: number): Vector;
	CrossProduct2D(B: Vector2D): any;
	Distance2D(v2: Vector2D): any;
	DistanceSquared2D(v2: Vector2D): any;
	Divide_Vector2DFloat(B: any): Vector2D;
	Divide_Vector2DVector2D(B: Vector2D): Vector2D;
	DotProduct2D(B: Vector2D): any;
	EqualEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	EqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	GetAbs2D(): Vector2D;
	GetAbsMax2D(): any;
	GetMax2D(): any;
	GetMin2D(): any;
	GetRotated2D(AngleDeg: number): Vector2D;
	IsNearlyZero2D(Tolerance: number): boolean;
	IsZero2D(): boolean;
	MakeBox2D(Max: Vector2D): Box2D;
	Multiply_Vector2DFloat(B: any): Vector2D;
	Multiply_Vector2DVector2D(B: Vector2D): Vector2D;
	Negated2D(): Vector2D;
	Normal2D(): Vector2D;
	Normalize2D(Tolerance?: number): {A: Vector2D};
	NormalSafe2D(Tolerance: number): Vector2D;
	NotEqual_Vector2DVector2D(B: Vector2D,ErrorTolerance: number): boolean;
	NotEqualExactly_Vector2DVector2D(B: Vector2D): boolean;
	Set2D(X?: any,Y?: any): {A: Vector2D};
	Spherical2DToUnitCartesian(): Vector;
	Subtract_Vector2DFloat(B: any): Vector2D;
	Subtract_Vector2DVector2D(B: Vector2D): Vector2D;
	ToDirectionAndLength2D(OutDir?: Vector2D,OutLength?: any): {OutDir: Vector2D, OutLength: any};
	ToRounded2D(): Vector2D;
	ToSign2D(): Vector2D;
	Vector2DInterpTo(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	Vector2DInterpTo_Constant(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	VSize2D(): any;
	VSize2DSquared(): any;
	SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	LineTraceTrackedObjects(bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static Conv_Vector2dToText(InVec: Vector2D): string;
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Add_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static BreakVector2D(InVec: Vector2D,X?: any,Y?: any): {X: any, Y: any};
	static ClampAxes2D(A: Vector2D,MinAxisVal: any,MaxAxisVal: any): Vector2D;
	static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;
	static Conv_Vector2DToVector(InVector2D: Vector2D,Z: number): Vector;
	static CrossProduct2D(A: Vector2D,B: Vector2D): any;
	static Distance2D(v1: Vector2D,v2: Vector2D): any;
	static DistanceSquared2D(v1: Vector2D,v2: Vector2D): any;
	static Divide_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Divide_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static DotProduct2D(A: Vector2D,B: Vector2D): any;
	static EqualEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static EqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static GetAbs2D(A: Vector2D): Vector2D;
	static GetAbsMax2D(A: Vector2D): any;
	static GetMax2D(A: Vector2D): any;
	static GetMin2D(A: Vector2D): any;
	static GetRotated2D(A: Vector2D,AngleDeg: number): Vector2D;
	static IsNearlyZero2D(A: Vector2D,Tolerance: number): boolean;
	static IsZero2D(A: Vector2D): boolean;
	static MakeBox2D(Min: Vector2D,Max: Vector2D): Box2D;
	static Multiply_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static Negated2D(A: Vector2D): Vector2D;
	static Normal2D(A: Vector2D): Vector2D;
	static Normalize2D(A?: Vector2D,Tolerance?: number): {A: Vector2D};
	static NormalSafe2D(A: Vector2D,Tolerance: number): Vector2D;
	static NotEqual_Vector2DVector2D(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	static NotEqualExactly_Vector2DVector2D(A: Vector2D,B: Vector2D): boolean;
	static Set2D(A?: Vector2D,X?: any,Y?: any): {A: Vector2D};
	static Spherical2DToUnitCartesian(A: Vector2D): Vector;
	static Subtract_Vector2DFloat(A: Vector2D,B: any): Vector2D;
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	static ToDirectionAndLength2D(A: Vector2D,OutDir?: Vector2D,OutLength?: any): {OutDir: Vector2D, OutLength: any};
	static ToRounded2D(A: Vector2D): Vector2D;
	static ToSign2D(A: Vector2D): Vector2D;
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	static VSize2D(A: Vector2D): any;
	static VSize2DSquared(A: Vector2D): any;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	static MakeVector2D(X: any,Y: any): Vector2D;
	static Vector2D_One(): Vector2D;
	static Vector2D_Unit45Deg(): Vector2D;
	static Vector2D_Zero(): Vector2D;
	static NextSobolCell2D(index: number,NumCells: number,PreviousValue: Vector2D): Vector2D;
	static RandomSobolCell2D(index: number,NumCells: number,Cell: Vector2D,Seed: Vector2D): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
}

declare class VectorSpringState { 
	clone() : VectorSpringState;
	static C(Other: UObject | any): VectorSpringState;
	ResetVectorSpringState(): {SpringState: VectorSpringState};
	SetVectorSpringStateVelocity(Velocity?: Vector): {SpringState: VectorSpringState};
	static ResetVectorSpringState(SpringState?: VectorSpringState): {SpringState: VectorSpringState};
	static SetVectorSpringStateVelocity(SpringState?: VectorSpringState,Velocity?: Vector): {SpringState: VectorSpringState};
}

declare class Vector { 
	X: any;
	Y: any;
	Z: any;
	clone() : Vector;
	static C(Other: UObject | any): Vector;
	GenerateBoxMesh(Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	GetLevelViewportCameraInfo(CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	SetLevelViewportCameraInfo(CameraRotation: Rotator): void;
	SegmentIntersection2D(SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	GetSelectionBounds(BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	Conv_VectorToText(): string;
	Conv_VectorToString(): string;
	Add_VectorFloat(B: any): Vector;
	Add_VectorInt(B: number): Vector;
	Add_VectorVector(B: Vector): Vector;
	BreakVector(X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	ClampVectorSize(Min: any,Max: any): Vector;
	Conv_VectorToLinearColor(): LinearColor;
	Conv_VectorToQuaternion(): Quat;
	Conv_VectorToRotator(): Rotator;
	Conv_VectorToTransform(): Transform;
	Conv_VectorToVector2D(): Vector2D;
	Cross_VectorVector(B: Vector): Vector;
	Divide_VectorFloat(B: any): Vector;
	Divide_VectorInt(B: number): Vector;
	Divide_VectorVector(B: Vector): Vector;
	Dot_VectorVector(B: Vector): any;
	DynamicWeightedMovingAverage_FVector(PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	EqualEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	EqualExactly_VectorVector(B: Vector): boolean;
	FindClosestPointOnLine(LineOrigin: Vector,LineDirection: Vector): Vector;
	FindClosestPointOnSegment(SegmentStart: Vector,SegmentEnd: Vector): Vector;
	FindLookAtRotation(Target: Vector): Rotator;
	FindNearestPointsOnLineSegments(Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	FTruncVector(): IntVector;
	GetAzimuthAndElevation(ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	GetDirectionUnitVector(To: Vector): Vector;
	GetMaxElement(): any;
	GetMinElement(): any;
	GetPointDistanceToLine(LineOrigin: Vector,LineDirection: Vector): number;
	GetPointDistanceToSegment(SegmentStart: Vector,SegmentEnd: Vector): number;
	GetReflectionVector(SurfaceNormal: Vector): Vector;
	GetSlopeDegreeAngles(FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	GetYawPitchFromVector(Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	GreaterGreater_VectorRotator(B: Rotator): Vector;
	IsPointInBox(BoxOrigin: Vector,BoxExtent: Vector): boolean;
	IsPointInBoxWithTransform(BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	LessLess_VectorRotator(B: Rotator): Vector;
	LinePlaneIntersection(LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	LinePlaneIntersection_OriginNormal(LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	MakeBox(Max: Vector): Box;
	MakeBoxSphereBounds(BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	MakePlaneFromPointAndNormal(Normal: Vector): Plane;
	MakeRotationFromAxes(Right: Vector,Up: Vector): Rotator;
	MakeRotFromX(): Rotator;
	MakeRotFromXY(Y: Vector): Rotator;
	MakeRotFromXZ(Z: Vector): Rotator;
	MakeRotFromY(): Rotator;
	MakeRotFromYX(X: Vector): Rotator;
	MakeRotFromYZ(Z: Vector): Rotator;
	MakeRotFromZ(): Rotator;
	MakeRotFromZX(X: Vector): Rotator;
	MakeRotFromZY(Y: Vector): Rotator;
	MakeTransform(Rotation: Rotator,Scale: Vector): Transform;
	MirrorVectorByNormal(InNormal: Vector): Vector;
	Multiply_VectorFloat(B: any): Vector;
	Multiply_VectorInt(B: number): Vector;
	Multiply_VectorVector(B: Vector): Vector;
	NegateVector(): Vector;
	Normal(Tolerance: number): Vector;
	NotEqual_VectorVector(B: Vector,ErrorTolerance: number): boolean;
	NotEqualExactly_VectorVector(B: Vector): boolean;
	ProjectPointOnToPlane(PlaneBase: Vector,PlaneNormal: Vector): Vector;
	ProjectVectorOnToPlane(PlaneNormal: Vector): Vector;
	ProjectVectorOnToVector(Target: Vector): Vector;
	Quat_MakeFromEuler(): Quat;
	RandomPointInBoundingBox(HalfSize: Vector): Vector;
	RandomPointInBoundingBoxFromStream(HalfSize: Vector,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInDegrees(ConeHalfAngleInDegrees: number): Vector;
	RandomUnitVectorInConeInDegreesFromStream(ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInConeInRadians(ConeHalfAngleInRadians: number): Vector;
	RandomUnitVectorInConeInRadiansFromStream(ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInDegrees(MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	RandomUnitVectorInEllipticalConeInDegreesFromStream(MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	RandomUnitVectorInEllipticalConeInRadians(MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	RandomUnitVectorInEllipticalConeInRadiansFromStream(MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	RotateAngleAxis(AngleDeg: number,Axis: Vector): Vector;
	RotatorFromAxisAndAngle(Angle: number): Rotator;
	SelectVector(B: Vector,bPickA: boolean): Vector;
	Subtract_VectorFloat(B: any): Vector;
	Subtract_VectorInt(B: number): Vector;
	Subtract_VectorVector(B: Vector): Vector;
	VEase(B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	Vector_AddBounded(InAddVect?: Vector,InRadius?: number): {A: Vector};
	Vector_Assign(InVector?: Vector): {A: Vector};
	Vector_BoundedToBox(InBoxMin: Vector,InBoxMax: Vector): Vector;
	Vector_BoundedToCube(InRadius: number): Vector;
	Vector_ClampSize2D(Min: any,Max: any): Vector;
	Vector_ClampSizeMax(Max: any): Vector;
	Vector_ClampSizeMax2D(Max: any): Vector;
	Vector_ComponentMax(B: Vector): Vector;
	Vector_ComponentMin(B: Vector): Vector;
	Vector_CosineAngle2D(B: Vector): any;
	Vector_Distance(v2: Vector): any;
	Vector_Distance2D(v2: Vector): any;
	Vector_Distance2DSquared(v2: Vector): any;
	Vector_DistanceSquared(v2: Vector): any;
	Vector_GetAbs(): Vector;
	Vector_GetAbsMax(): any;
	Vector_GetAbsMin(): any;
	Vector_GetProjection(): Vector;
	Vector_GetSignVector(): Vector;
	Vector_HeadingAngle(): any;
	Vector_IsNAN(): boolean;
	Vector_IsNearlyZero(Tolerance: number): boolean;
	Vector_IsNormal(): boolean;
	Vector_IsUniform(Tolerance: number): boolean;
	Vector_IsUnit(SquaredLenthTolerance: number): boolean;
	Vector_IsZero(): boolean;
	Vector_MirrorByPlane(InPlane: Plane): Vector;
	Vector_Normal2D(Tolerance: number): Vector;
	Vector_Normalize(Tolerance?: number): {A: Vector};
	Vector_NormalUnsafe(): Vector;
	Vector_ProjectOnToNormal(InNormal: Vector): Vector;
	Vector_Reciprocal(): Vector;
	Vector_Set(X?: any,Y?: any,Z?: any): {A: Vector};
	Vector_SnappedToGrid(InGridSize: number): Vector;
	Vector_ToDegrees(): Vector;
	Vector_ToRadians(): Vector;
	Vector_UnitCartesianToSpherical(): Vector2D;
	Vector_UnwindEuler(): {A: Vector};
	VectorSpringInterp(Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	VInterpTo(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VInterpTo_Constant(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	VLerp(B: Vector,Alpha: number): Vector;
	VSize(): any;
	VSizeSquared(): any;
	VSizeXY(): any;
	VSizeXYSquared(): any;
	WeightedMovingAverage_FVector(PreviousSample: Vector,Weight: number): Vector;
	FindNearestActor(ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	CalculateDirection(BaseRotation: Rotator): number;
	K2_TwoBoneIK(JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	IsValidAIDirection(): boolean;
	IsValidAILocation(): boolean;
	GetPositionalTrackingCameraParameters(CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	GetTrackingSensorParameters(Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	AddManualEnvironmentCaptureProbe(Extent: Vector): boolean;
	GetObjectClassificationAtLocation(OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	LineTraceTrackedObjects3D(End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	SetARWorldOriginLocationAndRotation(OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static GetLevelViewportCameraInfo(CameraLocation?: Vector,CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	static SetLevelViewportCameraInfo(CameraLocation: Vector,CameraRotation: Rotator): void;
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	static GetSelectionBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static Conv_VectorToText(InVec: Vector): string;
	static Conv_VectorToString(InVec: Vector): string;
	static Add_VectorFloat(A: Vector,B: any): Vector;
	static Add_VectorInt(A: Vector,B: number): Vector;
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	static BreakVector(InVec: Vector,X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static ClampVectorSize(A: Vector,Min: any,Max: any): Vector;
	static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
	static Conv_VectorToQuaternion(InVec: Vector): Quat;
	static Conv_VectorToRotator(InVec: Vector): Rotator;
	static Conv_VectorToTransform(InLocation: Vector): Transform;
	static Conv_VectorToVector2D(InVector: Vector): Vector2D;
	static Cross_VectorVector(A: Vector,B: Vector): Vector;
	static Divide_VectorFloat(A: Vector,B: any): Vector;
	static Divide_VectorInt(A: Vector,B: number): Vector;
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	static Dot_VectorVector(A: Vector,B: Vector): any;
	static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,MaxDistance: number,MinWeight: number,MaxWeight: number): Vector;
	static EqualEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static EqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	static FTruncVector(InVector: Vector): IntVector;
	static GetAzimuthAndElevation(InDirection: Vector,ReferenceFrame: Transform,Azimuth?: number,Elevation?: number): {Azimuth: number, Elevation: number};
	static GetDirectionUnitVector(From: Vector,To: Vector): Vector;
	static GetMaxElement(A: Vector): any;
	static GetMinElement(A: Vector): any;
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	static GetReflectionVector(Direction: Vector,SurfaceNormal: Vector): Vector;
	static GetSlopeDegreeAngles(MyRightYAxis: Vector,FloorNormal: Vector,UpVector: Vector,OutSlopePitchDegreeAngle?: number,OutSlopeRollDegreeAngle?: number): {OutSlopePitchDegreeAngle: number, OutSlopeRollDegreeAngle: number};
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	static GreaterGreater_VectorRotator(A: Vector,B: Rotator): Vector;
	static IsPointInBox(Point: Vector,BoxOrigin: Vector,BoxExtent: Vector): boolean;
	static IsPointInBoxWithTransform(Point: Vector,BoxWorldTransform: Transform,BoxExtent: Vector): boolean;
	static LessLess_VectorRotator(A: Vector,B: Rotator): Vector;
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static LinePlaneIntersection_OriginNormal(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	static MakeBox(Min: Vector,Max: Vector): Box;
	static MakeBoxSphereBounds(Origin: Vector,BoxExtent: Vector,SphereRadius: number): BoxSphereBounds;
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	static MakeRotFromX(X: Vector): Rotator;
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	static MakeRotFromY(Y: Vector): Rotator;
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	static MakeRotFromZ(Z: Vector): Rotator;
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	static Multiply_VectorFloat(A: Vector,B: any): Vector;
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	static NegateVector(A: Vector): Vector;
	static Normal(A: Vector,Tolerance: number): Vector;
	static NotEqual_VectorVector(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	static NotEqualExactly_VectorVector(A: Vector,B: Vector): boolean;
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	static Quat_MakeFromEuler(Euler: Vector): Quat;
	static RandomPointInBoundingBox(Center: Vector,HalfSize: Vector): Vector;
	static RandomPointInBoundingBoxFromStream(Center: Vector,HalfSize: Vector,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInDegrees(ConeDir: Vector,ConeHalfAngleInDegrees: number): Vector;
	static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector,ConeHalfAngleInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInConeInRadians(ConeDir: Vector,ConeHalfAngleInRadians: number): Vector;
	static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector,ConeHalfAngleInRadians: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number,Stream: RandomStream): Vector;
	static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number): Vector;
	static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector,MaxYawInRadians: number,MaxPitchInRadians: number,Stream: RandomStream): Vector;
	static RotateAngleAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	static Subtract_VectorFloat(A: Vector,B: any): Vector;
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	static VEase(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	static Vector_AddBounded(A?: Vector,InAddVect?: Vector,InRadius?: number): {A: Vector};
	static Vector_Assign(A?: Vector,InVector?: Vector): {A: Vector};
	static Vector_BoundedToBox(InVect: Vector,InBoxMin: Vector,InBoxMax: Vector): Vector;
	static Vector_BoundedToCube(InVect: Vector,InRadius: number): Vector;
	static Vector_ClampSize2D(A: Vector,Min: any,Max: any): Vector;
	static Vector_ClampSizeMax(A: Vector,Max: any): Vector;
	static Vector_ClampSizeMax2D(A: Vector,Max: any): Vector;
	static Vector_ComponentMax(A: Vector,B: Vector): Vector;
	static Vector_ComponentMin(A: Vector,B: Vector): Vector;
	static Vector_CosineAngle2D(A: Vector,B: Vector): any;
	static Vector_Distance(v1: Vector,v2: Vector): any;
	static Vector_Distance2D(v1: Vector,v2: Vector): any;
	static Vector_Distance2DSquared(v1: Vector,v2: Vector): any;
	static Vector_DistanceSquared(v1: Vector,v2: Vector): any;
	static Vector_GetAbs(A: Vector): Vector;
	static Vector_GetAbsMax(A: Vector): any;
	static Vector_GetAbsMin(A: Vector): any;
	static Vector_GetProjection(A: Vector): Vector;
	static Vector_GetSignVector(A: Vector): Vector;
	static Vector_HeadingAngle(A: Vector): any;
	static Vector_IsNAN(A: Vector): boolean;
	static Vector_IsNearlyZero(A: Vector,Tolerance: number): boolean;
	static Vector_IsNormal(A: Vector): boolean;
	static Vector_IsUniform(A: Vector,Tolerance: number): boolean;
	static Vector_IsUnit(A: Vector,SquaredLenthTolerance: number): boolean;
	static Vector_IsZero(A: Vector): boolean;
	static Vector_MirrorByPlane(A: Vector,InPlane: Plane): Vector;
	static Vector_Normal2D(A: Vector,Tolerance: number): Vector;
	static Vector_Normalize(A?: Vector,Tolerance?: number): {A: Vector};
	static Vector_NormalUnsafe(A: Vector): Vector;
	static Vector_ProjectOnToNormal(V: Vector,InNormal: Vector): Vector;
	static Vector_Reciprocal(A: Vector): Vector;
	static Vector_Set(A?: Vector,X?: any,Y?: any,Z?: any): {A: Vector};
	static Vector_SnappedToGrid(InVect: Vector,InGridSize: number): Vector;
	static Vector_ToDegrees(A: Vector): Vector;
	static Vector_ToRadians(A: Vector): Vector;
	static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;
	static Vector_UnwindEuler(A?: Vector): {A: Vector};
	static VectorSpringInterp(Current: Vector,Target: Vector,SpringState?: VectorSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bClamp?: boolean,MinValue?: Vector,MaxValue?: Vector,bInitializeFromTarget?: boolean): {SpringState: VectorSpringState, $: Vector};
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	static VLerp(A: Vector,B: Vector,Alpha: number): Vector;
	static VSize(A: Vector): any;
	static VSizeSquared(A: Vector): any;
	static VSizeXY(A: Vector): any;
	static VSizeXYSquared(A: Vector): any;
	static WeightedMovingAverage_FVector(CurrentSample: Vector,PreviousSample: Vector,Weight: number): Vector;
	static FindNearestActor(Origin: Vector,ActorsToCheck: Actor[],Distance?: number): {Distance: number, $: Actor};
	static CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	static K2_TwoBoneIK(RootPos: Vector,JointPos: Vector,EndPos: Vector,JointTarget: Vector,Effector: Vector,OutJointPos?: Vector,OutEndPos?: Vector,bAllowStretching?: boolean,StartStretchRatio?: number,MaxStretchScale?: number): {OutJointPos: Vector, OutEndPos: Vector};
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static Conv_DoubleToVector(InDouble: any): Vector;
	static Conv_FloatToVector(InFloat: number): Vector;
	static Conv_IntToVector(inInt: number): Vector;
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	static MakeVector(X: any,Y: any,Z: any): Vector;
	static RandomUnitVector(): Vector;
	static Vector_Backward(): Vector;
	static Vector_Down(): Vector;
	static Vector_Forward(): Vector;
	static Vector_Left(): Vector;
	static Vector_One(): Vector;
	static Vector_Right(): Vector;
	static Vector_Up(): Vector;
	static Vector_Zero(): Vector;
	static NextSobolCell3D(index: number,NumCells: number,PreviousValue: Vector): Vector;
	static RandomSobolCell3D(index: number,NumCells: number,Cell: Vector,Seed: Vector): Vector;
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
	static K2_MakePerlinNoiseVectorAndRemap(X: number,Y: number,Z: number,RangeOutMinX: number,RangeOutMaxX: number,RangeOutMinY: number,RangeOutMaxY: number,RangeOutMinZ: number,RangeOutMaxZ: number): Vector;
}

declare type EVectorQuantization = 'RoundWholeNumber' | 'RoundOneDecimal' | 'RoundTwoDecimals' | 'EVectorQuantization_MAX';
declare var EVectorQuantization : { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals',EVectorQuantization_MAX:'EVectorQuantization_MAX', };
declare type ERotatorQuantization = 'ByteComponents' | 'ShortComponents' | 'ERotatorQuantization_MAX';
declare var ERotatorQuantization : { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents',ERotatorQuantization_MAX:'ERotatorQuantization_MAX', };
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	LocationQuantizationLevel: EVectorQuantization;
	VelocityQuantizationLevel: EVectorQuantization;
	RotationQuantizationLevel: ERotatorQuantization;
	clone() : RepMovement;
	static C(Other: UObject | any): RepMovement;
}

declare type EActorGridPlacement = 'Bounds' | 'Location' | 'AlwaysLoaded' | 'None' | 'EActorGridPlacement_MAX';
declare var EActorGridPlacement : { Bounds:'Bounds',Location:'Location',AlwaysLoaded:'AlwaysLoaded',None:'None',EActorGridPlacement_MAX:'EActorGridPlacement_MAX', };
declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject | any): RepAttachment;
}

declare type ENetDormancy = 'DORM_Never' | 'DORM_Awake' | 'DORM_DormantAll' | 'DORM_DormantPartial' | 'DORM_Initial' | 'DORM_MAX';
declare var ENetDormancy : { DORM_Never:'DORM_Never',DORM_Awake:'DORM_Awake',DORM_DormantAll:'DORM_DormantAll',DORM_DormantPartial:'DORM_DormantPartial',DORM_Initial:'DORM_Initial',DORM_MAX:'DORM_MAX', };
declare type EChildActorComponentTreeViewVisualizationMode = 'UseDefault' | 'ComponentOnly' | 'ComponentWithChildActor' | 'ChildActorOnly' | 'EChildActorComponentTreeViewVisualizationMode_MAX';
declare var EChildActorComponentTreeViewVisualizationMode : { UseDefault:'UseDefault',ComponentOnly:'ComponentOnly',ComponentWithChildActor:'ComponentWithChildActor',ChildActorOnly:'ChildActorOnly',EChildActorComponentTreeViewVisualizationMode_MAX:'EChildActorComponentTreeViewVisualizationMode_MAX', };
declare class ChildActorComponent extends SceneComponent { 
	ChildActorClass: UnrealEngineClass;
	ChildActor: Actor;
	ChildActorTemplate: Actor;
	EditorTreeViewVisualizationMode: EChildActorComponentTreeViewVisualizationMode;
	static Load(ResourceName: string): ChildActorComponent;
	static Find(Outer: UObject, ResourceName: string): ChildActorComponent;
	static GetDefaultObject(): ChildActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildActorComponent;
	SetChildActorClass(InClass: UnrealEngineClass): void;
	static C(Other: UObject | any): ChildActorComponent;
}

declare class ScriptTypedElementHandle { 
	clone() : ScriptTypedElementHandle;
	static C(Other: UObject | any): ScriptTypedElementHandle;
}

declare class Actor extends UObject { 
	PrimaryActorTick: ActorTickFunction;
	bNetTemporary: boolean;
	bNetStartup: boolean;
	bOnlyRelevantToOwner: boolean;
	bAlwaysRelevant: boolean;
	bReplicateMovement: boolean;
	bCallPreReplication: boolean;
	bCallPreReplicationForReplay: boolean;
	bHidden: boolean;
	bTearOff: boolean;
	bForceNetAddressable: boolean;
	bIsInEditingLevelInstance: boolean;
	bExchangedRoles: boolean;
	bNetLoadOnClient: boolean;
	bNetUseOwnerRelevancy: boolean;
	bRelevantForNetworkReplays: boolean;
	bRelevantForLevelBounds: boolean;
	bReplayRewindable: boolean;
	bAllowTickBeforeBeginPlay: boolean;
	bAutoDestroyWhenFinished: boolean;
	bCanBeDamaged: boolean;
	bBlockInput: boolean;
	bCollideWhenPlacing: boolean;
	bFindCameraComponentWhenViewTarget: boolean;
	bGenerateOverlapEventsDuringLevelStreaming: boolean;
	bIgnoresOriginShifting: boolean;
	bEnableAutoLODGeneration: boolean;
	bIsEditorOnlyActor: boolean;
	bActorSeamlessTraveled: boolean;
	bReplicates: boolean;
	bCanBeInCluster: boolean;
	bAllowReceiveTickEventOnDedicatedServer: boolean;
	bActorEnableCollision: boolean;
	bActorIsBeingDestroyed: boolean;
	UpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	DefaultUpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
	RemoteRole: ENetRole;
	ReplicatedMovement: RepMovement;
	InitialLifeSpan: number;
	CustomTimeDilation: number;
	GridPlacement: EActorGridPlacement;
	RuntimeGrid: string;
	AttachmentReplication: RepAttachment;
	Owner: Actor;
	NetDriverName: string;
	Role: ENetRole;
	NetDormancy: ENetDormancy;
	SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
	AutoReceiveInput: EAutoReceiveInput;
	InputPriority: number;
	InputComponent: InputComponent;
	NetCullDistanceSquared: number;
	NetTag: number;
	NetUpdateFrequency: number;
	MinNetUpdateFrequency: number;
	NetPriority: number;
	Instigator: Pawn;
	Children: Actor[];
	RootComponent: SceneComponent;
	PivotOffset: Vector;
	HLODLayer: HLODLayer;
	RayTracingGroupId: number;
	Layers: string[];
	ParentComponentActor: any;
	ParentComponent: any;
	ActorGuid: Guid;
	DataLayers: ActorDataLayer[];
	GroupActor: Actor;
	SpriteScale: number;
	HiddenEditorViews: any;
	ActorLabel: string;
	FolderPath: string;
	FolderGuid: Guid;
	bHiddenEd: boolean;
	bIsEditorPreviewActor: boolean;
	bHiddenEdLayer: boolean;
	bHiddenEdLevel: boolean;
	bLockLocation: boolean;
	bActorLabelEditable: boolean;
	bEditable: boolean;
	bListedInSceneOutliner: boolean;
	bOptimizeBPComponentData: boolean;
	bCanPlayFromHere: boolean;
	bIsSpatiallyLoaded: boolean;
	bHiddenEdTemporary: boolean;
	bForceExternalActorLevelReferenceForPIE: boolean;
	Tags: string[];
	OnTakeAnyDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnTakePointDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnTakeRadialDamage: UnrealEngineMulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, Origin: Vector, HitInfo: HitResult, InstigatedBy: Controller, DamageCauser: Actor) => void>;
	OnActorBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnActorEndOverlap: UnrealEngineMulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedActor: Actor) => void>;
	OnClicked: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonPressed: Key) => void>;
	OnReleased: UnrealEngineMulticastDelegate<(TouchedActor: Actor, ButtonReleased: Key) => void>;
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedActor: Actor) => void>;
	OnActorHit: UnrealEngineMulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
	OnDestroyed: UnrealEngineMulticastDelegate<(DestroyedActor: Actor) => void>;
	OnEndPlay: UnrealEngineMulticastDelegate<(Actor: Actor, EndPlayReason: EEndPlayReason) => void>;
	InstanceComponents: ActorComponent[];
	BlueprintCreatedComponents: ActorComponent[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static GetDefaultObject(): Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Actor;
	WasRecentlyRendered(Tolerance: number): boolean;
	UserConstructionScript(): void;
	TearOff(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetReplicates(bInReplicates: boolean): void;
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	SetRayTracingGroupId(InRaytracingGroupId: number): void;
	SetOwner(NewOwner: Actor): void;
	SetNetDormancy(NewDormancy: ENetDormancy): void;
	SetLifeSpan(InLifespan: number): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	SetFolderPath(NewFolderPath: string): void;
	SetAutoDestroyWhenFinished(bVal: boolean): void;
	SetActorTickInterval(TickInterval: number): void;
	SetActorTickEnabled(bEnabled: boolean): void;
	SetActorScale3D(NewScale3D: Vector): void;
	SetActorRelativeScale3D(NewRelativeScale: Vector): void;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorHiddenInGame(bNewHidden: boolean): void;
	SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveRadialDamage(DamageReceived: number,DamageType: DamageType,Origin: Vector,HitInfo: HitResult,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceivePointDamage(Damage: number,DamageType: DamageType,HitLocation: Vector,HitNormal: Vector,HitComponent: PrimitiveComponent,BoneName: string,ShotFromDirection: Vector,InstigatedBy: Controller,DamageCauser: Actor,HitInfo: HitResult): void;
	ReceiveHit(MyComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,bSelfMoved: boolean,HitLocation: Vector,HitNormal: Vector,NormalImpulse: Vector,Hit: HitResult): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveDestroyed(): void;
	ReceiveBeginPlay(): void;
	ReceiveAnyDamage(Damage: number,DamageType: DamageType,InstigatedBy: Controller,DamageCauser: Actor): void;
	ReceiveActorOnReleased(ButtonReleased: Key): void;
	ReceiveActorOnInputTouchLeave(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnter(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchEnd(FingerIndex: ETouchIndex): void;
	ReceiveActorOnInputTouchBegin(FingerIndex: ETouchIndex): void;
	ReceiveActorOnClicked(ButtonPressed: Key): void;
	ReceiveActorEndOverlap(OtherActor: Actor): void;
	ReceiveActorEndCursorOver(): void;
	ReceiveActorBeginOverlap(OtherActor: Actor): void;
	ReceiveActorBeginCursorOver(): void;
	PrestreamTextures(Seconds: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	OnRep_ReplicateMovement(): void;
	OnRep_ReplicatedMovement(): void;
	OnRep_Owner(): void;
	OnRep_Instigator(): void;
	OnRep_AttachmentReplication(): void;
	MakeNoise(Loudness: number,NoiseInstigator: Pawn,NoiseLocation: Vector,MaxRange: number,Tag: string): void;
	K2_TeleportTo(DestLocation: Vector,DestRotation: Rotator): boolean;
	K2_SetActorTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorRotation(NewRotation: Rotator,bTeleportPhysics: boolean): boolean;
	K2_SetActorRelativeTransform(NewRelativeTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeRotation(NewRelativeRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorRelativeLocation(NewRelativeLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_SetActorLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	K2_OnReset(): void;
	K2_OnEndViewTarget(PC: PlayerController): void;
	K2_OnBecomeViewTarget(PC: PlayerController): void;
	K2_GetRootComponent(): SceneComponent;
	K2_GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	K2_GetActorRotation(): Rotator;
	K2_GetActorLocation(): Vector;
	K2_DetachFromActor(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule): void;
	K2_DestroyActor(): void;
	K2_AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachToActor(ParentActor: Actor,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentToActor(InParentActor: Actor,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AttachRootComponentTo(InParent: SceneComponent,InSocketName: string,AttachLocationType: EAttachLocation,bWeldSimulatedBodies: boolean): void;
	K2_AddActorWorldTransformKeepScale(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	K2_AddActorLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	IsTemporarilyHiddenInEditor(bIncludeParent: boolean): boolean;
	IsSelectable(): boolean;
	IsOverlappingActor(Other: Actor): boolean;
	IsHiddenEdAtStartup(): boolean;
	IsHiddenEd(): boolean;
	IsEditable(): boolean;
	IsChildActor(): boolean;
	IsActorTickEnabled(): boolean;
	IsActorBeingDestroyed(): boolean;
	HasAuthority(): boolean;
	GetVerticalDistanceTo(OtherActor: Actor): number;
	GetVelocity(): Vector;
	GetTransform(): Transform;
	GetTickableWhenPaused(): boolean;
	GetSquaredHorizontalDistanceTo(OtherActor: Actor): number;
	GetSquaredDistanceTo(OtherActor: Actor): number;
	GetRemoteRole(): ENetRole;
	GetRayTracingGroupId(): number;
	GetParentComponent(): ChildActorComponent;
	GetParentActor(): Actor;
	GetOwner(): Actor;
	GetOverlappingComponents(OverlappingComponents?: PrimitiveComponent[]): {OverlappingComponents: PrimitiveComponent[]};
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	GetLocalRole(): ENetRole;
	GetLifeSpan(): number;
	GetLevelTransform(): Transform;
	GetLevel(): Level;
	GetInstigatorController(): Controller;
	GetInstigator(): Pawn;
	GetInputVectorAxisValue(InputAxisKey: Key): Vector;
	GetInputAxisValue(InputAxisName: string): number;
	GetInputAxisKeyValue(InputAxisKey: Key): number;
	GetHorizontalDotProductTo(OtherActor: Actor): number;
	GetHorizontalDistanceTo(OtherActor: Actor): number;
	GetGameTimeSinceCreation(): number;
	GetFolderPath(): string;
	GetDotProductTo(OtherActor: Actor): number;
	GetDistanceTo(OtherActor: Actor): number;
	GetDefaultActorLabel(): string;
	GetComponentsByTag(ComponentClass: UnrealEngineClass,Tag: string): ActorComponent[];
	GetComponentsByInterface(Interface: UnrealEngineClass): ActorComponent[];
	GetComponentByClass(ComponentClass: UnrealEngineClass): ActorComponent;
	GetAttachParentSocketName(): string;
	GetAttachParentActor(): Actor;
	GetAttachedActors(OutActors?: Actor[],bResetArray?: boolean,bRecursivelyIncludeAttachedActors?: boolean): {OutActors: Actor[]};
	GetAllChildActors(ChildActors?: Actor[],bIncludeDescendants?: boolean): {ChildActors: Actor[]};
	GetActorUpVector(): Vector;
	GetActorTimeDilation(): number;
	GetActorTickInterval(): number;
	GetActorScale3D(): Vector;
	GetActorRightVector(): Vector;
	GetActorRelativeScale3D(): Vector;
	GetActorLabel(bCreateIfNone: boolean): string;
	GetActorForwardVector(): Vector;
	GetActorEyesViewPoint(OutLocation?: Vector,OutRotation?: Rotator): {OutLocation: Vector, OutRotation: Rotator};
	GetActorEnableCollision(): boolean;
	GetActorBounds(bOnlyCollidingComponents: boolean,Origin?: Vector,BoxExtent?: Vector,bIncludeFromChildActors?: boolean): {Origin: Vector, BoxExtent: Vector};
	ForceNetUpdate(): void;
	FlushNetDormancy(): void;
	FinishAddComponent(Component: ActorComponent,bManualAttachment: boolean,RelativeTransform: Transform): void;
	EnableInput(PlayerController: PlayerController): void;
	DisableInput(PlayerController: PlayerController): void;
	DetachRootComponentFromParent(bMaintainWorldPosition: boolean): void;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	AddComponentByClass(Class: UnrealEngineClass,bManualAttachment: boolean,RelativeTransform: Transform,bDeferredFinish: boolean): ActorComponent;
	AddComponent(TemplateName: string,bManualAttachment: boolean,RelativeTransform: Transform,ComponentTemplateContext: UObject,bDeferredFinish: boolean): ActorComponent;
	ActorHasTag(Tag: string): boolean;
	static C(Other: UObject | any): Actor;
	ClearActorLabel(): void;
	GetActorLabel(): string;
	GetActorLocation(): Vector;
	GetActorRotation(): Rotator;
	GetFolderPath(): string;
	IsActorLabelEditable(): boolean;
	SetActorLabel(NewActorLabel: string,bMarkDirty: boolean): void;
	SetActorLabelUnique(NewActorLabel: string,InExistingActorLabels: string[]): void;
	SetActorLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	SetFolderPath(NewFolderPath: string): void;
	SetFolderPath_Recursively(NewFolderPath: string): void;
	SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
	AddActorToLayer(Layer: ActorLayer): void;
	RemoveActorFromLayer(Layer: ActorLayer): void;
	DestroyActor(): boolean;
	PilotLevelActor(): void;
	SetActorSelectionState(bShouldBeSelected: boolean): void;
	Actor_GetWorld(): World;
	GetComponentsByClass(ComponentClass: UnrealEngineClass): ActorComponent[];
	GetLastRenderTime(): number;
	GetLevel(): Level;
	IsPendingKill(): boolean;
	ReregisterAllComponents(): void;
	SetActorFlags(Flags: number): void;
	SetRootComponent(Component: SceneComponent): void;
	ConvertActorToLightWeightInstance(): ActorInstanceHandle;
	GetActorBounds(Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	ApplyDamage(BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	ApplyPointDamage(BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	FinishSpawningActor(SpawnTransform: Transform): Actor;
	K2_AcquireEditorActorElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	GetAIController(): AIController;
	GetBlackboard(): BlackboardComponent;
	AddDeviceVisualizationComponentBlocking(XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	AddNamedDeviceVisualizationComponentBlocking(SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static ClearActorLabel(Actor: Actor): void;
	static GetActorLabel(Actor: Actor): string;
	static GetActorLocation(Actor: Actor): Vector;
	static GetActorRotation(Actor: Actor): Rotator;
	static GetFolderPath(Actor: Actor): string;
	static IsActorLabelEditable(Actor: Actor): boolean;
	static SetActorLabel(Actor: Actor,NewActorLabel: string,bMarkDirty: boolean): void;
	static SetActorLabelUnique(Actor: Actor,NewActorLabel: string,InExistingActorLabels: string[]): void;
	static SetActorLocation(Actor: Actor,NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult, $: boolean};
	static SetFolderPath(Actor: Actor,NewFolderPath: string): void;
	static SetFolderPath_Recursively(Actor: Actor,NewFolderPath: string): void;
	static SetIsTemporarilyHiddenInEditor(Actor: Actor,bIsHidden: boolean): void;
	static AddActorToLayer(InActor: Actor,Layer: ActorLayer): void;
	static RemoveActorFromLayer(InActor: Actor,Layer: ActorLayer): void;
	static DestroyActor(ActorToDestroy: Actor): boolean;
	static PilotLevelActor(ActorToPilot: Actor): void;
	static SetActorSelectionState(Actor: Actor,bShouldBeSelected: boolean): void;
	static Actor_GetWorld(Actor: Actor): World;
	static GetComponentsByClass(Actor: Actor,ComponentClass: UnrealEngineClass): ActorComponent[];
	static GetLastRenderTime(Actor: Actor): number;
	static GetLevel(Actor: Actor): Level;
	static IsPendingKill(InActor: Actor): boolean;
	static ReregisterAllComponents(Actor: Actor): void;
	static SetActorFlags(Actor: Actor,Flags: number): void;
	static SetRootComponent(Actor: Actor,Component: SceneComponent): void;
	static ConvertActorToLightWeightInstance(Actor: Actor): ActorInstanceHandle;
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ApplyDamage(DamagedActor: Actor,BaseDamage: number,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static ApplyPointDamage(DamagedActor: Actor,BaseDamage: number,HitFromDirection: Vector,HitInfo: HitResult,EventInstigator: Controller,DamageCauser: Actor,DamageTypeClass: UnrealEngineClass): number;
	static FinishSpawningActor(Actor: Actor,SpawnTransform: Transform): Actor;
	static K2_AcquireEditorActorElementHandle(Actor: Actor,bAllowCreate: boolean): ScriptTypedElementHandle;
	static GetAIController(ControlledActor: Actor): AIController;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
}

declare class ActorComponent extends UObject { 
	PrimaryComponentTick: ActorComponentTickFunction;
	ComponentTags: string[];
	AssetUserData: AssetUserData[];
	UCSSerializationIndex: number;
	bNetAddressable: boolean;
	bReplicates: boolean;
	bCreatedByConstructionScript: boolean;
	bInstanceComponent: boolean;
	bAutoActivate: boolean;
	bIsActive: boolean;
	bEditableWhenInherited: boolean;
	bCanEverAffectNavigation: boolean;
	bIsEditorOnly: boolean;
	bIsVisualizationComponent: boolean;
	bNeedsUCSSerializationIndexEvaluted: boolean;
	CreationMethod: EComponentCreationMethod;
	OnComponentActivated: UnrealEngineMulticastDelegate<(Component: ActorComponent, bReset: boolean) => void>;
	OnComponentDeactivated: UnrealEngineMulticastDelegate<(Component: ActorComponent) => void>;
	UCSModifiedProperties: SimpleMemberReference[];
	static Load(ResourceName: string): ActorComponent;
	static Find(Outer: UObject, ResourceName: string): ActorComponent;
	static GetDefaultObject(): ActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	ToggleActive(): void;
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	SetIsReplicated(ShouldReplicate: boolean): void;
	SetComponentTickIntervalAndCooldown(TickInterval: number): void;
	SetComponentTickInterval(TickInterval: number): void;
	SetComponentTickEnabled(bEnabled: boolean): void;
	SetAutoActivate(bNewAutoActivate: boolean): void;
	SetActive(bNewActive: boolean,bReset: boolean): void;
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	ReceiveTick(DeltaSeconds: number): void;
	ReceiveEndPlay(EndPlayReason: EEndPlayReason): void;
	ReceiveBeginPlay(): void;
	OnRep_IsActive(): void;
	K2_DestroyComponent(UObject: UObject): void;
	IsComponentTickEnabled(): boolean;
	IsBeingDestroyed(): boolean;
	IsActive(): boolean;
	GetOwner(): Actor;
	GetComponentTickInterval(): number;
	Deactivate(): void;
	ComponentHasTag(Tag: string): boolean;
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	Activate(bReset: boolean): void;
	static C(Other: UObject | any): ActorComponent;
	IsRegistered(): boolean;
	MarkRenderStateDirty(): void;
	RegisterComponent(): void;
	ReregisterComponent(): void;
	UnregisterComponent(): void;
	K2_AcquireEditorComponentElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	static MarkRenderStateDirty(Component: ActorComponent): void;
	static RegisterComponent(ActorComponent: ActorComponent): void;
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	static UnregisterComponent(ActorComponent: ActorComponent): void;
	static K2_AcquireEditorComponentElementHandle(Component: ActorComponent,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare class BlueprintComponentChangedPropertyInfo { 
	PropertyName: string;
	ArrayIndex: number;
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject | any): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	bHasValidCookedData: boolean;
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject | any): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject | any): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	InternalVariableName: string;
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static GetDefaultObject(): SCS_Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject | any): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	AllNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static GetDefaultObject(): SimpleConstructionScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject | any): SimpleConstructionScript;
}

declare type ETimelineLengthMode = 'TL_TimelineLength' | 'TL_LastKeyFrame' | 'TL_MAX';
declare var ETimelineLengthMode : { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame',TL_MAX:'TL_MAX', };
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
	bIsExpanded: boolean;
	bIsCurveViewSynchronized: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject | any): TTTrackBase;
}

declare class TTEventTrack extends TTTrackBase { 
	FunctionName: string;
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject | any): TTEventTrack;
}

declare class TTPropertyTrack extends TTTrackBase { 
	PropertyName: string;
	clone() : TTPropertyTrack;
	static C(Other: UObject | any): TTPropertyTrack;
}

declare class TTFloatTrack extends TTPropertyTrack { 
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject | any): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static GetDefaultObject(): CurveVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject | any): CurveVector;
}

declare class TTVectorTrack extends TTPropertyTrack { 
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject | any): TTVectorTrack;
}

declare class TTLinearColorTrack extends TTPropertyTrack { 
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject | any): TTLinearColorTrack;
}

declare class TTTrackId { 
	TrackType: number;
	TrackIndex: number;
	clone() : TTTrackId;
	static C(Other: UObject | any): TTTrackId;
}

declare class TimelineTemplate extends UObject { 
	TimeLineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	TimelineTickGroup: ETickingGroup;
	VariableName: string;
	DirectionPropertyName: string;
	UpdateFunctionName: string;
	FinishedFunctionName: string;
	TrackDisplayOrder: TTTrackId[];
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static GetDefaultObject(): TimelineTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject | any): TimelineTemplate;
}

declare class BPComponentClassOverride { 
	ComponentName: string;
	ComponentClass: UnrealEngineClass;
	clone() : BPComponentClassOverride;
	static C(Other: UObject | any): BPComponentClassOverride;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject | any): ComponentKey;
}

declare class ComponentOverrideRecord { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject | any): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	UnnecessaryComponents: ActorComponent[];
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static GetDefaultObject(): InheritableComponentHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject | any): InheritableComponentHandler;
}

declare type ELifetimeCondition = 'COND_None' | 'COND_InitialOnly' | 'COND_OwnerOnly' | 'COND_SkipOwner' | 'COND_SimulatedOnly' | 'COND_AutonomousOnly' | 'COND_SimulatedOrPhysics' | 'COND_InitialOrOwner' | 'COND_Custom' | 'COND_ReplayOrOwner' | 'COND_ReplayOnly' | 'COND_SimulatedOnlyNoReplay' | 'COND_SimulatedOrPhysicsNoReplay' | 'COND_SkipReplay' | 'COND_Never' | 'COND_Max';
declare var ELifetimeCondition : { COND_None:'COND_None',COND_InitialOnly:'COND_InitialOnly',COND_OwnerOnly:'COND_OwnerOnly',COND_SkipOwner:'COND_SkipOwner',COND_SimulatedOnly:'COND_SimulatedOnly',COND_AutonomousOnly:'COND_AutonomousOnly',COND_SimulatedOrPhysics:'COND_SimulatedOrPhysics',COND_InitialOrOwner:'COND_InitialOrOwner',COND_Custom:'COND_Custom',COND_ReplayOrOwner:'COND_ReplayOrOwner',COND_ReplayOnly:'COND_ReplayOnly',COND_SimulatedOnlyNoReplay:'COND_SimulatedOnlyNoReplay',COND_SimulatedOrPhysicsNoReplay:'COND_SimulatedOrPhysicsNoReplay',COND_SkipReplay:'COND_SkipReplay',COND_Never:'COND_Never',COND_Max:'COND_Max', };
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: any;
	RepNotifyFunc: string;
	ReplicationCondition: ELifetimeCondition;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject | any): BPVariableDescription;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject | any): BPInterfaceDescription;
}

declare class BPEditorBookmarkNode { 
	NodeGuid: Guid;
	ParentGuid: Guid;
	DisplayName: string;
	clone() : BPEditorBookmarkNode;
	static C(Other: UObject | any): BPEditorBookmarkNode;
}

declare class Breakpoint extends UObject { 
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static GetDefaultObject(): Breakpoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject | any): Breakpoint;
}

declare class EdGraphPinReference { 
	OwningNode: any;
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject | any): EdGraphPinReference;
}

declare class BlueprintExtension extends UObject { 
	static Load(ResourceName: string): BlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): BlueprintExtension;
	static GetDefaultObject(): BlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintExtension;
	static C(Other: UObject | any): BlueprintExtension;
}

declare class Blueprint extends BlueprintCore { 
	ParentClass: UnrealEngineClass;
	BlueprintType: EBlueprintType;
	bRecompileOnLoad: boolean;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bBeingCompiled: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bQueuedForCompilation: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bRunConstructionScriptInSequencer: boolean;
	bGenerateConstClass: boolean;
	bGenerateAbstractClass: boolean;
	bDisplayCompilePIEWarning: boolean;
	bDeprecate: boolean;
	bDuplicatingReadOnly: boolean;
	NativizationFlag: EBlueprintNativizationFlag;
	CompileMode: EBlueprintCompileMode;
	Status: EBlueprintStatus;
	BlueprintDisplayName: string;
	BlueprintDescription: string;
	BlueprintNamespace: string;
	BlueprintCategory: string;
	HideCategories: string[];
	BlueprintSystemVersion: number;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	PRIVATE_CachedMacroInfo: any;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	InheritableComponentHandler: InheritableComponentHandler;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImportedNamespaces: any;
	ImplementedInterfaces: BPInterfaceDescription[];
	LastEditedDocuments: EditedDocumentInfo[];
	Bookmarks: any;
	BookmarkNodes: BPEditorBookmarkNode[];
	Breakpoints: Breakpoint[];
	WatchedPins: EdGraphPinReference[];
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	ComponentTemplateNameIndex: any;
	OldToNewComponentTemplateNames: any;
	Extensions: BlueprintExtension[];
	ThumbnailInfo: ThumbnailInfo;
	CrcLastCompiledCDO: any;
	CrcLastCompiledSignature: any;
	bCachedDependenciesUpToDate: boolean;
	CachedDependencies: any;
	CachedDependents: any;
	CachedUDSDependencies: any;
	OriginalClass: UnrealEngineClass;
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static GetDefaultObject(): Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject | any): Blueprint;
	AddComponentsToBlueprint(Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	CompileBlueprint(): void;
	GetParentClassOfBlueprint(): UnrealEngineClass;
	RemoveComponentFromBlueprint(RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	AddFunctionGraph(FuncName: string): EdGraph;
	CompileBlueprint(): void;
	FindEventGraph(): EdGraph;
	FindGraph(GraphName: string): EdGraph;
	RemoveFunctionGraph(FuncName: string): void;
	RemoveGraph(Graph: EdGraph): void;
	RemoveUnusedNodes(): void;
	RemoveUnusedVariables(): number;
	ReparentBlueprint(NewParentClass: UnrealEngineClass): void;
	ReplaceVariableReferences(OldVarName: string,NewVarName: string): void;
	UpgradeOperatorNodes(): void;
	static AddComponentsToBlueprint(Blueprint: Blueprint,Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static GetParentClassOfBlueprint(Blueprint: Blueprint): UnrealEngineClass;
	static RemoveComponentFromBlueprint(Blueprint: Blueprint,RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
}

declare type ERigVMGraphNotifType = 'GraphChanged' | 'NodeAdded' | 'NodeRemoved' | 'NodeSelected' | 'NodeDeselected' | 'NodeSelectionChanged' | 'NodePositionChanged' | 'NodeSizeChanged' | 'NodeColorChanged' | 'PinAdded' | 'PinRemoved' | 'PinRenamed' | 'PinExpansionChanged' | 'PinWatchedChanged' | 'PinArraySizeChanged' | 'PinDefaultValueChanged' | 'PinDirectionChanged' | 'PinTypeChanged' | 'PinIndexChanged' | 'LinkAdded' | 'LinkRemoved' | 'CommentTextChanged' | 'RerouteCompactnessChanged' | 'VariableAdded' | 'VariableRemoved' | 'VariableRenamed' | 'ParameterAdded' | 'ParameterRemoved' | 'ParameterRenamed' | 'InteractionBracketOpened' | 'InteractionBracketClosed' | 'InteractionBracketCanceled' | 'PinBoundVariableChanged' | 'NodeRenamed' | 'NodeReferenceChanged' | 'NodeCategoryChanged' | 'NodeKeywordsChanged' | 'NodeDescriptionChanged' | 'VariableRemappingChanged' | 'Invalid' | 'ERigVMGraphNotifType_MAX';
declare var ERigVMGraphNotifType : { GraphChanged:'GraphChanged',NodeAdded:'NodeAdded',NodeRemoved:'NodeRemoved',NodeSelected:'NodeSelected',NodeDeselected:'NodeDeselected',NodeSelectionChanged:'NodeSelectionChanged',NodePositionChanged:'NodePositionChanged',NodeSizeChanged:'NodeSizeChanged',NodeColorChanged:'NodeColorChanged',PinAdded:'PinAdded',PinRemoved:'PinRemoved',PinRenamed:'PinRenamed',PinExpansionChanged:'PinExpansionChanged',PinWatchedChanged:'PinWatchedChanged',PinArraySizeChanged:'PinArraySizeChanged',PinDefaultValueChanged:'PinDefaultValueChanged',PinDirectionChanged:'PinDirectionChanged',PinTypeChanged:'PinTypeChanged',PinIndexChanged:'PinIndexChanged',LinkAdded:'LinkAdded',LinkRemoved:'LinkRemoved',CommentTextChanged:'CommentTextChanged',RerouteCompactnessChanged:'RerouteCompactnessChanged',VariableAdded:'VariableAdded',VariableRemoved:'VariableRemoved',VariableRenamed:'VariableRenamed',ParameterAdded:'ParameterAdded',ParameterRemoved:'ParameterRemoved',ParameterRenamed:'ParameterRenamed',InteractionBracketOpened:'InteractionBracketOpened',InteractionBracketClosed:'InteractionBracketClosed',InteractionBracketCanceled:'InteractionBracketCanceled',PinBoundVariableChanged:'PinBoundVariableChanged',NodeRenamed:'NodeRenamed',NodeReferenceChanged:'NodeReferenceChanged',NodeCategoryChanged:'NodeCategoryChanged',NodeKeywordsChanged:'NodeKeywordsChanged',NodeDescriptionChanged:'NodeDescriptionChanged',VariableRemappingChanged:'VariableRemappingChanged',Invalid:'Invalid',ERigVMGraphNotifType_MAX:'ERigVMGraphNotifType_MAX', };
declare type ERigVMPinDirection = 'Input' | 'Output' | 'IO' | 'Visible' | 'Hidden' | 'Invalid' | 'ERigVMPinDirection_MAX';
declare var ERigVMPinDirection : { Input:'Input',Output:'Output',IO:'IO',Visible:'Visible',Hidden:'Hidden',Invalid:'Invalid',ERigVMPinDirection_MAX:'ERigVMPinDirection_MAX', };
declare class RigVMLink extends UObject { 
	SourcePinPath: string;
	TargetPinPath: string;
	static Load(ResourceName: string): RigVMLink;
	static Find(Outer: UObject, ResourceName: string): RigVMLink;
	static GetDefaultObject(): RigVMLink;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLink;
	GetTargetPin(): RigVMPin;
	GetSourcePin(): RigVMPin;
	GetPinPathRepresentation(): string;
	GetLinkIndex(): number;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLink;
}

declare class RigVMUnitNode extends RigVMNode { 
	ScriptStruct: ScriptStruct;
	MethodName: string;
	static Load(ResourceName: string): RigVMUnitNode;
	static Find(Outer: UObject, ResourceName: string): RigVMUnitNode;
	static GetDefaultObject(): RigVMUnitNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMUnitNode;
	GetStructDefaultValue(): string;
	GetScriptStruct(): ScriptStruct;
	GetMethodName(): string;
	static C(Other: UObject | any): RigVMUnitNode;
}

declare class RigVMInjectionInfo extends UObject { 
	UnitNode: RigVMUnitNode;
	UNode: RigVMNode;
	bInjectedAsInput: boolean;
	InputPin: RigVMPin;
	OutputPin: RigVMPin;
	static Load(ResourceName: string): RigVMInjectionInfo;
	static Find(Outer: UObject, ResourceName: string): RigVMInjectionInfo;
	static GetDefaultObject(): RigVMInjectionInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMInjectionInfo;
	GetPin(): RigVMPin;
	GetGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMInjectionInfo;
}

declare class RigVMPin extends UObject { 
	DisplayName: string;
	Direction: ERigVMPinDirection;
	bIsExpanded: boolean;
	bIsConstant: boolean;
	bRequiresWatch: boolean;
	bIsDynamicArray: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	CPPTypeObjectPath: string;
	DefaultValue: string;
	CustomWidgetName: string;
	SubPins: RigVMPin[];
	Links: RigVMLink[];
	InjectionInfos: RigVMInjectionInfo[];
	BoundVariablePath: string;
	static Load(ResourceName: string): RigVMPin;
	static Find(Outer: UObject, ResourceName: string): RigVMPin;
	static GetDefaultObject(): RigVMPin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMPin;
	RequiresWatch(bCheckExposedPinChain: boolean): boolean;
	IsUObject(): boolean;
	IsUnknownType(): boolean;
	IsStructMember(): boolean;
	IsStruct(): boolean;
	IsStringType(): boolean;
	IsRootPin(): boolean;
	IsReferenceCountedContainer(): boolean;
	IsLinkedTo(InPin: RigVMPin): boolean;
	IsExpanded(): boolean;
	IsExecuteContext(): boolean;
	IsDynamicArray(): boolean;
	IsDefinedAsConstant(): boolean;
	IsArrayElement(): boolean;
	IsArray(): boolean;
	GetToolTipText(): string;
	GetTargetLinks(bRecursive: boolean): RigVMLink[];
	GetSubPins(): RigVMPin[];
	GetSourceLinks(bRecursive: boolean): RigVMLink[];
	GetSegmentPath(bIncludeRootPin: boolean): string;
	GetScriptStruct(): ScriptStruct;
	GetRootPin(): RigVMPin;
	GetPinPath(bUseNodePath: boolean): string;
	GetPinIndex(): number;
	GetPinForLink(): RigVMPin;
	GetParentPin(): RigVMPin;
	GetOriginalPinFromInjectedNode(): RigVMPin;
	GetNode(): RigVMNode;
	GetLinks(): RigVMLink[];
	GetLinkedTargetPins(bRecursive: boolean): RigVMPin[];
	GetLinkedSourcePins(bRecursive: boolean): RigVMPin[];
	GetGraph(): RigVMGraph;
	GetEnum(): Enum;
	GetDisplayName(): string;
	GetDirection(): ERigVMPinDirection;
	GetDefaultValue(): string;
	GetCustomWidgetName(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	GetArraySize(): number;
	GetArrayElementCppType(): string;
	FindSubPin(InPinPath: string): RigVMPin;
	static C(Other: UObject | any): RigVMPin;
}

declare class RigVMNode extends UObject { 
	NodeTitle: string;
	position: Vector2D;
	Size: Vector2D;
	NodeColor: LinearColor;
	PreviousName: string;
	bHasBreakpoint: boolean;
	bHaltedAtThisNode: boolean;
	Pins: RigVMPin[];
	OrphanedPins: RigVMPin[];
	static Load(ResourceName: string): RigVMNode;
	static Find(Outer: UObject, ResourceName: string): RigVMNode;
	static GetDefaultObject(): RigVMNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMNode;
	SetHasBreakpoint(bValue: boolean): void;
	SetExecutionIsHaltedAtThisNode(bValue: boolean): void;
	IsVisibleInUI(): boolean;
	IsSelected(): boolean;
	IsPure(): boolean;
	IsMutable(): boolean;
	IsLinkedTo(InNode: RigVMNode): boolean;
	IsInjected(): boolean;
	IsEvent(): boolean;
	IsDefinedAsVarying(): boolean;
	IsDefinedAsConstant(): boolean;
	HasPinOfDirection(InDirection: ERigVMPinDirection): boolean;
	HasOutputPin(bIncludeIO: boolean): boolean;
	HasOrphanedPins(): boolean;
	HasIOPin(): boolean;
	HasInputPin(bIncludeIO: boolean): boolean;
	HasBreakpoint(): boolean;
	GetToolTipText(): string;
	GetSize(): Vector2D;
	GetRootGraph(): RigVMGraph;
	GetPreviousFName(): string;
	GetPosition(): Vector2D;
	GetPins(): RigVMPin[];
	GetOrphanedPins(): RigVMPin[];
	GetNodeTitle(): string;
	GetNodePath(bRecursive: boolean): string;
	GetNodeIndex(): number;
	GetNodeColor(): LinearColor;
	GetLinks(): RigVMLink[];
	GetLinkedTargetNodes(): RigVMNode[];
	GetLinkedSourceNodes(): RigVMNode[];
	GetInjectionInfo(): RigVMInjectionInfo;
	GetGraph(): RigVMGraph;
	GetEventName(): string;
	GetAllPinsRecursively(): RigVMPin[];
	FindPin(InPinPath: string): RigVMPin;
	ExecutionIsHaltedAtThisNode(): boolean;
	static C(Other: UObject | any): RigVMNode;
}

declare class RigVMGraphVariableDescription { 
	Name: string;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphVariableDescription;
	static C(Other: UObject | any): RigVMGraphVariableDescription;
}

declare class RigVMLibraryNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMLibraryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMLibraryNode;
	static GetDefaultObject(): RigVMLibraryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMLibraryNode;
	GetLibrary(): RigVMFunctionLibrary;
	GetContainedGraph(): RigVMGraph;
	static C(Other: UObject | any): RigVMLibraryNode;
}

declare class RigVMFunctionReferenceNode extends RigVMLibraryNode { 
	ReferencedNodePtr: RigVMLibraryNode;
	VariableMap: any;
	static Load(ResourceName: string): RigVMFunctionReferenceNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReferenceNode;
	static GetDefaultObject(): RigVMFunctionReferenceNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReferenceNode;
	static C(Other: UObject | any): RigVMFunctionReferenceNode;
}

declare class RigVMBuildData extends UObject { 
	FunctionReferences: any;
	static Load(ResourceName: string): RigVMBuildData;
	static Find(Outer: UObject, ResourceName: string): RigVMBuildData;
	static GetDefaultObject(): RigVMBuildData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBuildData;
	static C(Other: UObject | any): RigVMBuildData;
}

declare class RigVMFunctionLibrary extends RigVMGraph { 
	FunctionReferences: any;
	LocalizedFunctions: any;
	static Load(ResourceName: string): RigVMFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionLibrary;
	static GetDefaultObject(): RigVMFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionLibrary;
	GetReferencesForFunction(InFunctionName: string): RigVMFunctionReferenceNode[];
	GetReferencePathsForFunction(InFunctionName: string): string[];
	GetFunctions(): RigVMLibraryNode[];
	GetBuildData(): RigVMBuildData;
	FindFunctionForNode(InNode: RigVMNode): RigVMLibraryNode;
	FindFunction(InFunctionName: string): RigVMLibraryNode;
	static C(Other: UObject | any): RigVMFunctionLibrary;
}

declare class RigVMFunctionReturnNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMFunctionReturnNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionReturnNode;
	static GetDefaultObject(): RigVMFunctionReturnNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionReturnNode;
	static C(Other: UObject | any): RigVMFunctionReturnNode;
}

declare class RigVMGraphParameterDescription { 
	Name: string;
	bIsInput: boolean;
	CPPType: string;
	CPPTypeObject: UObject;
	DefaultValue: string;
	clone() : RigVMGraphParameterDescription;
	static C(Other: UObject | any): RigVMGraphParameterDescription;
}

declare class RigVMFunctionEntryNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMFunctionEntryNode;
	static Find(Outer: UObject, ResourceName: string): RigVMFunctionEntryNode;
	static GetDefaultObject(): RigVMFunctionEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMFunctionEntryNode;
	static C(Other: UObject | any): RigVMFunctionEntryNode;
}

declare class RigVMGraph extends UObject { 
	Nodes: RigVMNode[];
	Links: RigVMLink[];
	SelectedNodes: string[];
	DefaultFunctionLibraryPtr: any;
	LocalVariables: RigVMGraphVariableDescription[];
	static Load(ResourceName: string): RigVMGraph;
	static Find(Outer: UObject, ResourceName: string): RigVMGraph;
	static GetDefaultObject(): RigVMGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMGraph;
	SetDefaultFunctionLibrary(InFunctionLibrary: RigVMFunctionLibrary): void;
	IsTopLevelGraph(): boolean;
	IsRootGraph(): boolean;
	IsNodeSelected(InNodeName: string): boolean;
	GetVariableDescriptions(): RigVMGraphVariableDescription[];
	GetSelectNodes(): string[];
	GetRootGraph(): RigVMGraph;
	GetReturnNode(): RigVMFunctionReturnNode;
	GetParentGraph(): RigVMGraph;
	GetParameterDescriptions(): RigVMGraphParameterDescription[];
	GetOutputArguments(): RigVMGraphVariableDescription[];
	GetNodes(): RigVMNode[];
	GetNodePath(): string;
	GetLocalVariables(bIncludeInputArguments: boolean): RigVMGraphVariableDescription[];
	GetLinks(): RigVMLink[];
	GetInputArguments(): RigVMGraphVariableDescription[];
	GetGraphName(): string;
	GetEntryNode(): RigVMFunctionEntryNode;
	GetDefaultFunctionLibrary(): RigVMFunctionLibrary;
	GetContainedGraphs(bRecursive: boolean): RigVMGraph[];
	FindPin(InPinPath: string): RigVMPin;
	FindNodeByName(InNodeName: string): RigVMNode;
	FindNode(InNodePath: string): RigVMNode;
	FindLink(InLinkPinPathRepresentation: string): RigVMLink;
	static C(Other: UObject | any): RigVMGraph;
}

declare class RigVMActionKey { 
	ScriptStructPath: string;
	ExportedText: string;
	clone() : RigVMActionKey;
	static C(Other: UObject | any): RigVMActionKey;
}

declare class RigVMActionStack extends UObject { 
	ActionIndex: number;
	UndoActions: RigVMActionKey[];
	RedoActions: RigVMActionKey[];
	static Load(ResourceName: string): RigVMActionStack;
	static Find(Outer: UObject, ResourceName: string): RigVMActionStack;
	static GetDefaultObject(): RigVMActionStack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMActionStack;
	Undo(InController: RigVMController): boolean;
	Redo(InController: RigVMController): boolean;
	OpenUndoBracket(InTitle: string): boolean;
	CloseUndoBracket(): boolean;
	CancelUndoBracket(): boolean;
	static C(Other: UObject | any): RigVMActionStack;
}

declare class RigVMCollapseNode extends RigVMLibraryNode { 
	ContainedGraph: RigVMGraph;
	NodeCategory: string;
	NodeKeywords: string;
	NodeDescription: string;
	static Load(ResourceName: string): RigVMCollapseNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCollapseNode;
	static GetDefaultObject(): RigVMCollapseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCollapseNode;
	static C(Other: UObject | any): RigVMCollapseNode;
}

declare class RigVMVariableNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMVariableNode;
	static Find(Outer: UObject, ResourceName: string): RigVMVariableNode;
	static GetDefaultObject(): RigVMVariableNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMVariableNode;
	IsLocalVariable(): boolean;
	IsInputArgument(): boolean;
	IsGetter(): boolean;
	GetVariableName(): string;
	GetVariableDescription(): RigVMGraphVariableDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMVariableNode;
}

declare class RigVMSelectNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMSelectNode;
	static Find(Outer: UObject, ResourceName: string): RigVMSelectNode;
	static GetDefaultObject(): RigVMSelectNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMSelectNode;
	static C(Other: UObject | any): RigVMSelectNode;
}

declare class RigVMRerouteNode extends RigVMNode { 
	bShowAsFullNode: boolean;
	static Load(ResourceName: string): RigVMRerouteNode;
	static Find(Outer: UObject, ResourceName: string): RigVMRerouteNode;
	static GetDefaultObject(): RigVMRerouteNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMRerouteNode;
	GetShowsAsFullNode(): boolean;
	static C(Other: UObject | any): RigVMRerouteNode;
}

declare class RigVMPrototypeNode extends RigVMNode { 
	PrototypeNotation: string;
	SupportedTypesCache: any;
	static Load(ResourceName: string): RigVMPrototypeNode;
	static Find(Outer: UObject, ResourceName: string): RigVMPrototypeNode;
	static GetDefaultObject(): RigVMPrototypeNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMPrototypeNode;
	GetNotation(): string;
	static C(Other: UObject | any): RigVMPrototypeNode;
}

declare class RigVMParameterNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMParameterNode;
	static Find(Outer: UObject, ResourceName: string): RigVMParameterNode;
	static GetDefaultObject(): RigVMParameterNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMParameterNode;
	IsInput(): boolean;
	GetParameterName(): string;
	GetParameterDescription(): RigVMGraphParameterDescription;
	GetDefaultValue(): string;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMParameterNode;
}

declare class RigVMIfNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMIfNode;
	static Find(Outer: UObject, ResourceName: string): RigVMIfNode;
	static GetDefaultObject(): RigVMIfNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMIfNode;
	static C(Other: UObject | any): RigVMIfNode;
}

declare class RigVMEnumNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMEnumNode;
	static Find(Outer: UObject, ResourceName: string): RigVMEnumNode;
	static GetDefaultObject(): RigVMEnumNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMEnumNode;
	GetEnum(): Enum;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMEnumNode;
}

declare class RigVMCommentNode extends RigVMNode { 
	CommentText: string;
	FontSize: number;
	bBubbleVisible: boolean;
	bColorBubble: boolean;
	static Load(ResourceName: string): RigVMCommentNode;
	static Find(Outer: UObject, ResourceName: string): RigVMCommentNode;
	static GetDefaultObject(): RigVMCommentNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMCommentNode;
	GetCommentText(): string;
	GetCommentFontSize(): number;
	GetCommentColorBubble(): boolean;
	GetCommentBubbleVisible(): boolean;
	static C(Other: UObject | any): RigVMCommentNode;
}

declare class RigVMBranchNode extends RigVMNode { 
	static Load(ResourceName: string): RigVMBranchNode;
	static Find(Outer: UObject, ResourceName: string): RigVMBranchNode;
	static GetDefaultObject(): RigVMBranchNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMBranchNode;
	static C(Other: UObject | any): RigVMBranchNode;
}

declare class RigVMArrayNode extends RigVMNode { 
	OpCode: ERigVMOpCode;
	static Load(ResourceName: string): RigVMArrayNode;
	static Find(Outer: UObject, ResourceName: string): RigVMArrayNode;
	static GetDefaultObject(): RigVMArrayNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMArrayNode;
	GetOpCode(): ERigVMOpCode;
	GetCPPTypeObject(): UObject;
	GetCPPType(): string;
	static C(Other: UObject | any): RigVMArrayNode;
}

declare class RigVMController extends UObject { 
	ModifiedEventDynamic: UnrealEngineMulticastDelegate<(NotifType: ERigVMGraphNotifType, Graph: RigVMGraph, Subject: UObject) => void>;
	Graphs: RigVMGraph[];
	ExecuteContextStruct: Struct;
	ActionStack: RigVMActionStack;
	static Load(ResourceName: string): RigVMController;
	static Find(Outer: UObject, ResourceName: string): RigVMController;
	static GetDefaultObject(): RigVMController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigVMController;
	Undo(): boolean;
	UnbindPinFromVariable(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRerouteCompactnessByName(InNodeName: string,bShowAsFullNode: boolean,bSetupUndoRedo: boolean): boolean;
	SetRerouteCompactness(InNode: RigVMNode,bShowAsFullNode: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetRemappedVariable(InFunctionRefNode: RigVMFunctionReferenceNode,InInnerVariableName: string,InOuterVariableName: string,bSetupUndoRedo: boolean): boolean;
	SetPinIsWatched(InPinPath: string,bIsWatched: boolean,bSetupUndoRedo: boolean): boolean;
	SetPinExpansion(InPinPath: string,bIsExpanded: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetPinDefaultValue(InPinPath: string,InDefaultValue: string,bResizeArrays: boolean,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSizeByName(InNodeName: string,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSize(InNode: RigVMNode,InSize: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeSelection(InNodeNames: string[],bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePositionByName(InNodeName: string,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodePosition(InNode: RigVMNode,InPosition: Vector2D,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeKeywordsByName(InNodeName: string,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeKeywords(InNode: RigVMCollapseNode,InKeywords: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeDescriptionByName(InNodeName: string,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeDescription(InNode: RigVMCollapseNode,InDescription: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeColorByName(InNodeName: string,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeColor(InNode: RigVMNode,InColor: LinearColor,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetNodeCategoryByName(InNodeName: string,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean): boolean;
	SetNodeCategory(InNode: RigVMCollapseNode,InCategory: string,bSetupUndoRedo: boolean,bMergeUndoAction: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableTypeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableType(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetLocalVariableDefaultValue(InVariableName: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bNotify: boolean): boolean;
	SetIsRunningUnitTest(bIsRunning: boolean): void;
	SetGraph(InGraph: RigVMGraph): void;
	SetExposedPinIndex(InPinName: string,InNewIndex: number,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentTextByName(InNodeName: string,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetCommentText(InNode: RigVMNode,InCommentText: string,InCommentFontSize: number,bInCommentBubbleVisible: boolean,bInCommentColorBubble: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SetArrayPinSize(InArrayPinPath: string,InSize: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	SelectNodeByName(InNodeName: string,bSelect: boolean,bSetupUndoRedo: boolean): boolean;
	SelectNode(InNode: RigVMNode,bSelect: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ResetPinDefaultValue(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ReplaceParameterNodeWithVariable(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean): RigVMVariableNode;
	RenameVariable(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameParameter(InOldName: string,InNewName: string,bSetupUndoRedo: boolean): boolean;
	RenameNode(InNode: RigVMNode,InNewName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameLocalVariable(InVariableName: string,InNewVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RenameFunction(InOldFunctionName: string,InNewFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RenameExposedPin(InOldPinName: string,InNewPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveNodeByName(InNodeName: string,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveNode(InNode: RigVMNode,bSetupUndoRedo: boolean,bRecursive: boolean,bPrintPythonCommand: boolean,bRelinkPins: boolean): boolean;
	RemoveLocalVariable(InVariableName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveInjectedNode(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveFunctionFromLibrary(InFunctionName: string,bSetupUndoRedo: boolean): boolean;
	RemoveExposedPin(InPinName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RemoveArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	RefreshVariableNode(InNodeName: string,InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean,bSetupOrphanPins: boolean): void;
	Redo(): boolean;
	PushGraph(InGraph: RigVMGraph,bSetupUndoRedo: boolean): void;
	PromotePinToVariable(InPinPath: string,bCreateVariableNode: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	PromoteFunctionReferenceNodeToCollapseNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,bRemoveFunctionDefinition: boolean): string;
	PromoteCollapseNodeToFunctionReferenceNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean,InExistingFunctionDefinitionPath: string): string;
	PopGraph(bSetupUndoRedo: boolean): RigVMGraph;
	OpenUndoBracket(InTitle: string): boolean;
	OnExternalVariableTypeChangedFromObjectPath(InVarName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo: boolean): void;
	OnExternalVariableTypeChanged(InVarName: string,InCPPType: string,InCPPTypeObject: UObject,bSetupUndoRedo: boolean): void;
	OnExternalVariableRenamed(InOldVarName: string,InNewVarName: string,bSetupUndoRedo: boolean): void;
	OnExternalVariableRemoved(InVarName: string,bSetupUndoRedo: boolean): void;
	MakeVariableNodeFromBinding(InPinPath: string,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	MakeBindingsFromVariableNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	LocalizeFunctions(InFunctionDefinitions: RigVMLibraryNode[],bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): any;
	LocalizeFunction(InFunctionDefinition: RigVMLibraryNode,bLocalizeDependentPrivateFunctions: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	IsReportingEnabled(): boolean;
	InsertArrayPin(InArrayPinPath: string,InIndex: number,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	ImportNodesFromText(InText: string,bSetupUndoRedo: boolean,bPrintPythonCommands: boolean): string[];
	GetTopLevelGraph(): RigVMGraph;
	GetPinDefaultValue(InPinPath: string): string;
	GetGraph(): RigVMGraph;
	GeneratePythonCommands(): string[];
	ExportSelectedNodesToText(): string;
	ExportNodesToText(InNodeNames: string[]): string;
	ExpandLibraryNode(InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode[];
	EnableReporting(bEnabled: boolean): void;
	EjectNodeFromPin(InPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMNode;
	DuplicateArrayPin(InArrayElementPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	CollapseNodes(InNodeNames: string[],InCollapseNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMCollapseNode;
	CloseUndoBracket(): boolean;
	ClearNodeSelection(bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ClearArrayPin(InArrayPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	ChangeExposedPinType(InPinName: string,InCPPType: string,InCPPTypeObjectPath: string,bSetupUndoRedo?: boolean,bSetupOrphanPins?: boolean,bPrintPythonCommand?: boolean): {bSetupUndoRedo: boolean, $: boolean};
	CanImportNodesFromText(InText: string): boolean;
	CancelUndoBracket(): boolean;
	BreakLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BreakAllLinks(InPinPath: string,bAsInput: boolean,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	BindPinToVariable(InPinPath: string,InNewBoundVariablePath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	AddVariableNodeFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddVariableNode(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,bIsGetter: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMVariableNode;
	AddUnitNodeFromStructPath(InScriptStructPath: string,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddUnitNode(InScriptStruct: ScriptStruct,InMethodName: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMUnitNode;
	AddSelectNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMSelectNode;
	AddSelectNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMSelectNode;
	AddRerouteNodeOnPin(InPinPath: string,bAsInput: boolean,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLinkPath(InLinkPinPathRepresentation: string,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddRerouteNodeOnLink(InLink: RigVMLink,bShowAsFullNode: boolean,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMRerouteNode;
	AddPrototypeNode(InNotation: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMPrototypeNode;
	AddParameterNodeFromObjectPath(InParameterName: string,InCPPType: string,InCPPTypeObjectPath: string,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddParameterNode(InParameterName: string,InCPPType: string,InCPPTypeObject: UObject,bIsInput: boolean,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMParameterNode;
	AddLocalVariableFromObjectPath(InVariableName: string,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean): RigVMGraphVariableDescription;
	AddLocalVariable(InVariableName: string,InCPPType: string,InCPPTypeObject: UObject,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMGraphVariableDescription;
	AddLink(InOutputPinPath: string,InInputPinPath: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): boolean;
	AddInjectedNodeFromStructPath(InPinPath: string,bAsInput: boolean,InScriptStructPath: string,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean): RigVMInjectionInfo;
	AddInjectedNode(InPinPath: string,bAsInput: boolean,InScriptStruct: ScriptStruct,InMethodName: string,InInputPinName: string,InOutputPinName: string,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMInjectionInfo;
	AddIfNodeFromStruct(InScriptStruct: ScriptStruct,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMIfNode;
	AddIfNode(InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMIfNode;
	AddFunctionToLibrary(InFunctionName: string,bMutable: boolean,InNodePosition: Vector2D,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMLibraryNode;
	AddFunctionReferenceNode(InFunctionDefinition: RigVMLibraryNode,InNodePosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMFunctionReferenceNode;
	AddFreeRerouteNode(bShowAsFullNode: boolean,InCPPType: string,InCPPTypeObjectPath: string,bIsConstant: boolean,InCustomWidgetName: string,InDefaultValue: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean): RigVMRerouteNode;
	AddExposedPin(InPinName: string,InDirection: ERigVMPinDirection,InCPPType: string,InCPPTypeObjectPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddEnumNode(InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMEnumNode;
	AddCommentNode(InCommentText: string,InPosition: Vector2D,InSize: Vector2D,InColor: LinearColor,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMCommentNode;
	AddBranchNode(InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMBranchNode;
	AddArrayPin(InArrayPinPath: string,InDefaultValue: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): string;
	AddArrayNodeFromObjectPath(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObjectPath: string,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	AddArrayNode(InOpCode: ERigVMOpCode,InCPPType: string,InCPPTypeObject: UObject,InPosition: Vector2D,InNodeName: string,bSetupUndoRedo: boolean,bPrintPythonCommand: boolean): RigVMArrayNode;
	static C(Other: UObject | any): RigVMController;
}

declare class ControlRigGraph extends EdGraph { 
	ModelNodePath: string;
	bIsFunctionDefinition: boolean;
	TemplateController: RigVMController;
	static Load(ResourceName: string): ControlRigGraph;
	static Find(Outer: UObject, ResourceName: string): ControlRigGraph;
	static GetDefaultObject(): ControlRigGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigGraph;
	static C(Other: UObject | any): ControlRigGraph;
}

declare class RigGraphDisplaySettings { 
	bShowNodeRunCounts: boolean;
	NodeRunLowerBound: number;
	NodeRunLimit: number;
	MinMicroSeconds: any;
	MaxMicroSeconds: any;
	TotalMicroSeconds: any;
	bAutoDetermineRange: boolean;
	LastMinMicroSeconds: any;
	LastMaxMicroSeconds: any;
	MinDurationColor: LinearColor;
	MaxDurationColor: LinearColor;
	clone() : RigGraphDisplaySettings;
	static C(Other: UObject | any): RigGraphDisplaySettings;
}

declare class RigVMParserASTSettings { 
	bFoldAssignments: boolean;
	bFoldLiterals: boolean;
	bFoldConstantBranches: boolean;
	LinksToSkip: RigVMLink[];
	clone() : RigVMParserASTSettings;
	static C(Other: UObject | any): RigVMParserASTSettings;
}

declare class RigVMCompileSettings { 
	SurpressInfoMessages: boolean;
	SurpressWarnings: boolean;
	SurpressErrors: boolean;
	EnablePinWatches: boolean;
	IsPreprocessorPhase: boolean;
	ASTSettings: RigVMParserASTSettings;
	SetupNodeInstructionIndex: boolean;
	clone() : RigVMCompileSettings;
	static C(Other: UObject | any): RigVMCompileSettings;
}

declare class ControlRigPythonSettings { 
	clone() : ControlRigPythonSettings;
	static C(Other: UObject | any): ControlRigPythonSettings;
}

declare class ControlRigPublicFunctionArg { 
	Name: string;
	CPPType: string;
	CPPTypeObjectPath: string;
	bIsArray: boolean;
	Direction: ERigVMPinDirection;
	clone() : ControlRigPublicFunctionArg;
	static C(Other: UObject | any): ControlRigPublicFunctionArg;
}

declare class ControlRigPublicFunctionData { 
	Name: string;
	DisplayName: string;
	Category: string;
	Keywords: string;
	ReturnValue: ControlRigPublicFunctionArg;
	Arguments: ControlRigPublicFunctionArg[];
	clone() : ControlRigPublicFunctionData;
	static C(Other: UObject | any): ControlRigPublicFunctionData;
}

declare class RigVMReferenceNodeData { 
	ReferenceNodePath: string;
	ReferencedFunctionPath: string;
	clone() : RigVMReferenceNodeData;
	static C(Other: UObject | any): RigVMReferenceNodeData;
}

declare class RigElement { 
	Name: string;
	index: number;
	clone() : RigElement;
	static C(Other: UObject | any): RigElement;
}

declare class RigBone extends RigElement { 
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	GlobalTransform: Transform;
	LocalTransform: Transform;
	Dependents: number[];
	Type: ERigBoneType;
	clone() : RigBone;
	static C(Other: UObject | any): RigBone;
}

declare class RigBoneHierarchy { 
	Bones: RigBone[];
	clone() : RigBoneHierarchy;
	static C(Other: UObject | any): RigBoneHierarchy;
}

declare type ERigSpaceType = 'Global' | 'Bone' | 'Control' | 'Space' | 'ERigSpaceType_MAX';
declare var ERigSpaceType : { Global:'Global',Bone:'Bone',Control:'Control',Space:'Space',ERigSpaceType_MAX:'ERigSpaceType_MAX', };
declare class RigSpace extends RigElement { 
	SpaceType: ERigSpaceType;
	ParentName: string;
	ParentIndex: number;
	InitialTransform: Transform;
	LocalTransform: Transform;
	clone() : RigSpace;
	static C(Other: UObject | any): RigSpace;
}

declare class RigSpaceHierarchy { 
	Spaces: RigSpace[];
	clone() : RigSpaceHierarchy;
	static C(Other: UObject | any): RigSpaceHierarchy;
}

declare class RigControl extends RigElement { 
	ControlType: ERigControlType;
	DisplayName: string;
	ParentName: string;
	ParentIndex: number;
	SpaceName: string;
	SpaceIndex: number;
	OffsetTransform: Transform;
	InitialValue: RigControlValue;
	Value: RigControlValue;
	PrimaryAxis: ERigControlAxis;
	bIsCurve: boolean;
	bAnimatable: boolean;
	bLimitTranslation: boolean;
	bLimitRotation: boolean;
	bLimitScale: boolean;
	bDrawLimits: boolean;
	MinimumValue: RigControlValue;
	MaximumValue: RigControlValue;
	bGizmoEnabled: boolean;
	bGizmoVisible: boolean;
	GizmoName: string;
	GizmoTransform: Transform;
	GizmoColor: LinearColor;
	Dependents: number[];
	bIsTransientControl: boolean;
	ControlEnum: Enum;
	clone() : RigControl;
	static C(Other: UObject | any): RigControl;
}

declare class RigControlHierarchy { 
	Controls: RigControl[];
	clone() : RigControlHierarchy;
	static C(Other: UObject | any): RigControlHierarchy;
}

declare class RigCurve extends RigElement { 
	Value: number;
	clone() : RigCurve;
	static C(Other: UObject | any): RigCurve;
}

declare class RigCurveContainer { 
	Curves: RigCurve[];
	clone() : RigCurveContainer;
	static C(Other: UObject | any): RigCurveContainer;
}

declare class RigHierarchyContainer { 
	BoneHierarchy: RigBoneHierarchy;
	SpaceHierarchy: RigSpaceHierarchy;
	ControlHierarchy: RigControlHierarchy;
	CurveContainer: RigCurveContainer;
	clone() : RigHierarchyContainer;
	static C(Other: UObject | any): RigHierarchyContainer;
}

declare class ControlRigValidationPass extends UObject { 
	static Load(ResourceName: string): ControlRigValidationPass;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidationPass;
	static GetDefaultObject(): ControlRigValidationPass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidationPass;
	static C(Other: UObject | any): ControlRigValidationPass;
}

declare class ControlRigValidator extends UObject { 
	Passes: ControlRigValidationPass[];
	static Load(ResourceName: string): ControlRigValidator;
	static Find(Outer: UObject, ResourceName: string): ControlRigValidator;
	static GetDefaultObject(): ControlRigValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigValidator;
	static C(Other: UObject | any): ControlRigValidator;
}

declare class ControlRigBlueprint extends Blueprint { 
	FunctionLibraryEdGraph: ControlRigGraph;
	RigGraphDisplaySettings: RigGraphDisplaySettings;
	VMRuntimeSettings: RigVMRuntimeSettings;
	VMCompileSettings: RigVMCompileSettings;
	PythonLogSettings: ControlRigPythonSettings;
	Model: RigVMGraph;
	FunctionLibrary: RigVMFunctionLibrary;
	PublicFunctions: ControlRigPublicFunctionData[];
	FunctionReferenceNodeData: RigVMReferenceNodeData[];
	Controllers: any;
	TemplateModel: RigVMGraph;
	TemplateController: RigVMController;
	PinToOperandMap: any;
	GizmoLibrary: ControlRigShapeLibrary;
	ShapeLibraries: ControlRigShapeLibrary[];
	Statistics: RigVMStatistics;
	DrawContainer: ControlRigDrawContainer;
	Influences: RigInfluenceMapPerEvent;
	HierarchyContainer: RigHierarchyContainer;
	Hierarchy: RigHierarchy;
	bSupportsInversion: boolean;
	bSupportsControls: boolean;
	PreviewSkeletalMesh: SkeletalMesh;
	SourceHierarchyImport: UObject;
	SourceCurveImport: UObject;
	SupportedEventNames: string[];
	bExposesAnimatableControls: boolean;
	bAutoRecompileVM: boolean;
	bVMRecompilationRequired: boolean;
	bIsCompiling: boolean;
	VMRecompilationBracket: number;
	Validator: ControlRigValidator;
	DebugBoneRadius: number;
	static Load(ResourceName: string): ControlRigBlueprint;
	static Find(Outer: UObject, ResourceName: string): ControlRigBlueprint;
	static GetDefaultObject(): ControlRigBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlRigBlueprint;
	SuspendNotifications(bSuspendNotifs: boolean): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	RequestControlRigInit(): void;
	RequestAutoVMRecompilation(): void;
	RenameMemberVariable(InOldName: string,InNewName: string): boolean;
	RemoveMemberVariable(InName: string): boolean;
	RecompileVMIfRequired(): void;
	RecompileVM(): void;
	GetPreviewMesh(): SkeletalMesh;
	GetOrCreateController(InGraph: RigVMGraph): RigVMController;
	GetModel(InEdGraph: EdGraph): RigVMGraph;
	GetLocalFunctionLibrary(): RigVMFunctionLibrary;
	GetHierarchyController(): RigHierarchyController;
	static GetCurrentlyOpenRigBlueprints(): ControlRigBlueprint[];
	GetControlRigClass(): UnrealEngineClass;
	GetControllerByName(InGraphName: string): RigVMController;
	GetController(InGraph: RigVMGraph): RigVMController;
	static GetAvailableRigUnits(): Struct[];
	GetAllModels(): RigVMGraph[];
	GeneratePythonCommands(InNewBlueprintName: string): string[];
	CreateControlRig(): ControlRig;
	ChangeMemberVariableType(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): boolean;
	AddMemberVariable(InName: string,InCPPType: string,bIsPublic: boolean,bIsReadOnly: boolean,InDefaultValue: string): string;
	static C(Other: UObject | any): ControlRigBlueprint;
	GetController(): RigVMController;
	GetHierarchy(): RigHierarchy;
	GetHierarchyController(): RigHierarchyController;
	GetModel(): RigVMGraph;
	GetPreviewMesh(): SkeletalMesh;
	RecompileVM(): void;
	RecompileVMIfRequired(): void;
	RequestAutoVMRecompilation(): void;
	RequestControlRigInit(): void;
	SetPreviewMesh(PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
	static GetController(InRigBlueprint: ControlRigBlueprint): RigVMController;
	static GetHierarchy(InRigBlueprint: ControlRigBlueprint): RigHierarchy;
	static GetHierarchyController(InRigBlueprint: ControlRigBlueprint): RigHierarchyController;
	static GetModel(InRigBlueprint: ControlRigBlueprint): RigVMGraph;
	static GetPreviewMesh(InRigBlueprint: ControlRigBlueprint): SkeletalMesh;
	static RecompileVM(InRigBlueprint: ControlRigBlueprint): void;
	static RecompileVMIfRequired(InRigBlueprint: ControlRigBlueprint): void;
	static RequestAutoVMRecompilation(InRigBlueprint: ControlRigBlueprint): void;
	static RequestControlRigInit(InRigBlueprint: ControlRigBlueprint): void;
	static SetPreviewMesh(InRigBlueprint: ControlRigBlueprint,PreviewMesh: SkeletalMesh,bMarkAsDirty: boolean): void;
}

declare class DirectoryItem { 
	Name: string;
	bIsDirectory: boolean;
	clone() : DirectoryItem;
	static C(Other: UObject | any): DirectoryItem;
}

declare type EFileRead_JS = 'FILEREAD_None' | 'FILEREAD_NoFail' | 'FILEREAD_Silent' | 'FILEREAD_NotUsedDummy' | 'FILEREAD_AllowWrite' | 'FILEREAD_MAX';
declare var EFileRead_JS : { FILEREAD_None:'FILEREAD_None',FILEREAD_NoFail:'FILEREAD_NoFail',FILEREAD_Silent:'FILEREAD_Silent',FILEREAD_NotUsedDummy:'FILEREAD_NotUsedDummy',FILEREAD_AllowWrite:'FILEREAD_AllowWrite',FILEREAD_MAX:'FILEREAD_MAX', };
declare class JavascriptStubStruct { 
	clone() : JavascriptStubStruct;
	static C(Other: UObject | any): JavascriptStubStruct;
}

declare class JavascriptFunction { 
	clone() : JavascriptFunction;
	static C(Other: UObject | any): JavascriptFunction;
	CallJS(CustomStruct: JavascriptStubStruct): void;
	static CallJS(UFunction: JavascriptFunction,CustomStruct: JavascriptStubStruct): void;
}

declare class ReadStringFromFileHandle { 
	clone() : ReadStringFromFileHandle;
	static C(Other: UObject | any): ReadStringFromFileHandle;
}

declare type EJavascriptEncodingOptions = 'AutoDetect' | 'ForceAnsi' | 'ForceUnicode' | 'ForceUTF8' | 'ForceUTF8WithoutBOM' | 'EJavascriptEncodingOptions_MAX';
declare var EJavascriptEncodingOptions : { AutoDetect:'AutoDetect',ForceAnsi:'ForceAnsi',ForceUnicode:'ForceUnicode',ForceUTF8:'ForceUTF8',ForceUTF8WithoutBOM:'ForceUTF8WithoutBOM',EJavascriptEncodingOptions_MAX:'EJavascriptEncodingOptions_MAX', };
declare class AudioEngineSubsystem extends DynamicSubsystem { 
	static Load(ResourceName: string): AudioEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): AudioEngineSubsystem;
	static GetDefaultObject(): AudioEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEngineSubsystem;
	static C(Other: UObject | any): AudioEngineSubsystem;
}

declare class GameInstanceSubsystem extends Subsystem { 
	static Load(ResourceName: string): GameInstanceSubsystem;
	static Find(Outer: UObject, ResourceName: string): GameInstanceSubsystem;
	static GetDefaultObject(): GameInstanceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstanceSubsystem;
	static C(Other: UObject | any): GameInstanceSubsystem;
}

declare class WorldSubsystem extends Subsystem { 
	static Load(ResourceName: string): WorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): WorldSubsystem;
	static GetDefaultObject(): WorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSubsystem;
	static C(Other: UObject | any): WorldSubsystem;
}

declare class CollisionProfileName { 
	Name: string;
	clone() : CollisionProfileName;
	static C(Other: UObject | any): CollisionProfileName;
}

declare type EPropertyAccessChangeNotifyMode = 'Default' | 'Never' | 'Always' | 'EPropertyAccessChangeNotifyMode_MAX';
declare var EPropertyAccessChangeNotifyMode : { Default:'Default',Never:'Never',Always:'Always',EPropertyAccessChangeNotifyMode_MAX:'EPropertyAccessChangeNotifyMode_MAX', };
declare class GenericStruct { 
	Data: number;
	clone() : GenericStruct;
	static C(Other: UObject | any): GenericStruct;
}

declare class UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UObject;
	static Find(Outer: UObject, ResourceName: string): UObject;
	static StaticClass: any;
	static GetClassObject(): Class;
	static GetDefaultObject(): UObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UObject;
	ExecuteUbergraph(EntryPoint: number): void;
	static C(Other: UObject | any): UObject;
	AddWhitelistedObject(): void;
	BroadcastAssetCreated(): void;
	ConditionalBeginDestroybyUObject(): boolean;
	GetUniqueID(): number;
	MarkPackageDirty(): boolean;
	ModifyObject(bAlwaysMarkDirty: boolean): void;
	OpenEditorForAsset(): boolean;
	PostEditChange(): void;
	CastToControlRigBlueprint(Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	SpawnActorFromObject(Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	CheckoutLoadedAsset(): boolean;
	ConsolidateAssets(AssetsToConsolidate: UObject[]): boolean;
	DeleteLoadedAsset(): boolean;
	DuplicateLoadedAsset(DestinationAssetPath: string): UObject;
	GetMetadataTag(Tag: string): string;
	GetMetadataTagValues(): any;
	GetPathNameForLoadedAsset(): string;
	RemoveMetadataTag(Tag: string): void;
	RenameLoadedAsset(DestinationAssetPath: string): boolean;
	SaveLoadedAsset(bOnlyIfIsDirty: boolean): boolean;
	SetMetadataTag(Tag: string,Value: string): void;
	DestroyUObject(): void;
	ConvertRelativePathToFull(RelativePath: string): string;
	CreateEnum(Name: string,DisplayNames: string[],Flags: string[]): Enum;
	CreatePackage(PackageName: string): Package;
	Duplicate(Outer: UObject,Name: string): UObject;
	FindObjectWithOuter(ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	FindPackage(PackageName: string): Package;
	GetArchetypePathName(): string;
	GetDir(WhichDir: string): string;
	GetFields(bIncludeSuper: boolean): Field[];
	GetFileSize(Filename: string): number;
	GetName(): string;
	GetObjectsWithOuter(Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetOuter(): UObject;
	GetOutermost(): UObject;
	HasAnyFlags(Flags: number): boolean;
	ReadDirectory(Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	ReadFile(Filename: string): boolean;
	ReadStringFromFile(Filename: string,ReadFlags: EFileRead_JS): string;
	ReadStringFromFileAsync(Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	SetObjectFlags(Flags: number): void;
	WriteFile(Filename: string): boolean;
	WriteStringToFile(Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	RenameAsset(NewName: string): void;
	GetDatasmithUserData(): DatasmithAssetUserData;
	GetDatasmithUserDataKeysAndValuesForValue(StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	GetDatasmithUserDataValueForKey(Key: string): string;
	RedirectVislog(DestinationOwner: UObject): void;
	GetAudioEngineSubsystem(Class: UnrealEngineClass): AudioEngineSubsystem;
	GetGameInstanceSubsystem(Class: UnrealEngineClass): GameInstanceSubsystem;
	GetLocalPlayerSubsystem(Class: UnrealEngineClass): LocalPlayerSubsystem;
	GetWorldSubsystem(Class: UnrealEngineClass): WorldSubsystem;
	MarkPropertyDirty(PropertyName: string): void;
	MarkPropertyDirtyFromRepIndex(RepIndex: number,PropertyName: string): void;
	Conv_ObjectToText(): string;
	Conv_ObjectToClass(Class: UnrealEngineClass): UnrealEngineClass;
	Conv_ObjectToSoftObjectReference(): UObject;
	Conv_SoftObjectReferenceToObject(): UObject;
	Conv_SoftObjectReferenceToString(): string;
	CreateCopyForUndoBuffer(): void;
	DoesImplementInterface(Interface: UnrealEngineClass): boolean;
	EqualEqual_SoftObjectReference(B: UObject): boolean;
	GetDisplayName(): string;
	GetEditorProperty(PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	GetObjectName(): string;
	GetOuterObject(): UObject;
	GetPathName(): string;
	GetPrimaryAssetIdFromObject(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftObjectReference(): PrimaryAssetId;
	GetSystemPath(): string;
	IsValid(): boolean;
	IsValidSoftObjectReference(): boolean;
	K2_ClearTimer(FunctionName: string): void;
	K2_GetTimerElapsedTime(FunctionName: string): number;
	K2_GetTimerRemainingTime(FunctionName: string): number;
	K2_IsTimerActive(FunctionName: string): boolean;
	K2_IsTimerPaused(FunctionName: string): boolean;
	K2_PauseTimer(FunctionName: string): void;
	K2_SetTimer(FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	K2_SetTimerForNextTick(FunctionName: string): TimerHandle;
	K2_TimerExists(FunctionName: string): boolean;
	K2_UnPauseTimer(FunctionName: string): void;
	LoadAsset_Blocking(): UObject;
	NotEqual_SoftObjectReference(B: UObject): boolean;
	SetBoolPropertyByName(PropertyName: string,Value: boolean): void;
	SetBytePropertyByName(PropertyName: string,Value: number): void;
	SetClassPropertyByName(PropertyName: string,Value: UnrealEngineClass): void;
	SetCollisionProfileNameProperty(PropertyName: string,Value: CollisionProfileName): void;
	SetColorPropertyByName(PropertyName: string,Value: Color): void;
	SetDoublePropertyByName(PropertyName: string,Value: any): void;
	SetEditorProperty(PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	SetFieldPathPropertyByName(PropertyName: string,Value: any): void;
	SetInt64PropertyByName(PropertyName: string,Value: any): void;
	SetInterfacePropertyByName(PropertyName: string,Value: any): void;
	SetIntPropertyByName(PropertyName: string,Value: number): void;
	SetLinearColorPropertyByName(PropertyName: string,Value: LinearColor): void;
	SetNamePropertyByName(PropertyName: string,Value: string): void;
	SetObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetRotatorPropertyByName(PropertyName: string,Value: Rotator): void;
	SetSoftClassPropertyByName(PropertyName: string,Value: Class): void;
	SetSoftObjectPropertyByName(PropertyName: string,Value: UObject): void;
	SetStringPropertyByName(PropertyName: string,Value: string): void;
	SetStructurePropertyByName(PropertyName: string,Value: GenericStruct): void;
	SetTextPropertyByName(PropertyName: string,Value: string): void;
	SetTransformPropertyByName(PropertyName: string,Value: Transform): void;
	SetVector3fPropertyByName(PropertyName: string,Value: Vector3f): void;
	SetVectorPropertyByName(PropertyName: string,Value: Vector): void;
	SnapshotObject(): void;
	TransactObject(): void;
	Conv_ObjectToString(): string;
	EqualEqual_ObjectObject(B: UObject): boolean;
	NotEqual_ObjectObject(B: UObject): boolean;
	SelectObject(B: UObject,bSelectA: boolean): UObject;
	SetArrayPropertyByName(PropertyName: string,Value: number[]): void;
	GetObjectClass(): UnrealEngineClass;
	K2_AcquireEditorObjectElementHandle(bAllowCreate: boolean): ScriptTypedElementHandle;
	SetSetPropertyByName(PropertyName: string,Value: any): void;
	SetMapPropertyByName(PropertyName: string,Value: any): void;
	GetBlueprintAsset(): Blueprint;
	static AddWhitelistedObject(InObject: UObject): void;
	static BroadcastAssetCreated(NewAsset: UObject): void;
	static ConditionalBeginDestroybyUObject(TargetObject: UObject): boolean;
	static GetUniqueID(InObject: UObject): number;
	static MarkPackageDirty(InObject: UObject): boolean;
	static ModifyObject(UObject: UObject,bAlwaysMarkDirty: boolean): void;
	static OpenEditorForAsset(Asset: UObject): boolean;
	static PostEditChange(InObject: UObject): void;
	static CastToControlRigBlueprint(UObject: UObject,Branches?: ECastToControlRigBlueprintCases,AsControlRigBlueprint?: ControlRigBlueprint): {Branches: ECastToControlRigBlueprintCases, AsControlRigBlueprint: ControlRigBlueprint};
	static SpawnActorFromObject(ObjectToUse: UObject,Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	static CheckoutLoadedAsset(AssetToCheckout: UObject): boolean;
	static ConsolidateAssets(AssetToConsolidateTo: UObject,AssetsToConsolidate: UObject[]): boolean;
	static DeleteLoadedAsset(AssetToDelete: UObject): boolean;
	static DuplicateLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): UObject;
	static GetMetadataTag(UObject: UObject,Tag: string): string;
	static GetMetadataTagValues(UObject: UObject): any;
	static GetPathNameForLoadedAsset(LoadedAsset: UObject): string;
	static RemoveMetadataTag(UObject: UObject,Tag: string): void;
	static RenameLoadedAsset(SourceAsset: UObject,DestinationAssetPath: string): boolean;
	static SaveLoadedAsset(AssetToSave: UObject,bOnlyIfIsDirty: boolean): boolean;
	static SetMetadataTag(UObject: UObject,Tag: string,Value: string): void;
	static DestroyUObject(UObject: UObject): void;
	static ConvertRelativePathToFull(UObject: UObject,RelativePath: string): string;
	static CreateEnum(Outer: UObject,Name: string,DisplayNames: string[],Flags: string[]): Enum;
	static CreatePackage(Outer: UObject,PackageName: string): Package;
	static Duplicate(UObject: UObject,Outer: UObject,Name: string): UObject;
	static FindObjectWithOuter(Outer: UObject,ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	static FindPackage(InOuter: UObject,PackageName: string): Package;
	static GetArchetypePathName(UObject: UObject): string;
	static GetDir(UObject: UObject,WhichDir: string): string;
	static GetFields(UObject: UObject,bIncludeSuper: boolean): Field[];
	static GetFileSize(UObject: UObject,Filename: string): number;
	static GetName(UObject: UObject): string;
	static GetObjectsWithOuter(Outer: UObject,Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetOuter(UObject: UObject): UObject;
	static GetOutermost(UObject: UObject): UObject;
	static HasAnyFlags(UObject: UObject,Flags: number): boolean;
	static ReadDirectory(UObject: UObject,Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	static ReadFile(UObject: UObject,Filename: string): boolean;
	static ReadStringFromFile(UObject: UObject,Filename: string,ReadFlags: EFileRead_JS): string;
	static ReadStringFromFileAsync(UObject: UObject,Filename: string,UFunction: JavascriptFunction): ReadStringFromFileHandle;
	static SetObjectFlags(Obj: UObject,Flags: number): void;
	static WriteFile(UObject: UObject,Filename: string): boolean;
	static WriteStringToFile(UObject: UObject,Filename: string,Data: string,EncodingOptions: EJavascriptEncodingOptions): boolean;
	static RenameAsset(Asset: UObject,NewName: string): void;
	static GetDatasmithUserData(UObject: UObject): DatasmithAssetUserData;
	static GetDatasmithUserDataKeysAndValuesForValue(UObject: UObject,StringToMatch: string,OutKeys?: string[],OutValues?: string[]): {OutKeys: string[], OutValues: string[]};
	static GetDatasmithUserDataValueForKey(UObject: UObject,Key: string): string;
	static RedirectVislog(SourceOwner: UObject,DestinationOwner: UObject): void;
	static GetAudioEngineSubsystem(ContextObject: UObject,Class: UnrealEngineClass): AudioEngineSubsystem;
	static GetGameInstanceSubsystem(ContextObject: UObject,Class: UnrealEngineClass): GameInstanceSubsystem;
	static GetLocalPlayerSubsystem(ContextObject: UObject,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetWorldSubsystem(ContextObject: UObject,Class: UnrealEngineClass): WorldSubsystem;
	static MarkPropertyDirty(UObject: UObject,PropertyName: string): void;
	static MarkPropertyDirtyFromRepIndex(UObject: UObject,RepIndex: number,PropertyName: string): void;
	static Conv_ObjectToText(InObj: UObject): string;
	static Conv_ObjectToClass(UObject: UObject,Class: UnrealEngineClass): UnrealEngineClass;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): UObject;
	static Conv_SoftObjectReferenceToObject(softobject: UObject): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: UObject): string;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static EqualEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static GetDisplayName(UObject: UObject): string;
	static GetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	static GetObjectName(UObject: UObject): string;
	static GetOuterObject(UObject: UObject): UObject;
	static GetPathName(UObject: UObject): string;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: UObject): PrimaryAssetId;
	static GetSystemPath(UObject: UObject): string;
	static IsValid(UObject: UObject): boolean;
	static IsValidSoftObjectReference(SoftObjectReference: UObject): boolean;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	static K2_SetTimerForNextTick(UObject: UObject,FunctionName: string): TimerHandle;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static LoadAsset_Blocking(Asset: UObject): UObject;
	static NotEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetColorPropertyByName(UObject: UObject,PropertyName: string,Value: Color): void;
	static SetDoublePropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	static SetFieldPathPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetInt64PropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetInterfacePropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: Class): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetVector3fPropertyByName(UObject: UObject,PropertyName: string,Value: Vector3f): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static SnapshotObject(UObject: UObject): void;
	static TransactObject(UObject: UObject): void;
	static Conv_ObjectToString(InObj: UObject): string;
	static EqualEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static NotEqual_ObjectObject(A: UObject,B: UObject): boolean;
	static SelectObject(A: UObject,B: UObject,bSelectA: boolean): UObject;
	static SetArrayPropertyByName(UObject: UObject,PropertyName: string,Value: number[]): void;
	static GetObjectClass(UObject: UObject): UnrealEngineClass;
	static K2_AcquireEditorObjectElementHandle(UObject: UObject,bAllowCreate: boolean): ScriptTypedElementHandle;
	static SetSetPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetMapPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
}

declare class GCObjectReferencer extends UObject { 
	static Load(ResourceName: string): GCObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): GCObjectReferencer;
	static GetDefaultObject(): GCObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GCObjectReferencer;
	static C(Other: UObject | any): GCObjectReferencer;
}

declare class TextBuffer extends UObject { 
	static Load(ResourceName: string): TextBuffer;
	static Find(Outer: UObject, ResourceName: string): TextBuffer;
	static GetDefaultObject(): TextBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBuffer;
	static C(Other: UObject | any): TextBuffer;
}

declare class DelegateFunction extends UFunction { 
	static Load(ResourceName: string): DelegateFunction;
	static Find(Outer: UObject, ResourceName: string): DelegateFunction;
	static GetDefaultObject(): DelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateFunction;
	static C(Other: UObject | any): DelegateFunction;
}

declare class SparseDelegateFunction extends DelegateFunction { 
	static Load(ResourceName: string): SparseDelegateFunction;
	static Find(Outer: UObject, ResourceName: string): SparseDelegateFunction;
	static GetDefaultObject(): SparseDelegateFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SparseDelegateFunction;
	static C(Other: UObject | any): SparseDelegateFunction;
}

declare class DynamicClass extends Class { 
	static Load(ResourceName: string): DynamicClass;
	static Find(Outer: UObject, ResourceName: string): DynamicClass;
	static GetDefaultObject(): DynamicClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicClass;
	static C(Other: UObject | any): DynamicClass;
}

declare class LinkerPlaceholderClass extends Class { 
	static Load(ResourceName: string): LinkerPlaceholderClass;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderClass;
	static GetDefaultObject(): LinkerPlaceholderClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderClass;
	static C(Other: UObject | any): LinkerPlaceholderClass;
}

declare class LinkerPlaceholderExportObject extends UObject { 
	static Load(ResourceName: string): LinkerPlaceholderExportObject;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderExportObject;
	static GetDefaultObject(): LinkerPlaceholderExportObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderExportObject;
	static C(Other: UObject | any): LinkerPlaceholderExportObject;
}

declare class LinkerPlaceholderFunction extends UFunction { 
	static Load(ResourceName: string): LinkerPlaceholderFunction;
	static Find(Outer: UObject, ResourceName: string): LinkerPlaceholderFunction;
	static GetDefaultObject(): LinkerPlaceholderFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinkerPlaceholderFunction;
	static C(Other: UObject | any): LinkerPlaceholderFunction;
}

declare class MetaData extends UObject { 
	static Load(ResourceName: string): MetaData;
	static Find(Outer: UObject, ResourceName: string): MetaData;
	static GetDefaultObject(): MetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaData;
	static C(Other: UObject | any): MetaData;
}

declare class ObjectRedirector extends UObject { 
	static Load(ResourceName: string): ObjectRedirector;
	static Find(Outer: UObject, ResourceName: string): ObjectRedirector;
	static GetDefaultObject(): ObjectRedirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectRedirector;
	static C(Other: UObject | any): ObjectRedirector;
}

declare class Property extends Field { 
	static Load(ResourceName: string): Property;
	static Find(Outer: UObject, ResourceName: string): Property;
	static GetDefaultObject(): Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject | any): Property;
}

declare class EnumProperty extends Property { 
	static Load(ResourceName: string): EnumProperty;
	static Find(Outer: UObject, ResourceName: string): EnumProperty;
	static GetDefaultObject(): EnumProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnumProperty;
	static C(Other: UObject | any): EnumProperty;
}

declare class ArrayProperty extends Property { 
	static Load(ResourceName: string): ArrayProperty;
	static Find(Outer: UObject, ResourceName: string): ArrayProperty;
	static GetDefaultObject(): ArrayProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrayProperty;
	static C(Other: UObject | any): ArrayProperty;
}

declare class ObjectPropertyBase extends Property { 
	static Load(ResourceName: string): ObjectPropertyBase;
	static Find(Outer: UObject, ResourceName: string): ObjectPropertyBase;
	static GetDefaultObject(): ObjectPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectPropertyBase;
	static C(Other: UObject | any): ObjectPropertyBase;
}

declare class BoolProperty extends Property { 
	static Load(ResourceName: string): BoolProperty;
	static Find(Outer: UObject, ResourceName: string): BoolProperty;
	static GetDefaultObject(): BoolProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolProperty;
	static C(Other: UObject | any): BoolProperty;
}

declare class NumericProperty extends Property { 
	static Load(ResourceName: string): NumericProperty;
	static Find(Outer: UObject, ResourceName: string): NumericProperty;
	static GetDefaultObject(): NumericProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NumericProperty;
	static C(Other: UObject | any): NumericProperty;
}

declare class ByteProperty extends NumericProperty { 
	static Load(ResourceName: string): ByteProperty;
	static Find(Outer: UObject, ResourceName: string): ByteProperty;
	static GetDefaultObject(): ByteProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ByteProperty;
	static C(Other: UObject | any): ByteProperty;
}

declare class ObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): ObjectProperty;
	static Find(Outer: UObject, ResourceName: string): ObjectProperty;
	static GetDefaultObject(): ObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectProperty;
	static C(Other: UObject | any): ObjectProperty;
}

declare class ClassProperty extends ObjectProperty { 
	static Load(ResourceName: string): ClassProperty;
	static Find(Outer: UObject, ResourceName: string): ClassProperty;
	static GetDefaultObject(): ClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassProperty;
	static C(Other: UObject | any): ClassProperty;
}

declare class DelegateProperty extends Property { 
	static Load(ResourceName: string): DelegateProperty;
	static Find(Outer: UObject, ResourceName: string): DelegateProperty;
	static GetDefaultObject(): DelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DelegateProperty;
	static C(Other: UObject | any): DelegateProperty;
}

declare class DoubleProperty extends NumericProperty { 
	static Load(ResourceName: string): DoubleProperty;
	static Find(Outer: UObject, ResourceName: string): DoubleProperty;
	static GetDefaultObject(): DoubleProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleProperty;
	static C(Other: UObject | any): DoubleProperty;
}

declare class FloatProperty extends NumericProperty { 
	static Load(ResourceName: string): FloatProperty;
	static Find(Outer: UObject, ResourceName: string): FloatProperty;
	static GetDefaultObject(): FloatProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatProperty;
	static C(Other: UObject | any): FloatProperty;
}

declare class IntProperty extends NumericProperty { 
	static Load(ResourceName: string): IntProperty;
	static Find(Outer: UObject, ResourceName: string): IntProperty;
	static GetDefaultObject(): IntProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntProperty;
	static C(Other: UObject | any): IntProperty;
}

declare class Int8Property extends NumericProperty { 
	static Load(ResourceName: string): Int8Property;
	static Find(Outer: UObject, ResourceName: string): Int8Property;
	static GetDefaultObject(): Int8Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int8Property;
	static C(Other: UObject | any): Int8Property;
}

declare class Int16Property extends NumericProperty { 
	static Load(ResourceName: string): Int16Property;
	static Find(Outer: UObject, ResourceName: string): Int16Property;
	static GetDefaultObject(): Int16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int16Property;
	static C(Other: UObject | any): Int16Property;
}

declare class Int64Property extends NumericProperty { 
	static Load(ResourceName: string): Int64Property;
	static Find(Outer: UObject, ResourceName: string): Int64Property;
	static GetDefaultObject(): Int64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int64Property;
	static C(Other: UObject | any): Int64Property;
}

declare class InterfaceProperty extends Property { 
	static Load(ResourceName: string): InterfaceProperty;
	static Find(Outer: UObject, ResourceName: string): InterfaceProperty;
	static GetDefaultObject(): InterfaceProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterfaceProperty;
	static C(Other: UObject | any): InterfaceProperty;
}

declare class LazyObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): LazyObjectProperty;
	static Find(Outer: UObject, ResourceName: string): LazyObjectProperty;
	static GetDefaultObject(): LazyObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LazyObjectProperty;
	static C(Other: UObject | any): LazyObjectProperty;
}

declare class MapProperty extends Property { 
	static Load(ResourceName: string): MapProperty;
	static Find(Outer: UObject, ResourceName: string): MapProperty;
	static GetDefaultObject(): MapProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapProperty;
	static C(Other: UObject | any): MapProperty;
}

declare class MulticastDelegateProperty extends Property { 
	static Load(ResourceName: string): MulticastDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegateProperty;
	static GetDefaultObject(): MulticastDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegateProperty;
	static C(Other: UObject | any): MulticastDelegateProperty;
}

declare class MulticastInlineDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastInlineDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegateProperty;
	static GetDefaultObject(): MulticastInlineDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegateProperty;
	static C(Other: UObject | any): MulticastInlineDelegateProperty;
}

declare class MulticastSparseDelegateProperty extends MulticastDelegateProperty { 
	static Load(ResourceName: string): MulticastSparseDelegateProperty;
	static Find(Outer: UObject, ResourceName: string): MulticastSparseDelegateProperty;
	static GetDefaultObject(): MulticastSparseDelegateProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastSparseDelegateProperty;
	static C(Other: UObject | any): MulticastSparseDelegateProperty;
}

declare class NameProperty extends Property { 
	static Load(ResourceName: string): NameProperty;
	static Find(Outer: UObject, ResourceName: string): NameProperty;
	static GetDefaultObject(): NameProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NameProperty;
	static C(Other: UObject | any): NameProperty;
}

declare class SetProperty extends Property { 
	static Load(ResourceName: string): SetProperty;
	static Find(Outer: UObject, ResourceName: string): SetProperty;
	static GetDefaultObject(): SetProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SetProperty;
	static C(Other: UObject | any): SetProperty;
}

declare class SoftObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): SoftObjectProperty;
	static Find(Outer: UObject, ResourceName: string): SoftObjectProperty;
	static GetDefaultObject(): SoftObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftObjectProperty;
	static C(Other: UObject | any): SoftObjectProperty;
}

declare class SoftClassProperty extends SoftObjectProperty { 
	static Load(ResourceName: string): SoftClassProperty;
	static Find(Outer: UObject, ResourceName: string): SoftClassProperty;
	static GetDefaultObject(): SoftClassProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoftClassProperty;
	static C(Other: UObject | any): SoftClassProperty;
}

declare class StrProperty extends Property { 
	static Load(ResourceName: string): StrProperty;
	static Find(Outer: UObject, ResourceName: string): StrProperty;
	static GetDefaultObject(): StrProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StrProperty;
	static C(Other: UObject | any): StrProperty;
}

declare class StructProperty extends Property { 
	static Load(ResourceName: string): StructProperty;
	static Find(Outer: UObject, ResourceName: string): StructProperty;
	static GetDefaultObject(): StructProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StructProperty;
	static C(Other: UObject | any): StructProperty;
}

declare class UInt16Property extends NumericProperty { 
	static Load(ResourceName: string): UInt16Property;
	static Find(Outer: UObject, ResourceName: string): UInt16Property;
	static GetDefaultObject(): UInt16Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt16Property;
	static C(Other: UObject | any): UInt16Property;
}

declare class UInt32Property extends NumericProperty { 
	static Load(ResourceName: string): UInt32Property;
	static Find(Outer: UObject, ResourceName: string): UInt32Property;
	static GetDefaultObject(): UInt32Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt32Property;
	static C(Other: UObject | any): UInt32Property;
}

declare class UInt64Property extends NumericProperty { 
	static Load(ResourceName: string): UInt64Property;
	static Find(Outer: UObject, ResourceName: string): UInt64Property;
	static GetDefaultObject(): UInt64Property;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UInt64Property;
	static C(Other: UObject | any): UInt64Property;
}

declare class WeakObjectProperty extends ObjectPropertyBase { 
	static Load(ResourceName: string): WeakObjectProperty;
	static Find(Outer: UObject, ResourceName: string): WeakObjectProperty;
	static GetDefaultObject(): WeakObjectProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WeakObjectProperty;
	static C(Other: UObject | any): WeakObjectProperty;
}

declare class TextProperty extends Property { 
	static Load(ResourceName: string): TextProperty;
	static Find(Outer: UObject, ResourceName: string): TextProperty;
	static GetDefaultObject(): TextProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextProperty;
	static C(Other: UObject | any): TextProperty;
}

declare class PropertyWrapper extends UObject { 
	static Load(ResourceName: string): PropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): PropertyWrapper;
	static GetDefaultObject(): PropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyWrapper;
	static C(Other: UObject | any): PropertyWrapper;
}

declare class MulticastDelegatePropertyWrapper extends PropertyWrapper { 
	static Load(ResourceName: string): MulticastDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastDelegatePropertyWrapper;
}

declare class MulticastInlineDelegatePropertyWrapper extends MulticastDelegatePropertyWrapper { 
	static Load(ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static Find(Outer: UObject, ResourceName: string): MulticastInlineDelegatePropertyWrapper;
	static GetDefaultObject(): MulticastInlineDelegatePropertyWrapper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MulticastInlineDelegatePropertyWrapper;
	static C(Other: UObject | any): MulticastInlineDelegatePropertyWrapper;
}

declare class InputCoreTypes extends UObject { 
	static Load(ResourceName: string): InputCoreTypes;
	static Find(Outer: UObject, ResourceName: string): InputCoreTypes;
	static GetDefaultObject(): InputCoreTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputCoreTypes;
	static C(Other: UObject | any): InputCoreTypes;
}

declare class FontFaceInterface extends Interface { 
	static Load(ResourceName: string): FontFaceInterface;
	static Find(Outer: UObject, ResourceName: string): FontFaceInterface;
	static GetDefaultObject(): FontFaceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontFaceInterface;
	static C(Other: UObject | any): FontFaceInterface;
}

declare class FontProviderInterface extends Interface { 
	static Load(ResourceName: string): FontProviderInterface;
	static Find(Outer: UObject, ResourceName: string): FontProviderInterface;
	static GetDefaultObject(): FontProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontProviderInterface;
	static C(Other: UObject | any): FontProviderInterface;
}

declare class SlateTypes extends UObject { 
	static Load(ResourceName: string): SlateTypes;
	static Find(Outer: UObject, ResourceName: string): SlateTypes;
	static GetDefaultObject(): SlateTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTypes;
	static C(Other: UObject | any): SlateTypes;
}

declare class SlateWidgetStyleContainerBase extends UObject { 
	static Load(ResourceName: string): SlateWidgetStyleContainerBase;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerBase;
	static GetDefaultObject(): SlateWidgetStyleContainerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerBase;
	static C(Other: UObject | any): SlateWidgetStyleContainerBase;
}

declare class SlateWidgetStyleAsset extends UObject { 
	CustomStyle: SlateWidgetStyleContainerBase;
	static Load(ResourceName: string): SlateWidgetStyleAsset;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleAsset;
	static GetDefaultObject(): SlateWidgetStyleAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleAsset;
	static C(Other: UObject | any): SlateWidgetStyleAsset;
}

declare class SlateWidgetStyleContainerInterface extends Interface { 
	static Load(ResourceName: string): SlateWidgetStyleContainerInterface;
	static Find(Outer: UObject, ResourceName: string): SlateWidgetStyleContainerInterface;
	static GetDefaultObject(): SlateWidgetStyleContainerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateWidgetStyleContainerInterface;
	static C(Other: UObject | any): SlateWidgetStyleContainerInterface;
}

declare class StyleColorList { 
	StyleColors: LinearColor;
	clone() : StyleColorList;
	static C(Other: UObject | any): StyleColorList;
}

declare class SlateThemeManager extends UObject { 
	CurrentThemeId: Guid;
	ActiveColors: StyleColorList;
	static Load(ResourceName: string): SlateThemeManager;
	static Find(Outer: UObject, ResourceName: string): SlateThemeManager;
	static GetDefaultObject(): SlateThemeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateThemeManager;
	static C(Other: UObject | any): SlateThemeManager;
}

declare class SlateWidgetStyle { 
	clone() : SlateWidgetStyle;
	static C(Other: UObject | any): SlateWidgetStyle;
}

declare class SlateSound { 
	ResourceObject: UObject;
	clone() : SlateSound;
	static C(Other: UObject | any): SlateSound;
}

declare class ButtonStyle extends SlateWidgetStyle { 
	Normal: SlateBrush;
	Hovered: SlateBrush;
	Pressed: SlateBrush;
	Disabled: SlateBrush;
	NormalForeground: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	DisabledForeground: SlateColor;
	NormalPadding: Margin;
	PressedPadding: Margin;
	PressedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	PressedSound: string;
	HoveredSound: string;
	clone() : ButtonStyle;
	static C(Other: UObject | any): ButtonStyle;
}

declare class ButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ButtonStyle: ButtonStyle;
	static Load(ResourceName: string): ButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ButtonWidgetStyle;
	static GetDefaultObject(): ButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonWidgetStyle;
	static C(Other: UObject | any): ButtonWidgetStyle;
}

declare type ESlateCheckBoxType = 'CheckBox' | 'ToggleButton' | 'ESlateCheckBoxType_MAX';
declare var ESlateCheckBoxType : { CheckBox:'CheckBox',ToggleButton:'ToggleButton',ESlateCheckBoxType_MAX:'ESlateCheckBoxType_MAX', };
declare class CheckBoxStyle extends SlateWidgetStyle { 
	CheckBoxType: ESlateCheckBoxType;
	UncheckedImage: SlateBrush;
	UncheckedHoveredImage: SlateBrush;
	UncheckedPressedImage: SlateBrush;
	CheckedImage: SlateBrush;
	CheckedHoveredImage: SlateBrush;
	CheckedPressedImage: SlateBrush;
	UndeterminedImage: SlateBrush;
	UndeterminedHoveredImage: SlateBrush;
	UndeterminedPressedImage: SlateBrush;
	Padding: Margin;
	BackgroundImage: SlateBrush;
	BackgroundHoveredImage: SlateBrush;
	BackgroundPressedImage: SlateBrush;
	ForegroundColor: SlateColor;
	HoveredForeground: SlateColor;
	PressedForeground: SlateColor;
	CheckedForeground: SlateColor;
	CheckedHoveredForeground: SlateColor;
	CheckedPressedForeground: SlateColor;
	UndeterminedForeground: SlateColor;
	BorderBackgroundColor: SlateColor;
	CheckedSlateSound: SlateSound;
	UncheckedSlateSound: SlateSound;
	HoveredSlateSound: SlateSound;
	CheckedSound: string;
	UncheckedSound: string;
	HoveredSound: string;
	clone() : CheckBoxStyle;
	static C(Other: UObject | any): CheckBoxStyle;
}

declare class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	CheckBoxStyle: CheckBoxStyle;
	static Load(ResourceName: string): CheckBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): CheckBoxWidgetStyle;
	static GetDefaultObject(): CheckBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxWidgetStyle;
	static C(Other: UObject | any): CheckBoxWidgetStyle;
}

declare class ComboButtonStyle extends SlateWidgetStyle { 
	ButtonStyle: ButtonStyle;
	DownArrowImage: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	MenuBorderBrush: SlateBrush;
	MenuBorderPadding: Margin;
	ContentPadding: Margin;
	DownArrowPadding: Margin;
	DownArrowAlign: EVerticalAlignment;
	clone() : ComboButtonStyle;
	static C(Other: UObject | any): ComboButtonStyle;
}

declare class ComboBoxStyle extends SlateWidgetStyle { 
	ComboButtonStyle: ComboButtonStyle;
	PressedSlateSound: SlateSound;
	SelectionChangeSlateSound: SlateSound;
	ContentPadding: Margin;
	MenuRowPadding: Margin;
	PressedSound: string;
	SelectionChangeSound: string;
	clone() : ComboBoxStyle;
	static C(Other: UObject | any): ComboBoxStyle;
}

declare class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboBoxStyle: ComboBoxStyle;
	static Load(ResourceName: string): ComboBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboBoxWidgetStyle;
	static GetDefaultObject(): ComboBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxWidgetStyle;
	static C(Other: UObject | any): ComboBoxWidgetStyle;
}

declare class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase { 
	ComboButtonStyle: ComboButtonStyle;
	static Load(ResourceName: string): ComboButtonWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ComboButtonWidgetStyle;
	static GetDefaultObject(): ComboButtonWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboButtonWidgetStyle;
	static C(Other: UObject | any): ComboButtonWidgetStyle;
}

declare class FontOutlineSettings { 
	OutlineSize: number;
	bSeparateFillAlpha: boolean;
	bApplyOutlineToDropShadows: boolean;
	OutlineMaterial: UObject;
	OutlineColor: LinearColor;
	clone() : FontOutlineSettings;
	static C(Other: UObject | any): FontOutlineSettings;
}

declare class SlateFontInfo { 
	FontObject: UObject;
	FontMaterial: UObject;
	OutlineSettings: FontOutlineSettings;
	TypefaceFontName: string;
	Size: number;
	LetterSpacing: number;
	FontName: string;
	Hinting: EFontHinting;
	clone() : SlateFontInfo;
	static C(Other: UObject | any): SlateFontInfo;
}

declare class ScrollBarStyle extends SlateWidgetStyle { 
	HorizontalBackgroundImage: SlateBrush;
	VerticalBackgroundImage: SlateBrush;
	VerticalTopSlotImage: SlateBrush;
	HorizontalTopSlotImage: SlateBrush;
	VerticalBottomSlotImage: SlateBrush;
	HorizontalBottomSlotImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DraggedThumbImage: SlateBrush;
	Thickness: number;
	clone() : ScrollBarStyle;
	static C(Other: UObject | any): ScrollBarStyle;
}

declare class EditableTextBoxStyle extends SlateWidgetStyle { 
	BackgroundImageNormal: SlateBrush;
	BackgroundImageHovered: SlateBrush;
	BackgroundImageFocused: SlateBrush;
	BackgroundImageReadOnly: SlateBrush;
	Padding: Margin;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	BackgroundColor: SlateColor;
	ReadOnlyForegroundColor: SlateColor;
	FocusedForegroundColor: SlateColor;
	HScrollBarPadding: Margin;
	VScrollBarPadding: Margin;
	ScrollBarStyle: ScrollBarStyle;
	clone() : EditableTextBoxStyle;
	static C(Other: UObject | any): EditableTextBoxStyle;
}

declare class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextBoxStyle: EditableTextBoxStyle;
	static Load(ResourceName: string): EditableTextBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextBoxWidgetStyle;
	static GetDefaultObject(): EditableTextBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBoxWidgetStyle;
	static C(Other: UObject | any): EditableTextBoxWidgetStyle;
}

declare class EditableTextStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	BackgroundImageSelected: SlateBrush;
	BackgroundImageComposing: SlateBrush;
	CaretImage: SlateBrush;
	clone() : EditableTextStyle;
	static C(Other: UObject | any): EditableTextStyle;
}

declare class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase { 
	EditableTextStyle: EditableTextStyle;
	static Load(ResourceName: string): EditableTextWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): EditableTextWidgetStyle;
	static GetDefaultObject(): EditableTextWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextWidgetStyle;
	static C(Other: UObject | any): EditableTextWidgetStyle;
}

declare class ProgressBarStyle extends SlateWidgetStyle { 
	BackgroundImage: SlateBrush;
	FillImage: SlateBrush;
	MarqueeImage: SlateBrush;
	EnableFillAnimation: boolean;
	clone() : ProgressBarStyle;
	static C(Other: UObject | any): ProgressBarStyle;
}

declare class ProgressWidgetStyle extends SlateWidgetStyleContainerBase { 
	ProgressBarStyle: ProgressBarStyle;
	static Load(ResourceName: string): ProgressWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ProgressWidgetStyle;
	static GetDefaultObject(): ProgressWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressWidgetStyle;
	static C(Other: UObject | any): ProgressWidgetStyle;
}

declare class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBarStyle: ScrollBarStyle;
	static Load(ResourceName: string): ScrollBarWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBarWidgetStyle;
	static GetDefaultObject(): ScrollBarWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBarWidgetStyle;
	static C(Other: UObject | any): ScrollBarWidgetStyle;
}

declare class ScrollBoxStyle extends SlateWidgetStyle { 
	BarThickness: number;
	TopShadowBrush: SlateBrush;
	BottomShadowBrush: SlateBrush;
	LeftShadowBrush: SlateBrush;
	RightShadowBrush: SlateBrush;
	clone() : ScrollBoxStyle;
	static C(Other: UObject | any): ScrollBoxStyle;
}

declare class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	ScrollBoxStyle: ScrollBoxStyle;
	static Load(ResourceName: string): ScrollBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): ScrollBoxWidgetStyle;
	static GetDefaultObject(): ScrollBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxWidgetStyle;
	static C(Other: UObject | any): ScrollBoxWidgetStyle;
}

declare class SlateSettings extends UObject { 
	bExplicitCanvasChildZOrder: boolean;
	static Load(ResourceName: string): SlateSettings;
	static Find(Outer: UObject, ResourceName: string): SlateSettings;
	static GetDefaultObject(): SlateSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateSettings;
	static C(Other: UObject | any): SlateSettings;
}

declare class SpinBoxStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	ActiveBackgroundBrush: SlateBrush;
	HoveredBackgroundBrush: SlateBrush;
	ActiveFillBrush: SlateBrush;
	HoveredFillBrush: SlateBrush;
	InactiveFillBrush: SlateBrush;
	ArrowsImage: SlateBrush;
	ForegroundColor: SlateColor;
	TextPadding: Margin;
	InsetPadding: Margin;
	clone() : SpinBoxStyle;
	static C(Other: UObject | any): SpinBoxStyle;
}

declare class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase { 
	SpinBoxStyle: SpinBoxStyle;
	static Load(ResourceName: string): SpinBoxWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): SpinBoxWidgetStyle;
	static GetDefaultObject(): SpinBoxWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBoxWidgetStyle;
	static C(Other: UObject | any): SpinBoxWidgetStyle;
}

declare type ETextTransformPolicy = 'None' | 'ToLower' | 'ToUpper' | 'ETextTransformPolicy_MAX';
declare var ETextTransformPolicy : { None:'None',ToLower:'ToLower',ToUpper:'ToUpper',ETextTransformPolicy_MAX:'ETextTransformPolicy_MAX', };
declare type ETextOverflowPolicy = 'Clip' | 'Ellipsis' | 'ETextOverflowPolicy_MAX';
declare var ETextOverflowPolicy : { Clip:'Clip',Ellipsis:'Ellipsis',ETextOverflowPolicy_MAX:'ETextOverflowPolicy_MAX', };
declare class TextBlockStyle extends SlateWidgetStyle { 
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	SelectedBackgroundColor: SlateColor;
	HighlightColor: SlateColor;
	HighlightShape: SlateBrush;
	StrikeBrush: SlateBrush;
	UnderlineBrush: SlateBrush;
	TransformPolicy: ETextTransformPolicy;
	OverflowPolicy: ETextOverflowPolicy;
	clone() : TextBlockStyle;
	static C(Other: UObject | any): TextBlockStyle;
}

declare class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase { 
	TextBlockStyle: TextBlockStyle;
	static Load(ResourceName: string): TextBlockWidgetStyle;
	static Find(Outer: UObject, ResourceName: string): TextBlockWidgetStyle;
	static GetDefaultObject(): TextBlockWidgetStyle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlockWidgetStyle;
	static C(Other: UObject | any): TextBlockWidgetStyle;
}

declare class ToolMenuBase extends UObject { 
	static Load(ResourceName: string): ToolMenuBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuBase;
	static GetDefaultObject(): ToolMenuBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuBase;
	static C(Other: UObject | any): ToolMenuBase;
}

declare class TypedElementCounterInterface extends Interface { 
	static Load(ResourceName: string): TypedElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementCounterInterface;
	static GetDefaultObject(): TypedElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementCounterInterface;
	static C(Other: UObject | any): TypedElementCounterInterface;
}

declare class TestTypedElementInterfaceA extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceA;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA;
	static GetDefaultObject(): TestTypedElementInterfaceA;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA;
	SetDisplayName(InElementHandle: ScriptTypedElementHandle,InNewName: string,bNotify: boolean): boolean;
	GetDisplayName(InElementHandle: ScriptTypedElementHandle): string;
	static C(Other: UObject | any): TestTypedElementInterfaceA;
}

declare class TestTypedElementInterfaceB extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceB;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceB;
	static GetDefaultObject(): TestTypedElementInterfaceB;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceB;
	MarkAsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceB;
}

declare class TestTypedElementInterfaceC extends Interface { 
	static Load(ResourceName: string): TestTypedElementInterfaceC;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceC;
	static GetDefaultObject(): TestTypedElementInterfaceC;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceC;
	GetIsTested(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TestTypedElementInterfaceC;
}

declare class TestTypedElementInterfaceA_ImplTyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplTyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplTyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplTyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplTyped;
}

declare class TestTypedElementInterfaceA_ImplUntyped extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceA_ImplUntyped;
	static GetDefaultObject(): TestTypedElementInterfaceA_ImplUntyped;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceA_ImplUntyped;
	static C(Other: UObject | any): TestTypedElementInterfaceA_ImplUntyped;
}

declare class TestTypedElementInterfaceBAndC_Typed extends UObject { 
	static Load(ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static Find(Outer: UObject, ResourceName: string): TestTypedElementInterfaceBAndC_Typed;
	static GetDefaultObject(): TestTypedElementInterfaceBAndC_Typed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestTypedElementInterfaceBAndC_Typed;
	static C(Other: UObject | any): TestTypedElementInterfaceBAndC_Typed;
}

declare class TypedElementHandleLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementHandleLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementHandleLibrary;
	static GetDefaultObject(): TypedElementHandleLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHandleLibrary;
	static Release(ElementHandle?: ScriptTypedElementHandle): {ElementHandle: ScriptTypedElementHandle};
	static NotEqual(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static IsSet(ElementHandle: ScriptTypedElementHandle): boolean;
	static Equal(LHS: ScriptTypedElementHandle,RHS: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementHandleLibrary;
}

declare class ScriptTypedElementListProxy { 
	clone() : ScriptTypedElementListProxy;
	static C(Other: UObject | any): ScriptTypedElementListProxy;
}

declare class TypedElementRegistry extends UObject { 
	static Load(ResourceName: string): TypedElementRegistry;
	static Find(Outer: UObject, ResourceName: string): TypedElementRegistry;
	static GetDefaultObject(): TypedElementRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementRegistry;
	static GetInstance(): TypedElementRegistry;
	GetElementInterface(InElementHandle: ScriptTypedElementHandle,InBaseInterfaceType: UnrealEngineClass): UObject;
	static C(Other: UObject | any): TypedElementRegistry;
}

declare class TypedElementListLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementListLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementListLibrary;
	static GetDefaultObject(): TypedElementListLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementListLibrary;
	static Shrink(ElementList: ScriptTypedElementListProxy): void;
	static Reset(ElementList: ScriptTypedElementListProxy): void;
	static Reserve(ElementList: ScriptTypedElementListProxy,Size: number): void;
	static Remove(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Num(ElementList: ScriptTypedElementListProxy): number;
	static IsValidIndex(ElementList: ScriptTypedElementListProxy,index: number): boolean;
	static HasElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): boolean;
	static HasElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): boolean;
	static GetElementInterface(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle,BaseInterfaceType: UnrealEngineClass): UObject;
	static GetElementHandles(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	static GetElementHandleAt(ElementList: ScriptTypedElementListProxy,index: number): ScriptTypedElementHandle;
	static Empty(ElementList: ScriptTypedElementListProxy,Slack: number): void;
	static CreateScriptElementList(Registry: TypedElementRegistry): ScriptTypedElementListProxy;
	static CountElementsOfType(ElementList: ScriptTypedElementListProxy,ElementTypeName: string): number;
	static CountElements(ElementList: ScriptTypedElementListProxy,BaseInterfaceType: UnrealEngineClass): number;
	static Contains(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static Clone(ElementList: ScriptTypedElementListProxy): ScriptTypedElementListProxy;
	static AppendList(ElementList: ScriptTypedElementListProxy,OtherElementList: ScriptTypedElementListProxy): void;
	static Append(ElementList: ScriptTypedElementListProxy,ElementHandles: ScriptTypedElementHandle[]): void;
	static Add(ElementList: ScriptTypedElementListProxy,ElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementListLibrary;
}

declare class TypedElementAssetDataInterface extends Interface { 
	static Load(ResourceName: string): TypedElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementAssetDataInterface;
	static GetDefaultObject(): TypedElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementAssetDataInterface;
	GetAssetData(InElementHandle: ScriptTypedElementHandle): AssetData;
	GetAllReferencedAssetDatas(InElementHandle: ScriptTypedElementHandle): AssetData[];
	static C(Other: UObject | any): TypedElementAssetDataInterface;
}

declare class TypedElementHierarchyInterface extends Interface { 
	static Load(ResourceName: string): TypedElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementHierarchyInterface;
	static GetDefaultObject(): TypedElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementHierarchyInterface;
	GetParentElement(InElementHandle: ScriptTypedElementHandle,bAllowCreate: boolean): ScriptTypedElementHandle;
	GetChildElements(InElementHandle: ScriptTypedElementHandle,OutElementHandles?: ScriptTypedElementHandle[],bAllowCreate?: boolean): {OutElementHandles: ScriptTypedElementHandle[]};
	static C(Other: UObject | any): TypedElementHierarchyInterface;
}

declare class TypedElementObjectInterface extends Interface { 
	static Load(ResourceName: string): TypedElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementObjectInterface;
	static GetDefaultObject(): TypedElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementObjectInterface;
	GetObjectClass(InElementHandle: ScriptTypedElementHandle): UnrealEngineClass;
	GetObject(InElementHandle: ScriptTypedElementHandle): UObject;
	static C(Other: UObject | any): TypedElementObjectInterface;
}

declare type ETypedElementChildInclusionMethod = 'None' | 'Immediate' | 'Recursive' | 'ETypedElementChildInclusionMethod_MAX';
declare var ETypedElementChildInclusionMethod : { None:'None',Immediate:'Immediate',Recursive:'Recursive',ETypedElementChildInclusionMethod_MAX:'ETypedElementChildInclusionMethod_MAX', };
declare class TypedElementSelectionOptions { 
	bAllowHidden: boolean;
	bAllowGroups: boolean;
	bAllowLegacyNotifications: boolean;
	bWarnIfLocked: boolean;
	ChildElementInclusionMethod: ETypedElementChildInclusionMethod;
	clone() : TypedElementSelectionOptions;
	static C(Other: UObject | any): TypedElementSelectionOptions;
}

declare class TypedElementIsSelectedOptions { 
	bAllowIndirect: boolean;
	clone() : TypedElementIsSelectedOptions;
	static C(Other: UObject | any): TypedElementIsSelectedOptions;
}

declare type ETypedElementSelectionMethod = 'Primary' | 'Secondary' | 'ETypedElementSelectionMethod_MAX';
declare var ETypedElementSelectionMethod : { Primary:'Primary',Secondary:'Secondary',ETypedElementSelectionMethod_MAX:'ETypedElementSelectionMethod_MAX', };
declare class TypedElementSelectionInterface extends Interface { 
	static Load(ResourceName: string): TypedElementSelectionInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionInterface;
	static GetDefaultObject(): TypedElementSelectionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionInterface;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InCurrentSelection: ScriptTypedElementListProxy,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle,InSelectionSet: ScriptTypedElementListProxy): boolean;
	static C(Other: UObject | any): TypedElementSelectionInterface;
}

declare class TypedElementSelectionSetState { 
	CreatedFromSelectionSet: any;
	clone() : TypedElementSelectionSetState;
	static C(Other: UObject | any): TypedElementSelectionSetState;
}

declare class TypedElementSelectionSet extends UObject { 
	OnPreSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	OnSelectionChange: UnrealEngineMulticastDelegate<(SelectionSet: TypedElementSelectionSet) => void>;
	static Load(ResourceName: string): TypedElementSelectionSet;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSet;
	static GetDefaultObject(): TypedElementSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSet;
	SetSelection(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	SelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	RestoreSelectionState(InSelectionState: TypedElementSelectionSetState): void;
	K2_GetSelectedElementHandles(InBaseInterfaceType: UnrealEngineClass): ScriptTypedElementHandle[];
	IsElementSelected(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementIsSelectedOptions): boolean;
	HasSelectedObjects(InRequiredClass: UnrealEngineClass): boolean;
	HasSelectedElements(InBaseInterfaceType: UnrealEngineClass): boolean;
	GetTopSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	GetSelectionElement(InElementHandle: ScriptTypedElementHandle,InSelectionMethod: ETypedElementSelectionMethod): ScriptTypedElementHandle;
	GetSelectedObjects(InRequiredClass: UnrealEngineClass): UObject[];
	GetNumSelectedElements(): number;
	GetCurrentSelectionState(): TypedElementSelectionSetState;
	GetBottomSelectedObject(InRequiredClass: UnrealEngineClass): UObject;
	DeselectElements(InElementHandles: ScriptTypedElementHandle[],InSelectionOptions: TypedElementSelectionOptions): boolean;
	DeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CountSelectedObjects(InRequiredClass: UnrealEngineClass): number;
	CountSelectedElements(InBaseInterfaceType: UnrealEngineClass): number;
	ClearSelection(InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanSelectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	CanDeselectElement(InElementHandle: ScriptTypedElementHandle,InSelectionOptions: TypedElementSelectionOptions): boolean;
	AllowSelectionModifiers(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementSelectionSet;
}

declare class TypedElementSelectionNormalizationOptions { 
	bExpandGroups: boolean;
	bFollowAttachment: boolean;
	clone() : TypedElementSelectionNormalizationOptions;
	static C(Other: UObject | any): TypedElementSelectionNormalizationOptions;
}

declare class TypedElementSelectionSetLibrary extends UObject { 
	static Load(ResourceName: string): TypedElementSelectionSetLibrary;
	static Find(Outer: UObject, ResourceName: string): TypedElementSelectionSetLibrary;
	static GetDefaultObject(): TypedElementSelectionSetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementSelectionSetLibrary;
	static SetSelectionFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static SelectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static GetNormalizedSelection(SelectionSet: TypedElementSelectionSet,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static GetNormalizedElementList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,NormalizationOptions: TypedElementSelectionNormalizationOptions): ScriptTypedElementListProxy;
	static DeselectElementsFromList(SelectionSet: TypedElementSelectionSet,ElementList: ScriptTypedElementListProxy,SelectionOptions: TypedElementSelectionOptions): boolean;
	static C(Other: UObject | any): TypedElementSelectionSetLibrary;
}

declare type EColorVisionDeficiency = 'NormalVision' | 'Deuteranope' | 'Protanope' | 'Tritanope' | 'EColorVisionDeficiency_MAX';
declare var EColorVisionDeficiency : { NormalVision:'NormalVision',Deuteranope:'Deuteranope',Protanope:'Protanope',Tritanope:'Tritanope',EColorVisionDeficiency_MAX:'EColorVisionDeficiency_MAX', };
declare type ELogTimes = 'None' | 'UTC' | 'SinceGStartTime' | 'Local' | 'ELogTimes_MAX';
declare var ELogTimes : { None:'None',UTC:'UTC',SinceGStartTime:'SinceGStartTime',Local:'Local',ELogTimes_MAX:'ELogTimes_MAX', };
declare type ELogCategoryColorizationMode = 'None' | 'ColorizeWholeLine' | 'ColorizeCategoryOnly' | 'ColorizeCategoryAsBadge' | 'ELogCategoryColorizationMode_MAX';
declare var ELogCategoryColorizationMode : { None:'None',ColorizeWholeLine:'ColorizeWholeLine',ColorizeCategoryOnly:'ColorizeCategoryOnly',ColorizeCategoryAsBadge:'ColorizeCategoryAsBadge',ELogCategoryColorizationMode_MAX:'ELogCategoryColorizationMode_MAX', };
declare type EAssetEditorOpenLocation = 'Default' | 'NewWindow' | 'MainWindow' | 'ContentBrowser' | 'LastDockedWindowOrNewWindow' | 'LastDockedWindowOrMainWindow' | 'LastDockedWindowOrContentBrowser' | 'EAssetEditorOpenLocation_MAX';
declare var EAssetEditorOpenLocation : { Default:'Default',NewWindow:'NewWindow',MainWindow:'MainWindow',ContentBrowser:'ContentBrowser',LastDockedWindowOrNewWindow:'LastDockedWindowOrNewWindow',LastDockedWindowOrMainWindow:'LastDockedWindowOrMainWindow',LastDockedWindowOrContentBrowser:'LastDockedWindowOrContentBrowser',EAssetEditorOpenLocation_MAX:'EAssetEditorOpenLocation_MAX', };
declare class EditorStyleSettings extends UObject { 
	bEnableHighDPIAwareness: boolean;
	bEnableUserEditorLayoutManagement: boolean;
	ColorVisionDeficiencyPreviewType: EColorVisionDeficiency;
	ColorVisionDeficiencySeverity: number;
	bColorVisionDeficiencyCorrection: boolean;
	bColorVisionDeficiencyCorrectionPreviewWithDeficiency: boolean;
	SelectionColor: LinearColor;
	bEnableEditorWindowBackgroundColor: boolean;
	EditorWindowBackgroundColor: LinearColor;
	bUseSmallToolBarIcons: boolean;
	bUseGrid: boolean;
	RegularColor: LinearColor;
	RuleColor: LinearColor;
	CenterColor: LinearColor;
	GridSnapSize: any;
	GraphBackgroundBrush: SlateBrush;
	bShowFriendlyNames: boolean;
	bShowNativeComponentNames: boolean;
	bExpandConfigurationMenus: boolean;
	bShowProjectMenus: boolean;
	bShowLaunchMenus: boolean;
	bShowAllAdvancedDetails: boolean;
	bShowHiddenPropertiesWhilePlaying: boolean;
	LogFontSize: number;
	LogTimestampMode: ELogTimes;
	bPromoteOutputLogWarningsDuringPIE: boolean;
	CategoryColorizationMode: ELogCategoryColorizationMode;
	bCycleToOutputLogDrawer: boolean;
	AssetEditorOpenLocation: EAssetEditorOpenLocation;
	bEnableColorizedEditorTabs: boolean;
	static Load(ResourceName: string): EditorStyleSettings;
	static Find(Outer: UObject, ResourceName: string): EditorStyleSettings;
	static GetDefaultObject(): EditorStyleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorStyleSettings;
	static C(Other: UObject | any): EditorStyleSettings;
}

declare class MaterialShaderQualitySettings extends UObject { 
	ForwardSettingMap: any;
	static Load(ResourceName: string): MaterialShaderQualitySettings;
	static Find(Outer: UObject, ResourceName: string): MaterialShaderQualitySettings;
	static GetDefaultObject(): MaterialShaderQualitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialShaderQualitySettings;
	static C(Other: UObject | any): MaterialShaderQualitySettings;
}

declare type EMobileShadowQuality = 'NoFiltering' | 'PCF_1x1' | 'PCF_3x3' | 'PCF_5x5' | 'EMobileShadowQuality_MAX';
declare var EMobileShadowQuality : { NoFiltering:'NoFiltering',PCF_1x1:'PCF_1x1',PCF_3x3:'PCF_3x3',PCF_5x5:'PCF_5x5',EMobileShadowQuality_MAX:'EMobileShadowQuality_MAX', };
declare class MaterialQualityOverrides { 
	bDiscardQualityDuringCook: boolean;
	bEnableOverride: boolean;
	bForceFullyRough: boolean;
	bForceNonMetal: boolean;
	bForceDisableLMDirectionality: boolean;
	bForceLQReflections: boolean;
	bForceDisablePreintegratedGF: boolean;
	bDisableMaterialNormalCalculation: boolean;
	MobileShadowQuality: EMobileShadowQuality;
	clone() : MaterialQualityOverrides;
	static C(Other: UObject | any): MaterialQualityOverrides;
}

declare class ShaderPlatformQualitySettings extends UObject { 
	QualityOverrides: MaterialQualityOverrides;
	static Load(ResourceName: string): ShaderPlatformQualitySettings;
	static Find(Outer: UObject, ResourceName: string): ShaderPlatformQualitySettings;
	static GetDefaultObject(): ShaderPlatformQualitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderPlatformQualitySettings;
	static C(Other: UObject | any): ShaderPlatformQualitySettings;
}

declare class DeveloperSettings extends UObject { 
	static Load(ResourceName: string): DeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettings;
	static GetDefaultObject(): DeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettings;
	static C(Other: UObject | any): DeveloperSettings;
}

declare class DeveloperSettingsBackedByCVars extends DeveloperSettings { 
	static Load(ResourceName: string): DeveloperSettingsBackedByCVars;
	static Find(Outer: UObject, ResourceName: string): DeveloperSettingsBackedByCVars;
	static GetDefaultObject(): DeveloperSettingsBackedByCVars;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeveloperSettingsBackedByCVars;
	static C(Other: UObject | any): DeveloperSettingsBackedByCVars;
}

declare class PlatformSettings extends UObject { 
	static Load(ResourceName: string): PlatformSettings;
	static Find(Outer: UObject, ResourceName: string): PlatformSettings;
	static GetDefaultObject(): PlatformSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettings;
	static C(Other: UObject | any): PlatformSettings;
}

declare class PlatformSettingsManager extends UObject { 
	SettingsMap: any;
	static Load(ResourceName: string): PlatformSettingsManager;
	static Find(Outer: UObject, ResourceName: string): PlatformSettingsManager;
	static GetDefaultObject(): PlatformSettingsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformSettingsManager;
	static C(Other: UObject | any): PlatformSettingsManager;
}

declare type ECookProgressDisplayMode = 'Nothing' | 'RemainingPackages' | 'PackageNames' | 'NamesAndRemainingPackages' | 'Instigators' | 'InstigatorsAndCount' | 'InstigatorsAndNames' | 'InstigatorsAndNamesAndCount' | 'Max' | 'ECookProgressDisplayMode_MAX';
declare var ECookProgressDisplayMode : { Nothing:'Nothing',RemainingPackages:'RemainingPackages',PackageNames:'PackageNames',NamesAndRemainingPackages:'NamesAndRemainingPackages',Instigators:'Instigators',InstigatorsAndCount:'InstigatorsAndCount',InstigatorsAndNames:'InstigatorsAndNames',InstigatorsAndNamesAndCount:'InstigatorsAndNamesAndCount',Max:'Max',ECookProgressDisplayMode_MAX:'ECookProgressDisplayMode_MAX', };
declare type EBlueprintComponentDataCookingMethod = 'Disabled' | 'AllBlueprints' | 'EnabledBlueprintsOnly' | 'EBlueprintComponentDataCookingMethod_MAX';
declare var EBlueprintComponentDataCookingMethod : { Disabled:'Disabled',AllBlueprints:'AllBlueprints',EnabledBlueprintsOnly:'EnabledBlueprintsOnly',EBlueprintComponentDataCookingMethod_MAX:'EBlueprintComponentDataCookingMethod_MAX', };
declare type ETextureFormatASTCCompressor = 'IntelISPC' | 'Arm' | 'Max' | 'ETextureFormatASTCCompressor_MAX';
declare var ETextureFormatASTCCompressor : { IntelISPC:'IntelISPC',Arm:'Arm',Max:'Max',ETextureFormatASTCCompressor_MAX:'ETextureFormatASTCCompressor_MAX', };
declare class CookerSettings extends DeveloperSettings { 
	bEnableCookOnTheSide: boolean;
	bEnableBuildDDCInBackground: boolean;
	bIterativeCookingForLaunchOn: boolean;
	bIterativeCookingForFileCookContent: boolean;
	bCookOnTheFlyForLaunchOn: boolean;
	CookProgressDisplayMode: ECookProgressDisplayMode;
	bIgnoreIniSettingsOutOfDateForIteration: boolean;
	bIgnoreScriptPackagesOutOfDateForIteration: boolean;
	bCompileBlueprintsInDevelopmentMode: boolean;
	BlueprintComponentDataCookingMethod: EBlueprintComponentDataCookingMethod;
	ClassesExcludedOnDedicatedServer: string[];
	ModulesExcludedOnDedicatedServer: string[];
	ClassesExcludedOnDedicatedClient: string[];
	ModulesExcludedOnDedicatedClient: string[];
	VersionedIntRValues: string[];
	DefaultASTCQualityBySpeed: number;
	DefaultASTCQualityBySize: number;
	DefaultASTCCompressor: ETextureFormatASTCCompressor;
	bAllowASTCHDRProfile: boolean;
	bAllowCookedDataInEditorBuilds: boolean;
	bCookBlueprintComponentTemplateData: boolean;
	static Load(ResourceName: string): CookerSettings;
	static Find(Outer: UObject, ResourceName: string): CookerSettings;
	static GetDefaultObject(): CookerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerSettings;
	static C(Other: UObject | any): CookerSettings;
}

declare type EProjectPackagingBuild = 'Always' | 'Never' | 'IfProjectHasCode' | 'IfEditorWasBuiltLocally' | 'EProjectPackagingBuild_MAX';
declare var EProjectPackagingBuild : { Always:'Always',Never:'Never',IfProjectHasCode:'IfProjectHasCode',IfEditorWasBuiltLocally:'IfEditorWasBuiltLocally',EProjectPackagingBuild_MAX:'EProjectPackagingBuild_MAX', };
declare type EProjectPackagingBuildConfigurations = 'PPBC_Debug' | 'PPBC_DebugGame' | 'PPBC_Development' | 'PPBC_Test' | 'PPBC_Shipping' | 'PPBC_MAX';
declare var EProjectPackagingBuildConfigurations : { PPBC_Debug:'PPBC_Debug',PPBC_DebugGame:'PPBC_DebugGame',PPBC_Development:'PPBC_Development',PPBC_Test:'PPBC_Test',PPBC_Shipping:'PPBC_Shipping',PPBC_MAX:'PPBC_MAX', };
declare class DirectoryPath { 
	Path: string;
	clone() : DirectoryPath;
	static C(Other: UObject | any): DirectoryPath;
}

declare type EProjectPackagingBlueprintNativizationMethod = 'Disabled' | 'Inclusive' | 'Exclusive' | 'EProjectPackagingBlueprintNativizationMethod_MAX';
declare var EProjectPackagingBlueprintNativizationMethod : { Disabled:'Disabled',Inclusive:'Inclusive',Exclusive:'Exclusive',EProjectPackagingBlueprintNativizationMethod_MAX:'EProjectPackagingBlueprintNativizationMethod_MAX', };
declare type EProjectPackagingInternationalizationPresets = 'English' | 'EFIGS' | 'EFIGSCJK' | 'CJK' | 'All' | 'EProjectPackagingInternationalizationPresets_MAX';
declare var EProjectPackagingInternationalizationPresets : { English:'English',EFIGS:'EFIGS',EFIGSCJK:'EFIGSCJK',CJK:'CJK',All:'All',EProjectPackagingInternationalizationPresets_MAX:'EProjectPackagingInternationalizationPresets_MAX', };
declare class ProjectBuildSettings { 
	Name: string;
	SpecificPlatforms: string[];
	BuildCookRunParams: string;
	clone() : ProjectBuildSettings;
	static C(Other: UObject | any): ProjectBuildSettings;
}

declare class ProjectPackagingSettings extends UObject { 
	Build: EProjectPackagingBuild;
	BuildConfiguration: EProjectPackagingBuildConfigurations;
	BuildTarget: string;
	LaunchOnTarget: string;
	StagingDirectory: DirectoryPath;
	FullRebuild: boolean;
	ForDistribution: boolean;
	IncludeDebugFiles: boolean;
	BlueprintNativizationMethod: EProjectPackagingBlueprintNativizationMethod;
	NativizeBlueprintAssets: FilePath[];
	bIncludeNativizedAssetsInProjectGeneration: boolean;
	bExcludeMonolithicEngineHeadersInNativizedCode: boolean;
	UsePakFile: boolean;
	bUseIoStore: boolean;
	bUseZenStore: boolean;
	bMakeBinaryConfig: boolean;
	bGenerateChunks: boolean;
	bGenerateNoChunks: boolean;
	bChunkHardReferencesOnly: boolean;
	bForceOneChunkPerFile: boolean;
	MaxChunkSize: any;
	bBuildHttpChunkInstallData: boolean;
	HttpChunkInstallDataDirectory: DirectoryPath;
	bCompressed: boolean;
	PackageCompressionFormat: string;
	bForceUseProjectCompressionFormatIgnoreHardwareOverride: boolean;
	PackageAdditionalCompressionOptions: string;
	PackageCompressionMethod: string;
	PackageCompressionLevel_DebugDevelopment: number;
	PackageCompressionLevel_TestShipping: number;
	PackageCompressionLevel_Distribution: number;
	PackageCompressionMinBytesSaved: number;
	PackageCompressionMinPercentSaved: number;
	bPackageCompressionEnableDDC: boolean;
	PackageCompressionMinSizeToConsiderDDC: number;
	HttpChunkInstallDataVersion: string;
	IncludePrerequisites: boolean;
	IncludeAppLocalPrerequisites: boolean;
	bShareMaterialShaderCode: boolean;
	bDeterministicShaderCodeOrder: boolean;
	bSharedMaterialNativeLibraries: boolean;
	ApplocalPrerequisitesDirectory: DirectoryPath;
	IncludeCrashReporter: boolean;
	InternationalizationPreset: EProjectPackagingInternationalizationPresets;
	CulturesToStage: string[];
	LocalizationTargetsToChunk: string[];
	LocalizationTargetCatchAllChunkId: number;
	bCookAll: boolean;
	bCookMapsOnly: boolean;
	bEncryptIniFiles: boolean;
	bEncryptPakIndex: boolean;
	GenerateEarlyDownloaderPakFile: boolean;
	bSkipEditorContent: boolean;
	bSkipMovies: boolean;
	UFSMovies: string[];
	NonUFSMovies: string[];
	CompressedChunkWildcard: string[];
	IniKeyBlacklist: string[];
	IniSectionBlacklist: string[];
	EarlyDownloaderPakFileFiles: string[];
	MapsToCook: FilePath[];
	DirectoriesToAlwaysCook: DirectoryPath[];
	DirectoriesToNeverCook: DirectoryPath[];
	TestDirectoriesToNotSearch: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFS: DirectoryPath[];
	DirectoriesToAlwaysStageAsUFSServer: DirectoryPath[];
	DirectoriesToAlwaysStageAsNonUFSServer: DirectoryPath[];
	ProjectCustomBuilds: ProjectBuildSettings[];
	EngineCustomBuilds: ProjectBuildSettings[];
	PerPlatformBuildConfig: any;
	PerPlatformTargetFlavorName: any;
	PerPlatformBuildTarget: any;
	static Load(ResourceName: string): ProjectPackagingSettings;
	static Find(Outer: UObject, ResourceName: string): ProjectPackagingSettings;
	static GetDefaultObject(): ProjectPackagingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProjectPackagingSettings;
	static C(Other: UObject | any): ProjectPackagingSettings;
}

declare class ClothingAssetFactoryBase extends UObject { 
	static Load(ResourceName: string): ClothingAssetFactoryBase;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetFactoryBase;
	static GetDefaultObject(): ClothingAssetFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetFactoryBase;
	static C(Other: UObject | any): ClothingAssetFactoryBase;
}

declare class StatePerObjectConfig extends UObject { 
	PerObjectConfigSection: string;
	bEnabled: boolean;
	static Load(ResourceName: string): StatePerObjectConfig;
	static Find(Outer: UObject, ResourceName: string): StatePerObjectConfig;
	static GetDefaultObject(): StatePerObjectConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatePerObjectConfig;
	static C(Other: UObject | any): StatePerObjectConfig;
}

declare class EscalationManagerConfig extends StatePerObjectConfig { 
	EscalationSeverity: string[];
	static Load(ResourceName: string): EscalationManagerConfig;
	static Find(Outer: UObject, ResourceName: string): EscalationManagerConfig;
	static GetDefaultObject(): EscalationManagerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EscalationManagerConfig;
	static C(Other: UObject | any): EscalationManagerConfig;
}

declare class NetAnalyticsDataConfig { 
	DataName: string;
	bEnabled: boolean;
	clone() : NetAnalyticsDataConfig;
	static C(Other: UObject | any): NetAnalyticsDataConfig;
}

declare class NetAnalyticsAggregatorConfig extends UObject { 
	NetAnalyticsData: NetAnalyticsDataConfig[];
	static Load(ResourceName: string): NetAnalyticsAggregatorConfig;
	static Find(Outer: UObject, ResourceName: string): NetAnalyticsAggregatorConfig;
	static GetDefaultObject(): NetAnalyticsAggregatorConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetAnalyticsAggregatorConfig;
	static C(Other: UObject | any): NetAnalyticsAggregatorConfig;
}

declare class JsonUtilitiesDummyObject extends UObject { 
	static Load(ResourceName: string): JsonUtilitiesDummyObject;
	static Find(Outer: UObject, ResourceName: string): JsonUtilitiesDummyObject;
	static GetDefaultObject(): JsonUtilitiesDummyObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonUtilitiesDummyObject;
	static C(Other: UObject | any): JsonUtilitiesDummyObject;
}

declare class AssetRegistryImpl extends UObject { 
	static Load(ResourceName: string): AssetRegistryImpl;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryImpl;
	static GetDefaultObject(): AssetRegistryImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryImpl;
	static C(Other: UObject | any): AssetRegistryImpl;
}

declare class ARFilter { 
	PackageNames: string[];
	PackagePaths: string[];
	ObjectPaths: string[];
	ClassNames: string[];
	RecursiveClassesExclusionSet: any;
	bRecursivePaths: boolean;
	bRecursiveClasses: boolean;
	bIncludeOnlyOnDiskAssets: boolean;
	clone() : ARFilter;
	static C(Other: UObject | any): ARFilter;
}

declare class TagAndValue { 
	Tag: string;
	Value: string;
	clone() : TagAndValue;
	static C(Other: UObject | any): TagAndValue;
}

declare class AssetRegistryHelpers extends UObject { 
	static Load(ResourceName: string): AssetRegistryHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetRegistryHelpers;
	static GetDefaultObject(): AssetRegistryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistryHelpers;
	static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;
	static SetFilterTagsAndValues(InFilter: ARFilter,InTagsAndValues: TagAndValue[]): ARFilter;
	static IsValid(InAssetData: AssetData): boolean;
	static IsUAsset(InAssetData: AssetData): boolean;
	static IsRedirector(InAssetData: AssetData): boolean;
	static IsAssetLoaded(InAssetData: AssetData): boolean;
	static GetTagValue(InAssetData: AssetData,InTagName: string,OutTagValue?: string): {OutTagValue: string, $: boolean};
	static GetFullName(InAssetData: AssetData): string;
	static GetExportTextName(InAssetData: AssetData): string;
	static GetClass(InAssetData: AssetData): UnrealEngineClass;
	static GetAsset(InAssetData: AssetData): UObject;
	static CreateAssetData(InAsset: UObject,bAllowBlueprintClass: boolean): AssetData;
	static C(Other: UObject | any): AssetRegistryHelpers;
}

declare class AssetRegistryDependencyOptions { 
	bIncludeSoftPackageReferences: boolean;
	bIncludeHardPackageReferences: boolean;
	bIncludeSearchableNames: boolean;
	bIncludeSoftManagementReferences: boolean;
	bIncludeHardManagementReferences: boolean;
	clone() : AssetRegistryDependencyOptions;
	static C(Other: UObject | any): AssetRegistryDependencyOptions;
}

declare class AssetRegistry extends Interface { 
	static Load(ResourceName: string): AssetRegistry;
	static Find(Outer: UObject, ResourceName: string): AssetRegistry;
	static GetDefaultObject(): AssetRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetRegistry;
	WaitForPackage(PackageName: string): void;
	WaitForCompletion(): void;
	UseFilterToExcludeAssets(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	SearchAllAssets(bSynchronousSearch: boolean): void;
	ScanPathsSynchronous(InPaths: string[],bForceRescan: boolean,bIgnoreDenyListScanFilters: boolean): void;
	ScanModifiedAssetFiles(InFilePaths: string[]): void;
	ScanFilesSynchronous(InFilePaths: string[],bForceRescan: boolean): void;
	RunAssetsThroughFilter(AssetDataList?: AssetData[],Filter?: ARFilter): {AssetDataList: AssetData[]};
	PrioritizeSearchPath(PathToPrioritize: string): void;
	K2_GetReferencers(PackageName: string,ReferenceOptions: AssetRegistryDependencyOptions,OutReferencers?: string[]): {OutReferencers: string[], $: boolean};
	K2_GetDependencies(PackageName: string,DependencyOptions: AssetRegistryDependencyOptions,OutDependencies?: string[]): {OutDependencies: string[], $: boolean};
	IsSearchAsync(): boolean;
	IsSearchAllAssets(): boolean;
	IsLoadingAssets(): boolean;
	HasAssets(PackagePath: string,bRecursive: boolean): boolean;
	GetSubPaths(InBasePath: string,OutPathList?: string[],bInRecurse?: boolean): {OutPathList: string[]};
	GetAssetsByPaths(PackagePaths: string[],OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPath(PackagePath: string,OutAssetData?: AssetData[],bRecursive?: boolean,bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByPackageName(PackageName: string,OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssetsByClass(ClassName: string,OutAssetData?: AssetData[],bSearchSubClasses?: boolean): {OutAssetData: AssetData[], $: boolean};
	GetAssets(Filter: ARFilter,OutAssetData?: AssetData[]): {OutAssetData: AssetData[], $: boolean};
	GetAssetByObjectPath(ObjectPath: string,bIncludeOnlyOnDiskAssets: boolean): AssetData;
	GetAllCachedPaths(OutPathList?: string[]): {OutPathList: string[]};
	GetAllAssets(OutAssetData?: AssetData[],bIncludeOnlyOnDiskAssets?: boolean): {OutAssetData: AssetData[], $: boolean};
	static C(Other: UObject | any): AssetRegistry;
}

declare class AutoCompleteCommand { 
	Command: string;
	Desc: string;
	clone() : AutoCompleteCommand;
	static C(Other: UObject | any): AutoCompleteCommand;
}

declare class ConsoleSettings extends UObject { 
	MaxScrollbackSize: number;
	ManualAutoCompleteList: AutoCompleteCommand[];
	AutoCompleteMapPaths: string[];
	BackgroundOpacityPercentage: number;
	bOrderTopToBottom: boolean;
	bDisplayHelpInAutoComplete: boolean;
	InputColor: Color;
	HistoryColor: Color;
	AutoCompleteCommandColor: Color;
	AutoCompleteCVarColor: Color;
	AutoCompleteFadedColor: Color;
	static Load(ResourceName: string): ConsoleSettings;
	static Find(Outer: UObject, ResourceName: string): ConsoleSettings;
	static GetDefaultObject(): ConsoleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConsoleSettings;
	static C(Other: UObject | any): ConsoleSettings;
}

declare class TemplateMapInfoOverride { 
	Thumbnail: SoftObjectPath;
	Map: SoftObjectPath;
	DisplayName: string;
	clone() : TemplateMapInfoOverride;
	static C(Other: UObject | any): TemplateMapInfoOverride;
}

declare type ETwoPlayerSplitScreenType = 'Horizontal' | 'Vertical' | 'ETwoPlayerSplitScreenType_MAX';
declare var ETwoPlayerSplitScreenType : { Horizontal:'Horizontal',Vertical:'Vertical',ETwoPlayerSplitScreenType_MAX:'ETwoPlayerSplitScreenType_MAX', };
declare type EThreePlayerSplitScreenType = 'FavorTop' | 'FavorBottom' | 'Vertical' | 'Horizontal' | 'EThreePlayerSplitScreenType_MAX';
declare var EThreePlayerSplitScreenType : { FavorTop:'FavorTop',FavorBottom:'FavorBottom',Vertical:'Vertical',Horizontal:'Horizontal',EThreePlayerSplitScreenType_MAX:'EThreePlayerSplitScreenType_MAX', };
declare type EFourPlayerSplitScreenType = 'Grid' | 'Vertical' | 'Horizontal' | 'EFourPlayerSplitScreenType_MAX';
declare var EFourPlayerSplitScreenType : { Grid:'Grid',Vertical:'Vertical',Horizontal:'Horizontal',EFourPlayerSplitScreenType_MAX:'EFourPlayerSplitScreenType_MAX', };
declare class GameModeName { 
	Name: string;
	GameMode: SoftClassPath;
	clone() : GameModeName;
	static C(Other: UObject | any): GameModeName;
}

declare class GameMapsSettings extends UObject { 
	EditorStartupMap: SoftObjectPath;
	EditorTemplateMapOverrides: TemplateMapInfoOverride[];
	LocalMapOptions: string;
	TransitionMap: SoftObjectPath;
	bUseSplitscreen: boolean;
	TwoPlayerSplitscreenLayout: ETwoPlayerSplitScreenType;
	ThreePlayerSplitscreenLayout: EThreePlayerSplitScreenType;
	FourPlayerSplitscreenLayout: EFourPlayerSplitScreenType;
	bOffsetPlayerGamepadIds: boolean;
	GameInstanceClass: SoftClassPath;
	GameDefaultMap: SoftObjectPath;
	ServerDefaultMap: SoftObjectPath;
	GlobalDefaultGameMode: SoftClassPath;
	GlobalDefaultServerGameMode: SoftClassPath;
	GameModeMapPrefixes: GameModeName[];
	GameModeClassAliases: GameModeName[];
	static Load(ResourceName: string): GameMapsSettings;
	static Find(Outer: UObject, ResourceName: string): GameMapsSettings;
	static GetDefaultObject(): GameMapsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMapsSettings;
	SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer: boolean): void;
	GetSkipAssigningGamepadToPlayer1(): boolean;
	static GetGameMapsSettings(): GameMapsSettings;
	static C(Other: UObject | any): GameMapsSettings;
}

declare class GameNetworkManagerSettings extends UObject { 
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	TotalNetBandwidth: number;
	BadPingThreshold: number;
	bIsStandbyCheckingEnabled: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	static Load(ResourceName: string): GameNetworkManagerSettings;
	static Find(Outer: UObject, ResourceName: string): GameNetworkManagerSettings;
	static GetDefaultObject(): GameNetworkManagerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManagerSettings;
	static C(Other: UObject | any): GameNetworkManagerSettings;
}

declare class GameSessionSettings extends UObject { 
	MaxSpectators: number;
	MaxPlayers: number;
	bRequiresPushToTalk: boolean;
	static Load(ResourceName: string): GameSessionSettings;
	static Find(Outer: UObject, ResourceName: string): GameSessionSettings;
	static GetDefaultObject(): GameSessionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSessionSettings;
	static C(Other: UObject | any): GameSessionSettings;
}

declare class GeneralEngineSettings extends UObject { 
	static Load(ResourceName: string): GeneralEngineSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralEngineSettings;
	static GetDefaultObject(): GeneralEngineSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralEngineSettings;
	static C(Other: UObject | any): GeneralEngineSettings;
}

declare class GeneralProjectSettings extends UObject { 
	CompanyName: string;
	CompanyDistinguishedName: string;
	CopyrightNotice: string;
	Description: string;
	Homepage: string;
	LicensingTerms: string;
	PrivacyPolicy: string;
	ProjectID: Guid;
	ProjectName: string;
	ProjectVersion: string;
	SupportContact: string;
	ProjectDisplayedTitle: string;
	ProjectDebugTitleInfo: string;
	bShouldWindowPreserveAspectRatio: boolean;
	bUseBorderlessWindow: boolean;
	bStartInVR: boolean;
	bAllowWindowResize: boolean;
	bAllowClose: boolean;
	bAllowMaximize: boolean;
	bAllowMinimize: boolean;
	static Load(ResourceName: string): GeneralProjectSettings;
	static Find(Outer: UObject, ResourceName: string): GeneralProjectSettings;
	static GetDefaultObject(): GeneralProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeneralProjectSettings;
	static C(Other: UObject | any): GeneralProjectSettings;
}

declare class HudSettings extends UObject { 
	bShowHUD: boolean;
	DebugDisplay: string[];
	static Load(ResourceName: string): HudSettings;
	static Find(Outer: UObject, ResourceName: string): HudSettings;
	static GetDefaultObject(): HudSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HudSettings;
	static C(Other: UObject | any): HudSettings;
}

declare class HandlerComponentFactory extends UObject { 
	static Load(ResourceName: string): HandlerComponentFactory;
	static Find(Outer: UObject, ResourceName: string): HandlerComponentFactory;
	static GetDefaultObject(): HandlerComponentFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HandlerComponentFactory;
	static C(Other: UObject | any): HandlerComponentFactory;
}

declare class PacketHandlerProfileConfig extends UObject { 
	Components: string[];
	static Load(ResourceName: string): PacketHandlerProfileConfig;
	static Find(Outer: UObject, ResourceName: string): PacketHandlerProfileConfig;
	static GetDefaultObject(): PacketHandlerProfileConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PacketHandlerProfileConfig;
	static C(Other: UObject | any): PacketHandlerProfileConfig;
}

declare class ChaosPhysicalMaterial extends UObject { 
	Friction: number;
	StaticFriction: number;
	Restitution: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	SleepingLinearVelocityThreshold: number;
	SleepingAngularVelocityThreshold: number;
	static Load(ResourceName: string): ChaosPhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): ChaosPhysicalMaterial;
	static GetDefaultObject(): ChaosPhysicalMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosPhysicalMaterial;
	static C(Other: UObject | any): ChaosPhysicalMaterial;
}

declare type EClusterUnionMethod = 'PointImplicit' | 'DelaunayTriangulation' | 'MinimalSpanningSubsetDelaunayTriangulation' | 'PointImplicitAugmentedWithMinimalDelaunay' | 'None' | 'EClusterUnionMethod_MAX';
declare var EClusterUnionMethod : { PointImplicit:'PointImplicit',DelaunayTriangulation:'DelaunayTriangulation',MinimalSpanningSubsetDelaunayTriangulation:'MinimalSpanningSubsetDelaunayTriangulation',PointImplicitAugmentedWithMinimalDelaunay:'PointImplicitAugmentedWithMinimalDelaunay',None:'None',EClusterUnionMethod_MAX:'EClusterUnionMethod_MAX', };
declare class SolverCollisionFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	clone() : SolverCollisionFilterSettings;
	static C(Other: UObject | any): SolverCollisionFilterSettings;
}

declare class SolverBreakingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverBreakingFilterSettings;
	static C(Other: UObject | any): SolverBreakingFilterSettings;
}

declare class SolverTrailingFilterSettings { 
	FilterEnabled: boolean;
	MinMass: number;
	MinSpeed: number;
	MinVolume: number;
	clone() : SolverTrailingFilterSettings;
	static C(Other: UObject | any): SolverTrailingFilterSettings;
}

declare class ChaosSolverConfiguration { 
	Iterations: number;
	CollisionPairIterations: number;
	PushOutIterations: number;
	CollisionPushOutPairIterations: number;
	CollisionMarginFraction: number;
	CollisionMarginMax: number;
	CollisionCullDistance: number;
	CollisionMaxPushOutVelocity: number;
	JointPairIterations: number;
	JointPushOutPairIterations: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterUnionMethod;
	bGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	bGenerateBreakData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	bGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	bGenerateContactGraph: boolean;
	clone() : ChaosSolverConfiguration;
	static C(Other: UObject | any): ChaosSolverConfiguration;
}

declare class PhysicsSettingsCore extends DeveloperSettings { 
	DefaultGravityZ: number;
	DefaultTerminalVelocity: number;
	DefaultFluidFriction: number;
	SimulateScratchMemorySize: number;
	RagdollAggregateThreshold: number;
	TriangleMeshTriangleMinAreaThreshold: number;
	bEnableShapeSharing: boolean;
	bEnablePCM: boolean;
	bEnableStabilization: boolean;
	bWarnMissingLocks: boolean;
	bEnable2DPhysics: boolean;
	bDefaultHasComplexCollision: boolean;
	BounceThresholdVelocity: number;
	FrictionCombineMode: EFrictionCombineMode;
	RestitutionCombineMode: EFrictionCombineMode;
	MaxAngularVelocity: number;
	MaxDepenetrationVelocity: number;
	ContactOffsetMultiplier: number;
	MinContactOffset: number;
	MaxContactOffset: number;
	bSimulateSkeletalMeshOnDedicatedServer: boolean;
	DefaultShapeComplexity: ECollisionTraceFlag;
	SolverOptions: ChaosSolverConfiguration;
	static Load(ResourceName: string): PhysicsSettingsCore;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettingsCore;
	static GetDefaultObject(): PhysicsSettingsCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettingsCore;
	static C(Other: UObject | any): PhysicsSettingsCore;
}

declare class AudioParameterControllerInterface extends Interface { 
	static Load(ResourceName: string): AudioParameterControllerInterface;
	static Find(Outer: UObject, ResourceName: string): AudioParameterControllerInterface;
	static GetDefaultObject(): AudioParameterControllerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioParameterControllerInterface;
	SetTriggerParameter(InName: string): void;
	SetStringParameter(InName: string,InValue: string): void;
	SetStringArrayParameter(InName: string,InValue: string[]): void;
	SetParameters_Blueprint(InParameters: AudioParameter[]): void;
	SetObjectParameter(InName: string,InValue: UObject): void;
	SetObjectArrayParameter(InName: string,InValue: UObject[]): void;
	SetIntParameter(InName: string,inInt: number): void;
	SetIntArrayParameter(InName: string,InValue: number[]): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetFloatArrayParameter(InName: string,InValue: number[]): void;
	SetBoolParameter(InName: string,InBool: boolean): void;
	SetBoolArrayParameter(InName: string,InValue: boolean[]): void;
	ResetParameters(): void;
	static C(Other: UObject | any): AudioParameterControllerInterface;
}

declare class AudioCodecEncoderSettings extends UObject { 
	Version: number;
	static Load(ResourceName: string): AudioCodecEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioCodecEncoderSettings;
	static GetDefaultObject(): AudioCodecEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioCodecEncoderSettings;
	static C(Other: UObject | any): AudioCodecEncoderSettings;
}

declare class AudioEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): AudioEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): AudioEndpointSettingsBase;
	static GetDefaultObject(): AudioEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEndpointSettingsBase;
	static C(Other: UObject | any): AudioEndpointSettingsBase;
}

declare class DummyEndpointSettings extends AudioEndpointSettingsBase { 
	static Load(ResourceName: string): DummyEndpointSettings;
	static Find(Outer: UObject, ResourceName: string): DummyEndpointSettings;
	static GetDefaultObject(): DummyEndpointSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DummyEndpointSettings;
	static C(Other: UObject | any): DummyEndpointSettings;
}

declare class SoundfieldEndpointSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEndpointSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSettingsBase;
	static GetDefaultObject(): SoundfieldEndpointSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSettingsBase;
	static C(Other: UObject | any): SoundfieldEndpointSettingsBase;
}

declare class SoundfieldEffectSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEffectSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectSettingsBase;
	static GetDefaultObject(): SoundfieldEffectSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectSettingsBase;
	static C(Other: UObject | any): SoundfieldEffectSettingsBase;
}

declare class SoundfieldEffectBase extends UObject { 
	Settings: SoundfieldEffectSettingsBase;
	static Load(ResourceName: string): SoundfieldEffectBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEffectBase;
	static GetDefaultObject(): SoundfieldEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEffectBase;
	static C(Other: UObject | any): SoundfieldEffectBase;
}

declare type EPcmBitDepthConversion = 'SameAsSource' | 'Int16' | 'Float32' | 'EPcmBitDepthConversion_MAX';
declare var EPcmBitDepthConversion : { SameAsSource:'SameAsSource',Int16:'Int16',Float32:'Float32',EPcmBitDepthConversion_MAX:'EPcmBitDepthConversion_MAX', };
declare class AudioPcmEncoderSettings extends AudioCodecEncoderSettings { 
	BitDepthConversion: EPcmBitDepthConversion;
	static Load(ResourceName: string): AudioPcmEncoderSettings;
	static Find(Outer: UObject, ResourceName: string): AudioPcmEncoderSettings;
	static GetDefaultObject(): AudioPcmEncoderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioPcmEncoderSettings;
	static C(Other: UObject | any): AudioPcmEncoderSettings;
}

declare class ClothConfigBase extends UObject { 
	static Load(ResourceName: string): ClothConfigBase;
	static Find(Outer: UObject, ResourceName: string): ClothConfigBase;
	static GetDefaultObject(): ClothConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigBase;
	static C(Other: UObject | any): ClothConfigBase;
}

declare class ClothSharedSimConfigBase extends UObject { 
	static Load(ResourceName: string): ClothSharedSimConfigBase;
	static Find(Outer: UObject, ResourceName: string): ClothSharedSimConfigBase;
	static GetDefaultObject(): ClothSharedSimConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothSharedSimConfigBase;
	static C(Other: UObject | any): ClothSharedSimConfigBase;
}

declare class ClothVertBoneData { 
	NumInfluences: number;
	BoneIndices: any;
	BoneWeights: number;
	clone() : ClothVertBoneData;
	static C(Other: UObject | any): ClothVertBoneData;
}

declare class ClothPhysicalMeshDataBase_Legacy extends UObject { 
	Vertices: Vector3f[];
	Normals: Vector3f[];
	VertexColors: Color[];
	Indices: any[];
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	NumFixedVerts: number;
	MaxBoneWeights: number;
	SelfCollisionIndices: any[];
	static Load(ResourceName: string): ClothPhysicalMeshDataBase_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothPhysicalMeshDataBase_Legacy;
	static GetDefaultObject(): ClothPhysicalMeshDataBase_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothPhysicalMeshDataBase_Legacy;
	static C(Other: UObject | any): ClothPhysicalMeshDataBase_Legacy;
}

declare type EMultiBoxType = 'MenuBar' | 'ToolBar' | 'VerticalToolBar' | 'SlimHorizontalToolBar' | 'UniformToolBar' | 'Menu' | 'ButtonRow' | 'EMultiBoxType_MAX';
declare var EMultiBoxType : { MenuBar:'MenuBar',ToolBar:'ToolBar',VerticalToolBar:'VerticalToolBar',SlimHorizontalToolBar:'SlimHorizontalToolBar',UniformToolBar:'UniformToolBar',Menu:'Menu',ButtonRow:'ButtonRow',EMultiBoxType_MAX:'EMultiBoxType_MAX', };
declare class ToolMenuOwner { 
	clone() : ToolMenuOwner;
	static C(Other: UObject | any): ToolMenuOwner;
}

declare class ToolMenuContext { 
	ContextObjects: UObject[];
	clone() : ToolMenuContext;
	static C(Other: UObject | any): ToolMenuContext;
}

declare type EMultiBlockType = 'None' | 'ButtonRow' | 'EditableText' | 'Heading' | 'MenuEntry' | 'Separator' | 'ToolBarButton' | 'ToolBarComboButton' | 'Widget' | 'EMultiBlockType_MAX';
declare var EMultiBlockType : { None:'None',ButtonRow:'ButtonRow',EditableText:'EditableText',Heading:'Heading',MenuEntry:'MenuEntry',Separator:'Separator',ToolBarButton:'ToolBarButton',ToolBarComboButton:'ToolBarComboButton',Widget:'Widget',EMultiBlockType_MAX:'EMultiBlockType_MAX', };
declare type EUserInterfaceActionType = 'None' | 'Button' | 'ToggleButton' | 'RadioButton' | 'Check' | 'CollapsedButton' | 'EUserInterfaceActionType_MAX';
declare var EUserInterfaceActionType : { None:'None',Button:'Button',ToggleButton:'ToggleButton',RadioButton:'RadioButton',Check:'Check',CollapsedButton:'CollapsedButton',EUserInterfaceActionType_MAX:'EUserInterfaceActionType_MAX', };
declare type EToolMenuInsertType = 'Default' | 'Before' | 'After' | 'First' | 'EToolMenuInsertType_MAX';
declare var EToolMenuInsertType : { Default:'Default',Before:'Before',After:'After',First:'First',EToolMenuInsertType_MAX:'EToolMenuInsertType_MAX', };
declare class ToolMenuInsert { 
	Name: string;
	position: EToolMenuInsertType;
	clone() : ToolMenuInsert;
	static C(Other: UObject | any): ToolMenuInsert;
}

declare class ScriptSlateIcon { 
	StyleSetName: string;
	StyleName: string;
	SmallStyleName: string;
	clone() : ScriptSlateIcon;
	static C(Other: UObject | any): ScriptSlateIcon;
}

declare class ToolMenuEntryScriptDataAdvanced { 
	TutorialHighlight: string;
	EntryType: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	StyleNameOverride: string;
	bIsSubMenu: boolean;
	bOpenSubMenuOnClick: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bSimpleComboBox: boolean;
	clone() : ToolMenuEntryScriptDataAdvanced;
	static C(Other: UObject | any): ToolMenuEntryScriptDataAdvanced;
}

declare class ToolMenuEntryScriptData { 
	Menu: string;
	Section: string;
	Name: string;
	Label: string;
	Tooltip: string;
	Icon: ScriptSlateIcon;
	OwnerName: string;
	InsertPosition: ToolMenuInsert;
	Advanced: ToolMenuEntryScriptDataAdvanced;
	clone() : ToolMenuEntryScriptData;
	static C(Other: UObject | any): ToolMenuEntryScriptData;
}

declare type ECheckBoxState = 'Unchecked' | 'Checked' | 'Undetermined' | 'ECheckBoxState_MAX';
declare var ECheckBoxState : { Unchecked:'Unchecked',Checked:'Checked',Undetermined:'Undetermined',ECheckBoxState_MAX:'ECheckBoxState_MAX', };
declare class ToolMenuEntryScript extends UObject { 
	Data: ToolMenuEntryScriptData;
	static Load(ResourceName: string): ToolMenuEntryScript;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryScript;
	static GetDefaultObject(): ToolMenuEntryScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryScript;
	RegisterMenuEntry(): void;
	IsVisible(Context: ToolMenuContext): boolean;
	InitEntry(OwnerName: string,Menu: string,Section: string,Name: string,Label: string,Tooltip: string): void;
	GetToolTip(Context: ToolMenuContext): string;
	GetLabel(Context: ToolMenuContext): string;
	GetIcon(Context: ToolMenuContext): ScriptSlateIcon;
	GetCheckState(Context: ToolMenuContext): ECheckBoxState;
	Execute(Context: ToolMenuContext): void;
	ConstructMenuEntry(Menu: ToolMenu,SectionName: string,Context: ToolMenuContext): void;
	CanExecute(Context: ToolMenuContext): boolean;
	static C(Other: UObject | any): ToolMenuEntryScript;
}

declare class ToolMenuEntry { 
	Name: string;
	Owner: ToolMenuOwner;
	Type: EMultiBlockType;
	UserInterfaceActionType: EUserInterfaceActionType;
	TutorialHighlightName: string;
	InsertPosition: ToolMenuInsert;
	bShouldCloseWindowAfterMenuSelection: boolean;
	ScriptObject: ToolMenuEntryScript;
	StyleNameOverride: string;
	bCommandIsKeybindOnly: boolean;
	clone() : ToolMenuEntry;
	static C(Other: UObject | any): ToolMenuEntry;
}

declare class ToolMenuSectionDynamic extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionDynamic;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionDynamic;
	static GetDefaultObject(): ToolMenuSectionDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionDynamic;
	ConstructSections(Menu: ToolMenu,Context: ToolMenuContext): void;
	static C(Other: UObject | any): ToolMenuSectionDynamic;
}

declare class ToolMenuSection { 
	Name: string;
	Owner: ToolMenuOwner;
	Blocks: ToolMenuEntry[];
	InsertPosition: ToolMenuInsert;
	Context: ToolMenuContext;
	ToolMenuSectionDynamic: ToolMenuSectionDynamic;
	clone() : ToolMenuSection;
	static C(Other: UObject | any): ToolMenuSection;
}

declare class ToolMenu extends ToolMenuBase { 
	MenuName: string;
	MenuParent: string;
	StyleName: string;
	TutorialHighlightName: string;
	MenuType: EMultiBoxType;
	bShouldCleanupContextOnDestroy: boolean;
	bShouldCloseWindowAfterMenuSelection: boolean;
	bCloseSelfOnly: boolean;
	bSearchable: boolean;
	bToolBarIsFocusable: boolean;
	bToolBarForceSmallIcons: boolean;
	bPreventCustomization: boolean;
	MenuOwner: ToolMenuOwner;
	Context: ToolMenuContext;
	Sections: ToolMenuSection[];
	SubMenuParent: ToolMenu;
	SubMenuSourceEntryName: string;
	static Load(ResourceName: string): ToolMenu;
	static Find(Outer: UObject, ResourceName: string): ToolMenu;
	static GetDefaultObject(): ToolMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenu;
	InitMenu(Owner: ToolMenuOwner,Name: string,Parent: string,Type: EMultiBoxType): void;
	AddSubMenuScript(Owner: string,SectionName: string,Name: string,Label: string,Tooltip: string): ToolMenu;
	AddSectionScript(SectionName: string,Label: string,InsertName: string,InsertType: EToolMenuInsertType): void;
	AddMenuEntryObject(InObject: ToolMenuEntryScript): void;
	AddMenuEntry(SectionName: string,Args: ToolMenuEntry): void;
	AddDynamicSectionScript(SectionName: string,UObject: ToolMenuSectionDynamic): void;
	static C(Other: UObject | any): ToolMenu;
}

declare class ToolMenuContextBase extends UObject { 
	static Load(ResourceName: string): ToolMenuContextBase;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextBase;
	static GetDefaultObject(): ToolMenuContextBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextBase;
	static C(Other: UObject | any): ToolMenuContextBase;
}

declare class SlateTabManagerContext extends ToolMenuContextBase { 
	static Load(ResourceName: string): SlateTabManagerContext;
	static Find(Outer: UObject, ResourceName: string): SlateTabManagerContext;
	static GetDefaultObject(): SlateTabManagerContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTabManagerContext;
	static C(Other: UObject | any): SlateTabManagerContext;
}

declare class CustomizedToolMenu { 
	Name: string;
	Entries: any;
	Sections: any;
	EntryOrder: any;
	SectionOrder: string[];
	clone() : CustomizedToolMenu;
	static C(Other: UObject | any): CustomizedToolMenu;
}

declare class ToolMenus extends UObject { 
	CustomizedMenus: CustomizedToolMenu[];
	MenuSubstitutionsDuringGenerate: any;
	Menus: any;
	static Load(ResourceName: string): ToolMenus;
	static Find(Outer: UObject, ResourceName: string): ToolMenus;
	static GetDefaultObject(): ToolMenus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenus;
	UnregisterOwnerByName(InOwnerName: string): void;
	SetSectionPosition(MenuName: string,SectionName: string,OtherSectionName: string,PositionType: EToolMenuInsertType): void;
	SetSectionLabel(MenuName: string,SectionName: string,Label: string): void;
	RemoveSection(MenuName: string,Section: string): void;
	RemoveMenu(MenuName: string): void;
	RemoveEntry(MenuName: string,Section: string,Name: string): void;
	RegisterMenu(Name: string,Parent: string,Type: EMultiBoxType,bWarnIfAlreadyRegistered: boolean): ToolMenu;
	RefreshMenuWidget(Name: string): boolean;
	RefreshAllWidgets(): void;
	IsMenuRegistered(Name: string): boolean;
	static Get(): ToolMenus;
	FindMenu(Name: string): ToolMenu;
	static FindContext(InContext: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	ExtendMenu(Name: string): ToolMenu;
	static AddMenuEntryObject(MenuEntryObject: ToolMenuEntryScript): boolean;
	static C(Other: UObject | any): ToolMenus;
}

declare class ToolMenuContextExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuContextExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuContextExtensions;
	static GetDefaultObject(): ToolMenuContextExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuContextExtensions;
	static FindByClass(Context: ToolMenuContext,InClass: UnrealEngineClass): UObject;
	static C(Other: UObject | any): ToolMenuContextExtensions;
}

declare type EToolMenuStringCommandType = 'Command' | 'Python' | 'Custom' | 'EToolMenuStringCommandType_MAX';
declare var EToolMenuStringCommandType : { Command:'Command',Python:'Python',Custom:'Custom',EToolMenuStringCommandType_MAX:'EToolMenuStringCommandType_MAX', };
declare class ToolMenuStringCommand { 
	Type: EToolMenuStringCommandType;
	CustomType: string;
	string: string;
	clone() : ToolMenuStringCommand;
	static C(Other: UObject | any): ToolMenuStringCommand;
}

declare class ToolMenuEntryExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuEntryExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuEntryExtensions;
	static GetDefaultObject(): ToolMenuEntryExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuEntryExtensions;
	static SetToolTip(Target?: ToolMenuEntry,Tooltip?: string): {Target: ToolMenuEntry};
	static SetStringCommand(Target?: ToolMenuEntry,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Target: ToolMenuEntry};
	static SetLabel(Target?: ToolMenuEntry,Label?: string): {Target: ToolMenuEntry};
	static SetIcon(Target?: ToolMenuEntry,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {Target: ToolMenuEntry};
	static MakeToolMenuOwner(Name: string): ToolMenuOwner;
	static MakeStringCommand(Type: EToolMenuStringCommandType,CustomType: string,string: string): ToolMenuStringCommand;
	static MakeScriptSlateIcon(StyleSetName: string,StyleName: string,SmallStyleName: string): ScriptSlateIcon;
	static InitMenuEntry(InOwner: string,InName: string,InLabel: string,InToolTip: string,CommandType: EToolMenuStringCommandType,CustomCommandType: string,CommandString: string): ToolMenuEntry;
	static GetToolTip(Target: ToolMenuEntry): string;
	static GetLabel(Target: ToolMenuEntry): string;
	static BreakToolMenuOwner(InValue: ToolMenuOwner,Name?: string): {Name: string};
	static BreakStringCommand(InValue: ToolMenuStringCommand,Type?: EToolMenuStringCommandType,CustomType?: string,string?: string): {Type: EToolMenuStringCommandType, CustomType: string, string: string};
	static BreakScriptSlateIcon(InValue: ScriptSlateIcon,StyleSetName?: string,StyleName?: string,SmallStyleName?: string): {StyleSetName: string, StyleName: string, SmallStyleName: string};
	static C(Other: UObject | any): ToolMenuEntryExtensions;
}

declare class ToolMenuSectionExtensions extends UObject { 
	static Load(ResourceName: string): ToolMenuSectionExtensions;
	static Find(Outer: UObject, ResourceName: string): ToolMenuSectionExtensions;
	static GetDefaultObject(): ToolMenuSectionExtensions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolMenuSectionExtensions;
	static SetLabel(Section?: ToolMenuSection,Label?: string): {Section: ToolMenuSection};
	static GetLabel(Section: ToolMenuSection): string;
	static AddEntryObject(Section?: ToolMenuSection,InObject?: ToolMenuEntryScript): {Section: ToolMenuSection};
	static AddEntry(Section?: ToolMenuSection,Args?: ToolMenuEntry): {Section: ToolMenuSection};
	static C(Other: UObject | any): ToolMenuSectionExtensions;
}

declare class PropertyConfigFileDisplayRow extends UObject { 
	ConfigFileName: string;
	ExternalProperty: any;
	bIsFileWritable: boolean;
	static Load(ResourceName: string): PropertyConfigFileDisplayRow;
	static Find(Outer: UObject, ResourceName: string): PropertyConfigFileDisplayRow;
	static GetDefaultObject(): PropertyConfigFileDisplayRow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyConfigFileDisplayRow;
	static C(Other: UObject | any): PropertyConfigFileDisplayRow;
}

declare class ConfigHierarchyPropertyView extends UObject { 
	EditProperty: any;
	ConfigFilePropertyObjects: PropertyConfigFileDisplayRow[];
	static Load(ResourceName: string): ConfigHierarchyPropertyView;
	static Find(Outer: UObject, ResourceName: string): ConfigHierarchyPropertyView;
	static GetDefaultObject(): ConfigHierarchyPropertyView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConfigHierarchyPropertyView;
	static C(Other: UObject | any): ConfigHierarchyPropertyView;
}

declare type EInterchangeNodeContainerType = 'NodeContainerType_None' | 'NodeContainerType_TranslatedScene' | 'NodeContainerType_TranslatedAsset' | 'NodeContainerType_FactoryData' | 'NodeContainerType_MAX';
declare var EInterchangeNodeContainerType : { NodeContainerType_None:'NodeContainerType_None',NodeContainerType_TranslatedScene:'NodeContainerType_TranslatedScene',NodeContainerType_TranslatedAsset:'NodeContainerType_TranslatedAsset',NodeContainerType_FactoryData:'NodeContainerType_FactoryData',NodeContainerType_MAX:'NodeContainerType_MAX', };
declare class InterchangeBaseNode extends UObject { 
	ReferenceObject: SoftObjectPath;
	static Load(ResourceName: string): InterchangeBaseNode;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNode;
	static GetDefaultObject(): InterchangeBaseNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNode;
	SetParentUid(ParentUid: string): boolean;
	SetEnabled(bIsEnabled: boolean): boolean;
	SetDisplayLabel(DisplayName: string): boolean;
	SetAssetName(AssetName: string): boolean;
	RemoveTargetNodeUid(AssetUid: string): boolean;
	RemoveFactoryDependencyUid(DependencyUid: string): boolean;
	RemoveAttribute(NodeAttributeKey: string): boolean;
	IsEnabled(): boolean;
	InitializeNode(UniqueId: string,DisplayLabel: string,NodeContainerType: EInterchangeNodeContainerType): void;
	GetUniqueID(): string;
	GetTargetNodeUids(OutTargetAssets?: string[]): {OutTargetAssets: string[]};
	GetTargetNodeCount(): number;
	GetStringAttribute(NodeAttributeKey: string,OutValue?: string): {OutValue: string, $: boolean};
	GetParentUid(): string;
	GetNodeContainerType(): EInterchangeNodeContainerType;
	GetInt32Attribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetFloatAttribute(NodeAttributeKey: string,OutValue?: number): {OutValue: number, $: boolean};
	GetFactoryDependency(index: number,OutDependency?: string): {OutDependency: string};
	GetFactoryDependenciesCount(): number;
	GetFactoryDependencies(OutDependencies?: string[]): {OutDependencies: string[]};
	GetDisplayLabel(): string;
	GetBooleanAttribute(NodeAttributeKey: string,OutValue?: boolean): {OutValue: boolean, $: boolean};
	GetAssetName(): string;
	AddTargetNodeUid(AssetUid: string): boolean;
	AddStringAttribute(NodeAttributeKey: string,Value: string): boolean;
	AddInt32Attribute(NodeAttributeKey: string,Value: number): boolean;
	AddFloatAttribute(NodeAttributeKey: string,Value: number): boolean;
	AddFactoryDependencyUid(DependencyUid: string): boolean;
	AddBooleanAttribute(NodeAttributeKey: string,Value: boolean): boolean;
	static C(Other: UObject | any): InterchangeBaseNode;
}

declare class InterchangeBaseNodeContainer extends UObject { 
	Nodes: any;
	static Load(ResourceName: string): InterchangeBaseNodeContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeBaseNodeContainer;
	static GetDefaultObject(): InterchangeBaseNodeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeBaseNodeContainer;
	SetNodeParentUid(NodeUniqueID: string,NewParentNodeUid: string): boolean;
	SaveToFile(Filename: string): void;
	LoadFromFile(Filename: string): void;
	IsNodeUidValid(NodeUniqueID: string): boolean;
	GetRoots(RootNodes?: string[]): {RootNodes: string[]};
	GetNodes(ClassNode: UnrealEngineClass,OutNodes?: string[]): {OutNodes: string[]};
	GetNodeChildrenUids(NodeUniqueID: string): string[];
	GetNodeChildrenCount(NodeUniqueID: string): number;
	GetNodeChildren(NodeUniqueID: string,ChildIndex: number): InterchangeBaseNode;
	GetNode(NodeUniqueID: string): InterchangeBaseNode;
	AddNode(UNode: InterchangeBaseNode): string;
	static C(Other: UObject | any): InterchangeBaseNodeContainer;
}

declare class InterchangeResult extends UObject { 
	SourceAssetName: string;
	DestinationAssetName: string;
	AssetType: UnrealEngineClass;
	InterchangeKey: string;
	static Load(ResourceName: string): InterchangeResult;
	static Find(Outer: UObject, ResourceName: string): InterchangeResult;
	static GetDefaultObject(): InterchangeResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResult;
	static C(Other: UObject | any): InterchangeResult;
}

declare class InterchangeResultsContainer extends UObject { 
	Results: InterchangeResult[];
	static Load(ResourceName: string): InterchangeResultsContainer;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultsContainer;
	static GetDefaultObject(): InterchangeResultsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultsContainer;
	static C(Other: UObject | any): InterchangeResultsContainer;
}

declare class InterchangeFactoryBase extends UObject { 
	Results: InterchangeResultsContainer;
	static Load(ResourceName: string): InterchangeFactoryBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeFactoryBase;
	static GetDefaultObject(): InterchangeFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeFactoryBase;
	GetFactoryClass(): UnrealEngineClass;
	static C(Other: UObject | any): InterchangeFactoryBase;
}

declare class InterchangeSourceData extends UObject { 
	Filename: string;
	static Load(ResourceName: string): InterchangeSourceData;
	static Find(Outer: UObject, ResourceName: string): InterchangeSourceData;
	static GetDefaultObject(): InterchangeSourceData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeSourceData;
	SetFilename(InFilename: string): boolean;
	GetFilename(): string;
	static C(Other: UObject | any): InterchangeSourceData;
}

declare type EInterchangePipelineTask = 'PreFactoryImport' | 'PostFactoryImport' | 'Export' | 'EInterchangePipelineTask_MAX';
declare var EInterchangePipelineTask : { PreFactoryImport:'PreFactoryImport',PostFactoryImport:'PostFactoryImport',Export:'Export',EInterchangePipelineTask_MAX:'EInterchangePipelineTask_MAX', };
declare class InterchangePipelineBase extends UObject { 
	Results: InterchangeResultsContainer;
	static Load(ResourceName: string): InterchangePipelineBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineBase;
	static GetDefaultObject(): InterchangePipelineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineBase;
	ScriptedExecutePreImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,SourceDatas: InterchangeSourceData[]): boolean;
	ScriptedExecutePostImportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer,NodeKey: string,CreatedAsset: UObject,bIsAReimport: boolean): boolean;
	ScriptedExecuteExportPipeline(BaseNodeContainer: InterchangeBaseNodeContainer): boolean;
	ScriptedCanExecuteOnAnyThread(PipelineTask: EInterchangePipelineTask): boolean;
	static C(Other: UObject | any): InterchangePipelineBase;
}

declare class InterchangeResultSuccess extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultSuccess;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultSuccess;
	static GetDefaultObject(): InterchangeResultSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultSuccess;
	static C(Other: UObject | any): InterchangeResultSuccess;
}

declare class InterchangeResultWarning extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultWarning;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning;
	static GetDefaultObject(): InterchangeResultWarning;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning;
	static C(Other: UObject | any): InterchangeResultWarning;
}

declare class InterchangeResultError extends InterchangeResult { 
	static Load(ResourceName: string): InterchangeResultError;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError;
	static GetDefaultObject(): InterchangeResultError;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError;
	static C(Other: UObject | any): InterchangeResultError;
}

declare class InterchangeResultWarning_Generic extends InterchangeResultWarning { 
	text: string;
	static Load(ResourceName: string): InterchangeResultWarning_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultWarning_Generic;
	static GetDefaultObject(): InterchangeResultWarning_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultWarning_Generic;
	static C(Other: UObject | any): InterchangeResultWarning_Generic;
}

declare class InterchangeResultError_Generic extends InterchangeResultError { 
	text: string;
	static Load(ResourceName: string): InterchangeResultError_Generic;
	static Find(Outer: UObject, ResourceName: string): InterchangeResultError_Generic;
	static GetDefaultObject(): InterchangeResultError_Generic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeResultError_Generic;
	static C(Other: UObject | any): InterchangeResultError_Generic;
}

declare class InterchangeTranslatorBase extends UObject { 
	Results: InterchangeResultsContainer;
	SourceData: InterchangeSourceData;
	static Load(ResourceName: string): InterchangeTranslatorBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeTranslatorBase;
	static GetDefaultObject(): InterchangeTranslatorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeTranslatorBase;
	static C(Other: UObject | any): InterchangeTranslatorBase;
}

declare class InterchangeWriterBase extends UObject { 
	static Load(ResourceName: string): InterchangeWriterBase;
	static Find(Outer: UObject, ResourceName: string): InterchangeWriterBase;
	static GetDefaultObject(): InterchangeWriterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeWriterBase;
	static C(Other: UObject | any): InterchangeWriterBase;
}

declare class LiveLinkRole extends UObject { 
	static Load(ResourceName: string): LiveLinkRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkRole;
	static GetDefaultObject(): LiveLinkRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkRole;
	static C(Other: UObject | any): LiveLinkRole;
}

declare class LiveLinkBasicRole extends LiveLinkRole { 
	static Load(ResourceName: string): LiveLinkBasicRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkBasicRole;
	static GetDefaultObject(): LiveLinkBasicRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkBasicRole;
	static C(Other: UObject | any): LiveLinkBasicRole;
}

declare class LiveLinkAnimationRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkAnimationRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkAnimationRole;
	static GetDefaultObject(): LiveLinkAnimationRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkAnimationRole;
	static C(Other: UObject | any): LiveLinkAnimationRole;
}

declare class LiveLinkTransformRole extends LiveLinkBasicRole { 
	static Load(ResourceName: string): LiveLinkTransformRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkTransformRole;
	static GetDefaultObject(): LiveLinkTransformRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkTransformRole;
	static C(Other: UObject | any): LiveLinkTransformRole;
}

declare class LiveLinkCameraRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkCameraRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCameraRole;
	static GetDefaultObject(): LiveLinkCameraRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCameraRole;
	static C(Other: UObject | any): LiveLinkCameraRole;
}

declare class LiveLinkController extends UObject { 
	static Load(ResourceName: string): LiveLinkController;
	static Find(Outer: UObject, ResourceName: string): LiveLinkController;
	static GetDefaultObject(): LiveLinkController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkController;
	static C(Other: UObject | any): LiveLinkController;
}

declare type ELiveLinkSourceMode = 'Latest' | 'EngineTime' | 'Timecode' | 'ELiveLinkSourceMode_MAX';
declare var ELiveLinkSourceMode : { Latest:'Latest',EngineTime:'EngineTime',Timecode:'Timecode',ELiveLinkSourceMode_MAX:'ELiveLinkSourceMode_MAX', };
declare class LiveLinkSourceBufferManagementSettings { 
	bValidEngineTimeEnabled: boolean;
	ValidEngineTime: number;
	EngineTimeOffset: number;
	EngineTimeClockOffset: any;
	SmoothEngineTimeOffset: any;
	TimecodeFrameRate: FrameRate;
	bGenerateSubFrame: boolean;
	DetectedFrameRate: FrameRate;
	bUseTimecodeSmoothLatest: boolean;
	SourceTimecodeFrameRate: FrameRate;
	bValidTimecodeFrameEnabled: boolean;
	ValidTimecodeFrame: number;
	TimecodeFrameOffset: number;
	TimecodeClockOffset: any;
	LatestOffset: number;
	MaxNumberOfFrameToBuffered: number;
	bKeepAtLeastOneFrame: boolean;
	clone() : LiveLinkSourceBufferManagementSettings;
	static C(Other: UObject | any): LiveLinkSourceBufferManagementSettings;
}

declare class LiveLinkSourceFactory extends UObject { 
	static Load(ResourceName: string): LiveLinkSourceFactory;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceFactory;
	static GetDefaultObject(): LiveLinkSourceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceFactory;
	static C(Other: UObject | any): LiveLinkSourceFactory;
}

declare class LiveLinkSubjectName { 
	Name: string;
	clone() : LiveLinkSubjectName;
	static C(Other: UObject | any): LiveLinkSubjectName;
}

declare class LiveLinkSourceDebugInfo { 
	SubjectName: LiveLinkSubjectName;
	SnapshotIndex: number;
	NumberOfBufferAtSnapshot: number;
	clone() : LiveLinkSourceDebugInfo;
	static C(Other: UObject | any): LiveLinkSourceDebugInfo;
}

declare class LiveLinkSourceSettings extends UObject { 
	Mode: ELiveLinkSourceMode;
	BufferSettings: LiveLinkSourceBufferManagementSettings;
	ConnectionString: string;
	Factory: UnrealEngineClass;
	SourceDebugInfos: LiveLinkSourceDebugInfo[];
	static Load(ResourceName: string): LiveLinkSourceSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSourceSettings;
	static GetDefaultObject(): LiveLinkSourceSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSourceSettings;
	static C(Other: UObject | any): LiveLinkSourceSettings;
}

declare class LiveLinkCurveConversionSettings { 
	CurveConversionAssetMap: any;
	clone() : LiveLinkCurveConversionSettings;
	static C(Other: UObject | any): LiveLinkCurveConversionSettings;
}

declare class LiveLinkCurveRemapSettings extends LiveLinkSourceSettings { 
	CurveConversionSettings: LiveLinkCurveConversionSettings;
	static Load(ResourceName: string): LiveLinkCurveRemapSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkCurveRemapSettings;
	static GetDefaultObject(): LiveLinkCurveRemapSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkCurveRemapSettings;
	static C(Other: UObject | any): LiveLinkCurveRemapSettings;
}

declare class LiveLinkFrameInterpolationProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameInterpolationProcessor;
	static GetDefaultObject(): LiveLinkFrameInterpolationProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameInterpolationProcessor;
	static C(Other: UObject | any): LiveLinkFrameInterpolationProcessor;
}

declare class LiveLinkFramePreProcessor extends UObject { 
	static Load(ResourceName: string): LiveLinkFramePreProcessor;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFramePreProcessor;
	static GetDefaultObject(): LiveLinkFramePreProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFramePreProcessor;
	static C(Other: UObject | any): LiveLinkFramePreProcessor;
}

declare class LiveLinkFrameTranslator extends UObject { 
	static Load(ResourceName: string): LiveLinkFrameTranslator;
	static Find(Outer: UObject, ResourceName: string): LiveLinkFrameTranslator;
	static GetDefaultObject(): LiveLinkFrameTranslator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkFrameTranslator;
	static C(Other: UObject | any): LiveLinkFrameTranslator;
}

declare class LiveLinkLightRole extends LiveLinkTransformRole { 
	static Load(ResourceName: string): LiveLinkLightRole;
	static Find(Outer: UObject, ResourceName: string): LiveLinkLightRole;
	static GetDefaultObject(): LiveLinkLightRole;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkLightRole;
	static C(Other: UObject | any): LiveLinkLightRole;
}

declare class LiveLinkSubjectSettings extends UObject { 
	PreProcessors: LiveLinkFramePreProcessor[];
	InterpolationProcessor: LiveLinkFrameInterpolationProcessor;
	Translators: LiveLinkFrameTranslator[];
	Role: UnrealEngineClass;
	FrameRate: FrameRate;
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkSubjectSettings;
	static Find(Outer: UObject, ResourceName: string): LiveLinkSubjectSettings;
	static GetDefaultObject(): LiveLinkSubjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkSubjectSettings;
	static C(Other: UObject | any): LiveLinkSubjectSettings;
}

declare class LiveLinkVirtualSubject extends UObject { 
	Role: UnrealEngineClass;
	Subjects: LiveLinkSubjectName[];
	FrameTranslators: LiveLinkFrameTranslator[];
	bRebroadcastSubject: boolean;
	static Load(ResourceName: string): LiveLinkVirtualSubject;
	static Find(Outer: UObject, ResourceName: string): LiveLinkVirtualSubject;
	static GetDefaultObject(): LiveLinkVirtualSubject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LiveLinkVirtualSubject;
	static C(Other: UObject | any): LiveLinkVirtualSubject;
}

declare type EPIEPreviewDeviceType = 'Unset' | 'Android' | 'IOS' | 'TVOS' | 'Switch' | 'MAX';
declare var EPIEPreviewDeviceType : { Unset:'Unset',Android:'Android',IOS:'IOS',TVOS:'TVOS',Switch:'Switch',MAX:'MAX', };
declare class PIEPreviewDeviceSpecification extends UObject { 
	PreviewDeviceType: EPIEPreviewDeviceType;
	GPUFamily: string;
	GLVersion: string;
	VulkanVersion: string;
	AndroidVersion: string;
	DeviceMake: string;
	DeviceModel: string;
	DeviceBuildNumber: string;
	UsingHoudini: boolean;
	Hardware: string;
	Chipset: string;
	static Load(ResourceName: string): PIEPreviewDeviceSpecification;
	static Find(Outer: UObject, ResourceName: string): PIEPreviewDeviceSpecification;
	static GetDefaultObject(): PIEPreviewDeviceSpecification;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PIEPreviewDeviceSpecification;
	static C(Other: UObject | any): PIEPreviewDeviceSpecification;
}

declare class InputBehavior extends UObject { 
	static Load(ResourceName: string): InputBehavior;
	static Find(Outer: UObject, ResourceName: string): InputBehavior;
	static GetDefaultObject(): InputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehavior;
	static C(Other: UObject | any): InputBehavior;
}

declare class AnyButtonInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): AnyButtonInputBehavior;
	static Find(Outer: UObject, ResourceName: string): AnyButtonInputBehavior;
	static GetDefaultObject(): AnyButtonInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnyButtonInputBehavior;
	static C(Other: UObject | any): AnyButtonInputBehavior;
}

declare class AssetBackedTarget extends Interface { 
	static Load(ResourceName: string): AssetBackedTarget;
	static Find(Outer: UObject, ResourceName: string): AssetBackedTarget;
	static GetDefaultObject(): AssetBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBackedTarget;
	static C(Other: UObject | any): AssetBackedTarget;
}

declare class InteractiveGizmoBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoBuilder;
	static GetDefaultObject(): InteractiveGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoBuilder;
	static C(Other: UObject | any): InteractiveGizmoBuilder;
}

declare class AxisAngleGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): AxisAngleGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): AxisAngleGizmoBuilder;
	static GetDefaultObject(): AxisAngleGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisAngleGizmoBuilder;
	static C(Other: UObject | any): AxisAngleGizmoBuilder;
}

declare class BehaviorInfo { 
	Behavior: InputBehavior;
	clone() : BehaviorInfo;
	static C(Other: UObject | any): BehaviorInfo;
}

declare class InputBehaviorSet extends UObject { 
	Behaviors: BehaviorInfo[];
	static Load(ResourceName: string): InputBehaviorSet;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSet;
	static GetDefaultObject(): InputBehaviorSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSet;
	static C(Other: UObject | any): InputBehaviorSet;
}

declare class InteractiveGizmo extends UObject { 
	InputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InteractiveGizmo;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmo;
	static GetDefaultObject(): InteractiveGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmo;
	static C(Other: UObject | any): InteractiveGizmo;
}

declare class ClickDragInputBehavior extends AnyButtonInputBehavior { 
	bUpdateModifiersDuringDrag: boolean;
	static Load(ResourceName: string): ClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ClickDragInputBehavior;
	static GetDefaultObject(): ClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragInputBehavior;
	static C(Other: UObject | any): ClickDragInputBehavior;
}

declare class AxisAngleGizmo extends InteractiveGizmo { 
	AxisSource: any;
	AngleSource: any;
	HitTarget: any;
	StateTarget: any;
	MouseBehavior: ClickDragInputBehavior;
	bInInteraction: boolean;
	RotationOrigin: Vector;
	RotationAxis: Vector;
	RotationPlaneX: Vector;
	RotationPlaneY: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartAngle: number;
	InteractionCurAngle: number;
	static Load(ResourceName: string): AxisAngleGizmo;
	static Find(Outer: UObject, ResourceName: string): AxisAngleGizmo;
	static GetDefaultObject(): AxisAngleGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisAngleGizmo;
	static C(Other: UObject | any): AxisAngleGizmo;
}

declare class AxisPositionGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): AxisPositionGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): AxisPositionGizmoBuilder;
	static GetDefaultObject(): AxisPositionGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisPositionGizmoBuilder;
	static C(Other: UObject | any): AxisPositionGizmoBuilder;
}

declare class GizmoViewContext extends UObject { 
	static Load(ResourceName: string): GizmoViewContext;
	static Find(Outer: UObject, ResourceName: string): GizmoViewContext;
	static GetDefaultObject(): GizmoViewContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoViewContext;
	static C(Other: UObject | any): GizmoViewContext;
}

declare class AxisPositionGizmo extends InteractiveGizmo { 
	AxisSource: any;
	ParameterSource: any;
	GizmoViewContext: GizmoViewContext;
	HitTarget: any;
	StateTarget: any;
	MouseBehavior: ClickDragInputBehavior;
	bEnableSignedAxis: boolean;
	bInInteraction: boolean;
	InteractionOrigin: Vector;
	InteractionAxis: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartParameter: number;
	InteractionCurParameter: number;
	ParameterSign: number;
	static Load(ResourceName: string): AxisPositionGizmo;
	static Find(Outer: UObject, ResourceName: string): AxisPositionGizmo;
	static GetDefaultObject(): AxisPositionGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisPositionGizmo;
	static C(Other: UObject | any): AxisPositionGizmo;
}

declare class GizmoConstantAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	static Load(ResourceName: string): GizmoConstantAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantAxisSource;
	static GetDefaultObject(): GizmoConstantAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantAxisSource;
	static C(Other: UObject | any): GizmoConstantAxisSource;
}

declare class GizmoConstantFrameAxisSource extends UObject { 
	Origin: Vector;
	Direction: Vector;
	TangentX: Vector;
	TangentY: Vector;
	static Load(ResourceName: string): GizmoConstantFrameAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoConstantFrameAxisSource;
	static GetDefaultObject(): GizmoConstantFrameAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConstantFrameAxisSource;
	static C(Other: UObject | any): GizmoConstantFrameAxisSource;
}

declare class GizmoWorldAxisSource extends UObject { 
	Origin: Vector;
	AxisIndex: number;
	static Load(ResourceName: string): GizmoWorldAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoWorldAxisSource;
	static GetDefaultObject(): GizmoWorldAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoWorldAxisSource;
	static C(Other: UObject | any): GizmoWorldAxisSource;
}

declare class GizmoComponentAxisSource extends UObject { 
	Component: SceneComponent;
	AxisIndex: number;
	bLocalAxes: boolean;
	static Load(ResourceName: string): GizmoComponentAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentAxisSource;
	static GetDefaultObject(): GizmoComponentAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentAxisSource;
	static C(Other: UObject | any): GizmoComponentAxisSource;
}

declare class InteractiveToolPropertySet extends UObject { 
	CachedPropertiesMap: any;
	bIsPropertySetEnabled: boolean;
	static Load(ResourceName: string): InteractiveToolPropertySet;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolPropertySet;
	static GetDefaultObject(): InteractiveToolPropertySet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolPropertySet;
	static C(Other: UObject | any): InteractiveToolPropertySet;
}

declare class BrushBaseProperties extends InteractiveToolPropertySet { 
	BrushSize: number;
	bSpecifyRadius: boolean;
	BrushRadius: number;
	BrushStrength: number;
	BrushFalloffAmount: number;
	bShowStrength: boolean;
	bShowFalloff: boolean;
	static Load(ResourceName: string): BrushBaseProperties;
	static Find(Outer: UObject, ResourceName: string): BrushBaseProperties;
	static GetDefaultObject(): BrushBaseProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBaseProperties;
	static C(Other: UObject | any): BrushBaseProperties;
}

declare class InteractiveTool extends UObject { 
	InputBehaviors: InputBehaviorSet;
	ToolPropertyObjects: UObject[];
	static Load(ResourceName: string): InteractiveTool;
	static Find(Outer: UObject, ResourceName: string): InteractiveTool;
	static GetDefaultObject(): InteractiveTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveTool;
	static C(Other: UObject | any): InteractiveTool;
}

declare class ToolTarget extends UObject { 
	static Load(ResourceName: string): ToolTarget;
	static Find(Outer: UObject, ResourceName: string): ToolTarget;
	static GetDefaultObject(): ToolTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTarget;
	static C(Other: UObject | any): ToolTarget;
}

declare class SingleSelectionTool extends InteractiveTool { 
	Target: ToolTarget;
	static Load(ResourceName: string): SingleSelectionTool;
	static Find(Outer: UObject, ResourceName: string): SingleSelectionTool;
	static GetDefaultObject(): SingleSelectionTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleSelectionTool;
	static C(Other: UObject | any): SingleSelectionTool;
}

declare class MeshSurfacePointTool extends SingleSelectionTool { 
	static Load(ResourceName: string): MeshSurfacePointTool;
	static Find(Outer: UObject, ResourceName: string): MeshSurfacePointTool;
	static GetDefaultObject(): MeshSurfacePointTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSurfacePointTool;
	static C(Other: UObject | any): MeshSurfacePointTool;
}

declare class BrushStampData { 
	clone() : BrushStampData;
	static C(Other: UObject | any): BrushStampData;
}

declare class BrushStampIndicator extends InteractiveGizmo { 
	bVisible: boolean;
	BrushRadius: number;
	BrushFalloff: number;
	BrushPosition: Vector;
	BrushNormal: Vector;
	bDrawIndicatorLines: boolean;
	bDrawRadiusCircle: boolean;
	SampleStepCount: number;
	LineColor: LinearColor;
	LineThickness: number;
	bDepthTested: boolean;
	bDrawSecondaryLines: boolean;
	SecondaryLineThickness: number;
	SecondaryLineColor: LinearColor;
	AttachedComponent: PrimitiveComponent;
	static Load(ResourceName: string): BrushStampIndicator;
	static Find(Outer: UObject, ResourceName: string): BrushStampIndicator;
	static GetDefaultObject(): BrushStampIndicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushStampIndicator;
	static C(Other: UObject | any): BrushStampIndicator;
}

declare class BaseBrushTool extends MeshSurfacePointTool { 
	BrushProperties: BrushBaseProperties;
	bInBrushStroke: boolean;
	WorldToLocalScale: number;
	LastBrushStamp: BrushStampData;
	PropertyClass: Class;
	BrushStampIndicator: BrushStampIndicator;
	static Load(ResourceName: string): BaseBrushTool;
	static Find(Outer: UObject, ResourceName: string): BaseBrushTool;
	static GetDefaultObject(): BaseBrushTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseBrushTool;
	static C(Other: UObject | any): BaseBrushTool;
}

declare class BrushStampIndicatorBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): BrushStampIndicatorBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushStampIndicatorBuilder;
	static GetDefaultObject(): BrushStampIndicatorBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushStampIndicatorBuilder;
	static C(Other: UObject | any): BrushStampIndicatorBuilder;
}

declare class LocalClickDragInputBehavior extends ClickDragInputBehavior { 
	static Load(ResourceName: string): LocalClickDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalClickDragInputBehavior;
	static GetDefaultObject(): LocalClickDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalClickDragInputBehavior;
	static C(Other: UObject | any): LocalClickDragInputBehavior;
}

declare class InteractiveToolBuilder extends UObject { 
	static Load(ResourceName: string): InteractiveToolBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolBuilder;
	static GetDefaultObject(): InteractiveToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolBuilder;
	static C(Other: UObject | any): InteractiveToolBuilder;
}

declare class ClickDragToolBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): ClickDragToolBuilder;
	static Find(Outer: UObject, ResourceName: string): ClickDragToolBuilder;
	static GetDefaultObject(): ClickDragToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragToolBuilder;
	static C(Other: UObject | any): ClickDragToolBuilder;
}

declare class ClickDragTool extends InteractiveTool { 
	static Load(ResourceName: string): ClickDragTool;
	static Find(Outer: UObject, ResourceName: string): ClickDragTool;
	static GetDefaultObject(): ClickDragTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClickDragTool;
	static C(Other: UObject | any): ClickDragTool;
}

declare class InternalToolFrameworkActor extends Actor { 
	bIsSelectableInEditor: boolean;
	static GetDefaultObject(): InternalToolFrameworkActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternalToolFrameworkActor;
	static C(Other: UObject | any): InternalToolFrameworkActor;
}

declare class GizmoActor extends InternalToolFrameworkActor { 
	static GetDefaultObject(): GizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoActor;
	static C(Other: UObject | any): GizmoActor;
}

declare class CombinedTransformGizmoActor extends GizmoActor { 
	TranslateX: PrimitiveComponent;
	TranslateY: PrimitiveComponent;
	TranslateZ: PrimitiveComponent;
	TranslateYZ: PrimitiveComponent;
	TranslateXZ: PrimitiveComponent;
	TranslateXY: PrimitiveComponent;
	RotateX: PrimitiveComponent;
	RotateY: PrimitiveComponent;
	RotateZ: PrimitiveComponent;
	UniformScale: PrimitiveComponent;
	AxisScaleX: PrimitiveComponent;
	AxisScaleY: PrimitiveComponent;
	AxisScaleZ: PrimitiveComponent;
	PlaneScaleYZ: PrimitiveComponent;
	PlaneScaleXZ: PrimitiveComponent;
	PlaneScaleXY: PrimitiveComponent;
	static GetDefaultObject(): CombinedTransformGizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoActor;
	static C(Other: UObject | any): CombinedTransformGizmoActor;
}

declare class CombinedTransformGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): CombinedTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmoBuilder;
	static GetDefaultObject(): CombinedTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoBuilder;
	static C(Other: UObject | any): CombinedTransformGizmoBuilder;
}

declare class TransformProxy extends UObject { 
	bRotatePerObject: boolean;
	bSetPivotMode: boolean;
	SharedTransform: Transform;
	InitialSharedTransform: Transform;
	static Load(ResourceName: string): TransformProxy;
	static Find(Outer: UObject, ResourceName: string): TransformProxy;
	static GetDefaultObject(): TransformProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformProxy;
	static C(Other: UObject | any): TransformProxy;
}

declare type EToolContextCoordinateSystem = 'World' | 'Local' | 'EToolContextCoordinateSystem_MAX';
declare var EToolContextCoordinateSystem : { World:'World',Local:'Local',EToolContextCoordinateSystem_MAX:'EToolContextCoordinateSystem_MAX', };
declare class GizmoTransformChangeStateTarget extends UObject { 
	TransactionManager: any;
	static Load(ResourceName: string): GizmoTransformChangeStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformChangeStateTarget;
	static GetDefaultObject(): GizmoTransformChangeStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformChangeStateTarget;
	static C(Other: UObject | any): GizmoTransformChangeStateTarget;
}

declare class CombinedTransformGizmo extends InteractiveGizmo { 
	ActiveTarget: TransformProxy;
	bSnapToWorldGrid: boolean;
	bGridSizeIsExplicit: boolean;
	ExplicitGridSize: Vector;
	bRotationGridSizeIsExplicit: boolean;
	ExplicitRotationGridSize: Rotator;
	bSnapToWorldRotGrid: boolean;
	bUseContextCoordinateSystem: boolean;
	CurrentCoordinateSystem: EToolContextCoordinateSystem;
	ActiveComponents: PrimitiveComponent[];
	NonuniformScaleComponents: PrimitiveComponent[];
	ActiveGizmos: InteractiveGizmo[];
	CameraAxisSource: GizmoConstantFrameAxisSource;
	AxisXSource: GizmoComponentAxisSource;
	AxisYSource: GizmoComponentAxisSource;
	AxisZSource: GizmoComponentAxisSource;
	UnitAxisXSource: GizmoComponentAxisSource;
	UnitAxisYSource: GizmoComponentAxisSource;
	UnitAxisZSource: GizmoComponentAxisSource;
	StateTarget: GizmoTransformChangeStateTarget;
	static Load(ResourceName: string): CombinedTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmo;
	static GetDefaultObject(): CombinedTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmo;
	static C(Other: UObject | any): CombinedTransformGizmo;
}

declare class ContextObjectStore extends UObject { 
	ContextObjects: UObject[];
	static Load(ResourceName: string): ContextObjectStore;
	static Find(Outer: UObject, ResourceName: string): ContextObjectStore;
	static GetDefaultObject(): ContextObjectStore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContextObjectStore;
	static C(Other: UObject | any): ContextObjectStore;
}

declare class GizmoBaseComponent extends PrimitiveComponent { 
	Color: LinearColor;
	HoverSizeMultiplier: number;
	PixelHitDistanceThreshold: number;
	GizmoViewContext: GizmoViewContext;
	static Load(ResourceName: string): GizmoBaseComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseComponent;
	static GetDefaultObject(): GizmoBaseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseComponent;
	UpdateWorldLocalState(bWorldIn: boolean): void;
	UpdateHoverState(bHoveringIn: boolean): void;
	static C(Other: UObject | any): GizmoBaseComponent;
}

declare class GizmoArrowComponent extends GizmoBaseComponent { 
	Direction: Vector;
	Gap: number;
	Length: number;
	Thickness: number;
	static Load(ResourceName: string): GizmoArrowComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoArrowComponent;
	static GetDefaultObject(): GizmoArrowComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoArrowComponent;
	static C(Other: UObject | any): GizmoArrowComponent;
}

declare class GizmoBoxComponent extends GizmoBaseComponent { 
	Origin: Vector;
	Rotation: Quat;
	Dimensions: Vector;
	LineThickness: number;
	bRemoveHiddenLines: boolean;
	bEnableAxisFlip: boolean;
	static Load(ResourceName: string): GizmoBoxComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoBoxComponent;
	static GetDefaultObject(): GizmoBoxComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBoxComponent;
	static C(Other: UObject | any): GizmoBoxComponent;
}

declare class GizmoCircleComponent extends GizmoBaseComponent { 
	Normal: Vector;
	Radius: number;
	Thickness: number;
	NumSides: number;
	bViewAligned: boolean;
	bDrawFullCircle: boolean;
	bOnlyAllowFrontFacingHits: boolean;
	static Load(ResourceName: string): GizmoCircleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoCircleComponent;
	static GetDefaultObject(): GizmoCircleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoCircleComponent;
	static C(Other: UObject | any): GizmoCircleComponent;
}

declare class GizmoTransformSource extends Interface { 
	static Load(ResourceName: string): GizmoTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformSource;
	static GetDefaultObject(): GizmoTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformSource;
	SetTransform(NewTransform: Transform): void;
	GetTransform(): Transform;
	static C(Other: UObject | any): GizmoTransformSource;
}

declare class GizmoAxisSource extends Interface { 
	static Load(ResourceName: string): GizmoAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisSource;
	static GetDefaultObject(): GizmoAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisSource;
	HasTangentVectors(): boolean;
	GetTangentVectors(TangentXOut?: Vector,TangentYOut?: Vector): {TangentXOut: Vector, TangentYOut: Vector};
	GetOrigin(): Vector;
	GetDirection(): Vector;
	static C(Other: UObject | any): GizmoAxisSource;
}

declare class GizmoClickTarget extends Interface { 
	static Load(ResourceName: string): GizmoClickTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoClickTarget;
	static GetDefaultObject(): GizmoClickTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoClickTarget;
	UpdateInteractingState(bInteracting: boolean): void;
	UpdateHoverState(bHovering: boolean): void;
	static C(Other: UObject | any): GizmoClickTarget;
}

declare class GizmoStateTarget extends Interface { 
	static Load(ResourceName: string): GizmoStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoStateTarget;
	static GetDefaultObject(): GizmoStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoStateTarget;
	EndUpdate(): void;
	BeginUpdate(): void;
	static C(Other: UObject | any): GizmoStateTarget;
}

declare class GizmoFloatParameterSource extends Interface { 
	static Load(ResourceName: string): GizmoFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoFloatParameterSource;
	static GetDefaultObject(): GizmoFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoFloatParameterSource;
	SetParameter(NewValue: number): void;
	GetParameter(): number;
	EndModify(): void;
	BeginModify(): void;
	static C(Other: UObject | any): GizmoFloatParameterSource;
}

declare class GizmoVec2ParameterSource extends Interface { 
	static Load(ResourceName: string): GizmoVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoVec2ParameterSource;
	static GetDefaultObject(): GizmoVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoVec2ParameterSource;
	SetParameter(NewValue: Vector2D): void;
	GetParameter(): Vector2D;
	EndModify(): void;
	BeginModify(): void;
	static C(Other: UObject | any): GizmoVec2ParameterSource;
}

declare class GizmoLineHandleComponent extends GizmoBaseComponent { 
	Normal: Vector;
	HandleSize: number;
	Thickness: number;
	Direction: Vector;
	Length: number;
	bImageScale: boolean;
	static Load(ResourceName: string): GizmoLineHandleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoLineHandleComponent;
	static GetDefaultObject(): GizmoLineHandleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLineHandleComponent;
	static C(Other: UObject | any): GizmoLineHandleComponent;
}

declare class GizmoRectangleComponent extends GizmoBaseComponent { 
	DirectionX: Vector;
	DirectionY: Vector;
	bOrientYAccordingToCamera: boolean;
	OffsetX: number;
	OffsetY: number;
	LengthX: number;
	LengthY: number;
	Thickness: number;
	SegmentFlags: number;
	static Load(ResourceName: string): GizmoRectangleComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoRectangleComponent;
	static GetDefaultObject(): GizmoRectangleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoRectangleComponent;
	static C(Other: UObject | any): GizmoRectangleComponent;
}

declare class GizmoLambdaHitTarget extends UObject { 
	static Load(ResourceName: string): GizmoLambdaHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoLambdaHitTarget;
	static GetDefaultObject(): GizmoLambdaHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLambdaHitTarget;
	static C(Other: UObject | any): GizmoLambdaHitTarget;
}

declare class GizmoComponentHitTarget extends UObject { 
	Component: PrimitiveComponent;
	static Load(ResourceName: string): GizmoComponentHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentHitTarget;
	static GetDefaultObject(): GizmoComponentHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentHitTarget;
	static C(Other: UObject | any): GizmoComponentHitTarget;
}

declare class InputBehaviorSource extends Interface { 
	static Load(ResourceName: string): InputBehaviorSource;
	static Find(Outer: UObject, ResourceName: string): InputBehaviorSource;
	static GetDefaultObject(): InputBehaviorSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputBehaviorSource;
	static C(Other: UObject | any): InputBehaviorSource;
}

declare class LocalInputBehaviorSource extends UObject { 
	static Load(ResourceName: string): LocalInputBehaviorSource;
	static Find(Outer: UObject, ResourceName: string): LocalInputBehaviorSource;
	static GetDefaultObject(): LocalInputBehaviorSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalInputBehaviorSource;
	static C(Other: UObject | any): LocalInputBehaviorSource;
}

declare class InputRouter extends UObject { 
	bAutoInvalidateOnHover: boolean;
	bAutoInvalidateOnCapture: boolean;
	ActiveInputBehaviors: InputBehaviorSet;
	static Load(ResourceName: string): InputRouter;
	static Find(Outer: UObject, ResourceName: string): InputRouter;
	static GetDefaultObject(): InputRouter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputRouter;
	static C(Other: UObject | any): InputRouter;
}

declare class InteractionMechanic extends UObject { 
	static Load(ResourceName: string): InteractionMechanic;
	static Find(Outer: UObject, ResourceName: string): InteractionMechanic;
	static GetDefaultObject(): InteractionMechanic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractionMechanic;
	static C(Other: UObject | any): InteractionMechanic;
}

declare class ActiveGizmo { 
	Gizmo: InteractiveGizmo;
	clone() : ActiveGizmo;
	static C(Other: UObject | any): ActiveGizmo;
}

declare class InteractiveGizmoManager extends UObject { 
	ActiveGizmos: ActiveGizmo[];
	GizmoBuilders: any;
	static Load(ResourceName: string): InteractiveGizmoManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveGizmoManager;
	static GetDefaultObject(): InteractiveGizmoManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveGizmoManager;
	static C(Other: UObject | any): InteractiveGizmoManager;
}

declare class InteractiveToolWithToolTargetsBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): InteractiveToolWithToolTargetsBuilder;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolWithToolTargetsBuilder;
	static GetDefaultObject(): InteractiveToolWithToolTargetsBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolWithToolTargetsBuilder;
	static C(Other: UObject | any): InteractiveToolWithToolTargetsBuilder;
}

declare class ToolContextTransactionProvider extends Interface { 
	static Load(ResourceName: string): ToolContextTransactionProvider;
	static Find(Outer: UObject, ResourceName: string): ToolContextTransactionProvider;
	static GetDefaultObject(): ToolContextTransactionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolContextTransactionProvider;
	static C(Other: UObject | any): ToolContextTransactionProvider;
}

declare class InteractiveToolManager extends UObject { 
	ActiveLeftTool: InteractiveTool;
	ActiveRightTool: InteractiveTool;
	ToolBuilders: any;
	static Load(ResourceName: string): InteractiveToolManager;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolManager;
	static GetDefaultObject(): InteractiveToolManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolManager;
	static C(Other: UObject | any): InteractiveToolManager;
}

declare class ToolFrameworkComponent extends Interface { 
	static Load(ResourceName: string): ToolFrameworkComponent;
	static Find(Outer: UObject, ResourceName: string): ToolFrameworkComponent;
	static GetDefaultObject(): ToolFrameworkComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolFrameworkComponent;
	static C(Other: UObject | any): ToolFrameworkComponent;
}

declare class InteractiveToolCameraFocusAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolCameraFocusAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolCameraFocusAPI;
	static GetDefaultObject(): InteractiveToolCameraFocusAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolCameraFocusAPI;
	static C(Other: UObject | any): InteractiveToolCameraFocusAPI;
}

declare class InteractiveToolNestedAcceptCancelAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolNestedAcceptCancelAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolNestedAcceptCancelAPI;
	static GetDefaultObject(): InteractiveToolNestedAcceptCancelAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolNestedAcceptCancelAPI;
	static C(Other: UObject | any): InteractiveToolNestedAcceptCancelAPI;
}

declare class InteractiveToolExclusiveToolAPI extends Interface { 
	static Load(ResourceName: string): InteractiveToolExclusiveToolAPI;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolExclusiveToolAPI;
	static GetDefaultObject(): InteractiveToolExclusiveToolAPI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolExclusiveToolAPI;
	static C(Other: UObject | any): InteractiveToolExclusiveToolAPI;
}

declare class ToolTargetFactory extends UObject { 
	static Load(ResourceName: string): ToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): ToolTargetFactory;
	static GetDefaultObject(): ToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetFactory;
	static C(Other: UObject | any): ToolTargetFactory;
}

declare class ToolTargetManager extends UObject { 
	Factories: ToolTargetFactory[];
	static Load(ResourceName: string): ToolTargetManager;
	static Find(Outer: UObject, ResourceName: string): ToolTargetManager;
	static GetDefaultObject(): ToolTargetManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToolTargetManager;
	static C(Other: UObject | any): ToolTargetManager;
}

declare class InteractiveToolsContext extends UObject { 
	InputRouter: InputRouter;
	TargetManager: ToolTargetManager;
	ToolManager: InteractiveToolManager;
	GizmoManager: InteractiveGizmoManager;
	ContextObjectStore: ContextObjectStore;
	ToolManagerClass: Class;
	static Load(ResourceName: string): InteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): InteractiveToolsContext;
	static GetDefaultObject(): InteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InteractiveToolsContext;
	static C(Other: UObject | any): InteractiveToolsContext;
}

declare class IntervalGizmoActor extends GizmoActor { 
	UpIntervalComponent: GizmoLineHandleComponent;
	DownIntervalComponent: GizmoLineHandleComponent;
	ForwardIntervalComponent: GizmoLineHandleComponent;
	static GetDefaultObject(): IntervalGizmoActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmoActor;
	static C(Other: UObject | any): IntervalGizmoActor;
}

declare class IntervalGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): IntervalGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): IntervalGizmoBuilder;
	static GetDefaultObject(): IntervalGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmoBuilder;
	static C(Other: UObject | any): IntervalGizmoBuilder;
}

declare class IntervalGizmo extends InteractiveGizmo { 
	StateTarget: GizmoTransformChangeStateTarget;
	TransformProxy: TransformProxy;
	ActiveComponents: PrimitiveComponent[];
	ActiveGizmos: InteractiveGizmo[];
	AxisYSource: GizmoComponentAxisSource;
	AxisZSource: GizmoComponentAxisSource;
	static Load(ResourceName: string): IntervalGizmo;
	static Find(Outer: UObject, ResourceName: string): IntervalGizmo;
	static GetDefaultObject(): IntervalGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntervalGizmo;
	static C(Other: UObject | any): IntervalGizmo;
}

declare class GizmoBaseFloatParameterSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseFloatParameterSource;
	static GetDefaultObject(): GizmoBaseFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseFloatParameterSource;
	static C(Other: UObject | any): GizmoBaseFloatParameterSource;
}

declare class GizmoAxisIntervalParameterSource extends GizmoBaseFloatParameterSource { 
	FloatParameterSource: any;
	MinParameter: number;
	MaxParameter: number;
	static Load(ResourceName: string): GizmoAxisIntervalParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisIntervalParameterSource;
	static GetDefaultObject(): GizmoAxisIntervalParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisIntervalParameterSource;
	static C(Other: UObject | any): GizmoAxisIntervalParameterSource;
}

declare class KeyAsModifierInputBehavior extends InputBehavior { 
	static Load(ResourceName: string): KeyAsModifierInputBehavior;
	static Find(Outer: UObject, ResourceName: string): KeyAsModifierInputBehavior;
	static GetDefaultObject(): KeyAsModifierInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KeyAsModifierInputBehavior;
	static C(Other: UObject | any): KeyAsModifierInputBehavior;
}

declare class MaterialProvider extends Interface { 
	static Load(ResourceName: string): MaterialProvider;
	static Find(Outer: UObject, ResourceName: string): MaterialProvider;
	static GetDefaultObject(): MaterialProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialProvider;
	static C(Other: UObject | any): MaterialProvider;
}

declare class MeshDescriptionCommitter extends Interface { 
	static Load(ResourceName: string): MeshDescriptionCommitter;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionCommitter;
	static GetDefaultObject(): MeshDescriptionCommitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionCommitter;
	static C(Other: UObject | any): MeshDescriptionCommitter;
}

declare class MeshDescriptionProvider extends Interface { 
	static Load(ResourceName: string): MeshDescriptionProvider;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionProvider;
	static GetDefaultObject(): MeshDescriptionProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionProvider;
	static C(Other: UObject | any): MeshDescriptionProvider;
}

declare class MeshSurfacePointToolBuilder extends InteractiveToolWithToolTargetsBuilder { 
	static Load(ResourceName: string): MeshSurfacePointToolBuilder;
	static Find(Outer: UObject, ResourceName: string): MeshSurfacePointToolBuilder;
	static GetDefaultObject(): MeshSurfacePointToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSurfacePointToolBuilder;
	static C(Other: UObject | any): MeshSurfacePointToolBuilder;
}

declare class MouseHoverBehavior extends InputBehavior { 
	static Load(ResourceName: string): MouseHoverBehavior;
	static Find(Outer: UObject, ResourceName: string): MouseHoverBehavior;
	static GetDefaultObject(): MouseHoverBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseHoverBehavior;
	static C(Other: UObject | any): MouseHoverBehavior;
}

declare class LocalMouseHoverBehavior extends MouseHoverBehavior { 
	static Load(ResourceName: string): LocalMouseHoverBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalMouseHoverBehavior;
	static GetDefaultObject(): LocalMouseHoverBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMouseHoverBehavior;
	static C(Other: UObject | any): LocalMouseHoverBehavior;
}

declare class MouseWheelInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): MouseWheelInputBehavior;
	static Find(Outer: UObject, ResourceName: string): MouseWheelInputBehavior;
	static GetDefaultObject(): MouseWheelInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseWheelInputBehavior;
	static C(Other: UObject | any): MouseWheelInputBehavior;
}

declare class MultiClickSequenceInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): MultiClickSequenceInputBehavior;
	static Find(Outer: UObject, ResourceName: string): MultiClickSequenceInputBehavior;
	static GetDefaultObject(): MultiClickSequenceInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiClickSequenceInputBehavior;
	static C(Other: UObject | any): MultiClickSequenceInputBehavior;
}

declare class MultiSelectionTool extends InteractiveTool { 
	Targets: ToolTarget[];
	static Load(ResourceName: string): MultiSelectionTool;
	static Find(Outer: UObject, ResourceName: string): MultiSelectionTool;
	static GetDefaultObject(): MultiSelectionTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiSelectionTool;
	static C(Other: UObject | any): MultiSelectionTool;
}

declare class GizmoFloatParameterChange { 
	InitialValue: number;
	CurrentValue: number;
	clone() : GizmoFloatParameterChange;
	static C(Other: UObject | any): GizmoFloatParameterChange;
}

declare class GizmoLocalFloatParameterSource extends GizmoBaseFloatParameterSource { 
	Value: number;
	LastChange: GizmoFloatParameterChange;
	static Load(ResourceName: string): GizmoLocalFloatParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoLocalFloatParameterSource;
	static GetDefaultObject(): GizmoLocalFloatParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLocalFloatParameterSource;
	static C(Other: UObject | any): GizmoLocalFloatParameterSource;
}

declare class GizmoBaseVec2ParameterSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseVec2ParameterSource;
	static GetDefaultObject(): GizmoBaseVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseVec2ParameterSource;
	static C(Other: UObject | any): GizmoBaseVec2ParameterSource;
}

declare class GizmoVec2ParameterChange { 
	InitialValue: Vector2D;
	CurrentValue: Vector2D;
	clone() : GizmoVec2ParameterChange;
	static C(Other: UObject | any): GizmoVec2ParameterChange;
}

declare class GizmoLocalVec2ParameterSource extends GizmoBaseVec2ParameterSource { 
	Value: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	static Load(ResourceName: string): GizmoLocalVec2ParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoLocalVec2ParameterSource;
	static GetDefaultObject(): GizmoLocalVec2ParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLocalVec2ParameterSource;
	static C(Other: UObject | any): GizmoLocalVec2ParameterSource;
}

declare class GizmoAxisTranslationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	TransformSource: any;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurTranslationAxis: Vector;
	CurTranslationOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisTranslationParameterSource;
	static GetDefaultObject(): GizmoAxisTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisTranslationParameterSource;
	static C(Other: UObject | any): GizmoAxisTranslationParameterSource;
}

declare class GizmoPlaneTranslationParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: any;
	TransformSource: any;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurTranslationOrigin: Vector;
	CurTranslationNormal: Vector;
	CurTranslationAxisX: Vector;
	CurTranslationAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoPlaneTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoPlaneTranslationParameterSource;
	static GetDefaultObject(): GizmoPlaneTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoPlaneTranslationParameterSource;
	static C(Other: UObject | any): GizmoPlaneTranslationParameterSource;
}

declare class GizmoAxisRotationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	TransformSource: any;
	Angle: number;
	LastChange: GizmoFloatParameterChange;
	CurRotationAxis: Vector;
	CurRotationOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisRotationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisRotationParameterSource;
	static GetDefaultObject(): GizmoAxisRotationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisRotationParameterSource;
	static C(Other: UObject | any): GizmoAxisRotationParameterSource;
}

declare class GizmoUniformScaleParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: any;
	TransformSource: any;
	ScaleMultiplier: number;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurScaleOrigin: Vector;
	CurScaleNormal: Vector;
	CurScaleAxisX: Vector;
	CurScaleAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoUniformScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoUniformScaleParameterSource;
	static GetDefaultObject(): GizmoUniformScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoUniformScaleParameterSource;
	static C(Other: UObject | any): GizmoUniformScaleParameterSource;
}

declare class GizmoAxisScaleParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	TransformSource: any;
	ScaleMultiplier: number;
	bClampToZero: boolean;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurScaleAxis: Vector;
	CurScaleOrigin: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoAxisScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoAxisScaleParameterSource;
	static GetDefaultObject(): GizmoAxisScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoAxisScaleParameterSource;
	static C(Other: UObject | any): GizmoAxisScaleParameterSource;
}

declare class GizmoPlaneScaleParameterSource extends GizmoBaseVec2ParameterSource { 
	AxisSource: any;
	TransformSource: any;
	ScaleMultiplier: number;
	bUseEqualScaling: boolean;
	bClampToZero: boolean;
	Parameter: Vector2D;
	LastChange: GizmoVec2ParameterChange;
	CurScaleOrigin: Vector;
	CurScaleNormal: Vector;
	CurScaleAxisX: Vector;
	CurScaleAxisY: Vector;
	InitialTransform: Transform;
	static Load(ResourceName: string): GizmoPlaneScaleParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoPlaneScaleParameterSource;
	static GetDefaultObject(): GizmoPlaneScaleParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoPlaneScaleParameterSource;
	static C(Other: UObject | any): GizmoPlaneScaleParameterSource;
}

declare class PhysicsDataSource extends Interface { 
	static Load(ResourceName: string): PhysicsDataSource;
	static Find(Outer: UObject, ResourceName: string): PhysicsDataSource;
	static GetDefaultObject(): PhysicsDataSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsDataSource;
	static C(Other: UObject | any): PhysicsDataSource;
}

declare class PlanePositionGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): PlanePositionGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): PlanePositionGizmoBuilder;
	static GetDefaultObject(): PlanePositionGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanePositionGizmoBuilder;
	static C(Other: UObject | any): PlanePositionGizmoBuilder;
}

declare class PlanePositionGizmo extends InteractiveGizmo { 
	AxisSource: any;
	ParameterSource: any;
	HitTarget: any;
	StateTarget: any;
	MouseBehavior: ClickDragInputBehavior;
	bEnableSignedAxis: boolean;
	bFlipX: boolean;
	bFlipY: boolean;
	bInInteraction: boolean;
	InteractionOrigin: Vector;
	InteractionNormal: Vector;
	InteractionAxisX: Vector;
	InteractionAxisY: Vector;
	InteractionStartPoint: Vector;
	InteractionCurPoint: Vector;
	InteractionStartParameter: Vector2D;
	InteractionCurParameter: Vector2D;
	ParameterSigns: Vector2D;
	static Load(ResourceName: string): PlanePositionGizmo;
	static Find(Outer: UObject, ResourceName: string): PlanePositionGizmo;
	static GetDefaultObject(): PlanePositionGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanePositionGizmo;
	static C(Other: UObject | any): PlanePositionGizmo;
}

declare class PrimitiveComponentBackedTarget extends Interface { 
	static Load(ResourceName: string): PrimitiveComponentBackedTarget;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentBackedTarget;
	static GetDefaultObject(): PrimitiveComponentBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentBackedTarget;
	static C(Other: UObject | any): PrimitiveComponentBackedTarget;
}

declare class PrimitiveComponentToolTarget extends ToolTarget { 
	static Load(ResourceName: string): PrimitiveComponentToolTarget;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentToolTarget;
	static GetDefaultObject(): PrimitiveComponentToolTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentToolTarget;
	static C(Other: UObject | any): PrimitiveComponentToolTarget;
}

declare class PrimitiveComponentToolTargetFactory extends ToolTargetFactory { 
	static Load(ResourceName: string): PrimitiveComponentToolTargetFactory;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponentToolTargetFactory;
	static GetDefaultObject(): PrimitiveComponentToolTargetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponentToolTargetFactory;
	static C(Other: UObject | any): PrimitiveComponentToolTargetFactory;
}

declare class RepositionableTransformGizmoBuilder extends CombinedTransformGizmoBuilder { 
	static Load(ResourceName: string): RepositionableTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): RepositionableTransformGizmoBuilder;
	static GetDefaultObject(): RepositionableTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepositionableTransformGizmoBuilder;
	static C(Other: UObject | any): RepositionableTransformGizmoBuilder;
}

declare class RepositionableTransformGizmo extends CombinedTransformGizmo { 
	RepositionStateTarget: GizmoTransformChangeStateTarget;
	static Load(ResourceName: string): RepositionableTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): RepositionableTransformGizmo;
	static GetDefaultObject(): RepositionableTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RepositionableTransformGizmo;
	static C(Other: UObject | any): RepositionableTransformGizmo;
}

declare class ScalableSphereGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): ScalableSphereGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmoBuilder;
	static GetDefaultObject(): ScalableSphereGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmoBuilder;
	static C(Other: UObject | any): ScalableSphereGizmoBuilder;
}

declare class ScalableSphereGizmo extends InteractiveGizmo { 
	HitErrorThreshold: number;
	TransactionDescription: string;
	Radius: number;
	bIsHovering: boolean;
	bIsDragging: boolean;
	ActiveTarget: TransformProxy;
	ActiveAxis: Vector;
	DragStartWorldPosition: Vector;
	DragCurrentPositionProjected: Vector;
	InteractionStartParameter: number;
	static Load(ResourceName: string): ScalableSphereGizmo;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmo;
	static GetDefaultObject(): ScalableSphereGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmo;
	static C(Other: UObject | any): ScalableSphereGizmo;
}

declare class ScalableSphereGizmoInputBehavior extends AnyButtonInputBehavior { 
	static Load(ResourceName: string): ScalableSphereGizmoInputBehavior;
	static Find(Outer: UObject, ResourceName: string): ScalableSphereGizmoInputBehavior;
	static GetDefaultObject(): ScalableSphereGizmoInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScalableSphereGizmoInputBehavior;
	static C(Other: UObject | any): ScalableSphereGizmoInputBehavior;
}

declare class SceneSnappingManager extends UObject { 
	static Load(ResourceName: string): SceneSnappingManager;
	static Find(Outer: UObject, ResourceName: string): SceneSnappingManager;
	static GetDefaultObject(): SceneSnappingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneSnappingManager;
	static C(Other: UObject | any): SceneSnappingManager;
}

declare class SelectionSet extends UObject { 
	static Load(ResourceName: string): SelectionSet;
	static Find(Outer: UObject, ResourceName: string): SelectionSet;
	static GetDefaultObject(): SelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SelectionSet;
	static C(Other: UObject | any): SelectionSet;
}

declare class MeshSelectionSet extends SelectionSet { 
	Vertices: number[];
	Edges: number[];
	Faces: number[];
	Groups: number[];
	static Load(ResourceName: string): MeshSelectionSet;
	static Find(Outer: UObject, ResourceName: string): MeshSelectionSet;
	static GetDefaultObject(): MeshSelectionSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSelectionSet;
	static C(Other: UObject | any): MeshSelectionSet;
}

declare class SingleClickInputBehavior extends AnyButtonInputBehavior { 
	HitTestOnRelease: boolean;
	static Load(ResourceName: string): SingleClickInputBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleClickInputBehavior;
	static GetDefaultObject(): SingleClickInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickInputBehavior;
	static C(Other: UObject | any): SingleClickInputBehavior;
}

declare class LocalSingleClickInputBehavior extends SingleClickInputBehavior { 
	static Load(ResourceName: string): LocalSingleClickInputBehavior;
	static Find(Outer: UObject, ResourceName: string): LocalSingleClickInputBehavior;
	static GetDefaultObject(): LocalSingleClickInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalSingleClickInputBehavior;
	static C(Other: UObject | any): LocalSingleClickInputBehavior;
}

declare class SingleClickOrDragInputBehavior extends AnyButtonInputBehavior { 
	bBeginDragIfClickTargetNotHit: boolean;
	ClickDistanceThreshold: number;
	static Load(ResourceName: string): SingleClickOrDragInputBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleClickOrDragInputBehavior;
	static GetDefaultObject(): SingleClickOrDragInputBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickOrDragInputBehavior;
	static C(Other: UObject | any): SingleClickOrDragInputBehavior;
}

declare class SingleClickToolBuilder extends InteractiveToolBuilder { 
	static Load(ResourceName: string): SingleClickToolBuilder;
	static Find(Outer: UObject, ResourceName: string): SingleClickToolBuilder;
	static GetDefaultObject(): SingleClickToolBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickToolBuilder;
	static C(Other: UObject | any): SingleClickToolBuilder;
}

declare class SingleClickTool extends InteractiveTool { 
	static Load(ResourceName: string): SingleClickTool;
	static Find(Outer: UObject, ResourceName: string): SingleClickTool;
	static GetDefaultObject(): SingleClickTool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleClickTool;
	static C(Other: UObject | any): SingleClickTool;
}

declare class SingleKeyCaptureBehavior extends InputBehavior { 
	static Load(ResourceName: string): SingleKeyCaptureBehavior;
	static Find(Outer: UObject, ResourceName: string): SingleKeyCaptureBehavior;
	static GetDefaultObject(): SingleKeyCaptureBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SingleKeyCaptureBehavior;
	static C(Other: UObject | any): SingleKeyCaptureBehavior;
}

declare class SkeletalMeshBackedTarget extends AssetBackedTarget { 
	static Load(ResourceName: string): SkeletalMeshBackedTarget;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshBackedTarget;
	static GetDefaultObject(): SkeletalMeshBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshBackedTarget;
	static C(Other: UObject | any): SkeletalMeshBackedTarget;
}

declare class GizmoNilStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoNilStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoNilStateTarget;
	static GetDefaultObject(): GizmoNilStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoNilStateTarget;
	static C(Other: UObject | any): GizmoNilStateTarget;
}

declare class GizmoLambdaStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoLambdaStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoLambdaStateTarget;
	static GetDefaultObject(): GizmoLambdaStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoLambdaStateTarget;
	static C(Other: UObject | any): GizmoLambdaStateTarget;
}

declare class GizmoObjectModifyStateTarget extends UObject { 
	static Load(ResourceName: string): GizmoObjectModifyStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectModifyStateTarget;
	static GetDefaultObject(): GizmoObjectModifyStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectModifyStateTarget;
	static C(Other: UObject | any): GizmoObjectModifyStateTarget;
}

declare class StaticMeshBackedTarget extends AssetBackedTarget { 
	static Load(ResourceName: string): StaticMeshBackedTarget;
	static Find(Outer: UObject, ResourceName: string): StaticMeshBackedTarget;
	static GetDefaultObject(): StaticMeshBackedTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshBackedTarget;
	static C(Other: UObject | any): StaticMeshBackedTarget;
}

declare class CombinedTransformGizmoContextObject extends UObject { 
	static Load(ResourceName: string): CombinedTransformGizmoContextObject;
	static Find(Outer: UObject, ResourceName: string): CombinedTransformGizmoContextObject;
	static GetDefaultObject(): CombinedTransformGizmoContextObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CombinedTransformGizmoContextObject;
	static C(Other: UObject | any): CombinedTransformGizmoContextObject;
}

declare class GizmoBaseTransformSource extends UObject { 
	static Load(ResourceName: string): GizmoBaseTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseTransformSource;
	static GetDefaultObject(): GizmoBaseTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseTransformSource;
	static C(Other: UObject | any): GizmoBaseTransformSource;
}

declare class GizmoComponentWorldTransformSource extends GizmoBaseTransformSource { 
	Component: SceneComponent;
	bModifyComponentOnTransform: boolean;
	static Load(ResourceName: string): GizmoComponentWorldTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoComponentWorldTransformSource;
	static GetDefaultObject(): GizmoComponentWorldTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoComponentWorldTransformSource;
	static C(Other: UObject | any): GizmoComponentWorldTransformSource;
}

declare class GizmoScaledTransformSource extends GizmoBaseTransformSource { 
	ChildTransformSource: any;
	static Load(ResourceName: string): GizmoScaledTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoScaledTransformSource;
	static GetDefaultObject(): GizmoScaledTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoScaledTransformSource;
	static C(Other: UObject | any): GizmoScaledTransformSource;
}

declare class GizmoTransformProxyTransformSource extends GizmoBaseTransformSource { 
	Proxy: TransformProxy;
	static Load(ResourceName: string): GizmoTransformProxyTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoTransformProxyTransformSource;
	static GetDefaultObject(): GizmoTransformProxyTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoTransformProxyTransformSource;
	static C(Other: UObject | any): GizmoTransformProxyTransformSource;
}

declare class GizmoScaledAndUnscaledTransformSources extends GizmoBaseTransformSource { 
	ScaledTransformSource: any;
	UnscaledTransformSource: any;
	static Load(ResourceName: string): GizmoScaledAndUnscaledTransformSources;
	static Find(Outer: UObject, ResourceName: string): GizmoScaledAndUnscaledTransformSources;
	static GetDefaultObject(): GizmoScaledAndUnscaledTransformSources;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoScaledAndUnscaledTransformSources;
	static C(Other: UObject | any): GizmoScaledAndUnscaledTransformSources;
}

declare class GizmoEditorAxisSource extends UObject { 
	AxisIndex: number;
	bLocalAxes: boolean;
	static Load(ResourceName: string): GizmoEditorAxisSource;
	static Find(Outer: UObject, ResourceName: string): GizmoEditorAxisSource;
	static GetDefaultObject(): GizmoEditorAxisSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoEditorAxisSource;
	static C(Other: UObject | any): GizmoEditorAxisSource;
}

declare class EditorInteractiveGizmoConditionalBuilder extends Interface { 
	static Load(ResourceName: string): EditorInteractiveGizmoConditionalBuilder;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoConditionalBuilder;
	static GetDefaultObject(): EditorInteractiveGizmoConditionalBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoConditionalBuilder;
	static C(Other: UObject | any): EditorInteractiveGizmoConditionalBuilder;
}

declare class EditorInteractiveGizmoRegistry extends UObject { 
	GizmoCategoryMap: any;
	static Load(ResourceName: string): EditorInteractiveGizmoRegistry;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoRegistry;
	static GetDefaultObject(): EditorInteractiveGizmoRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoRegistry;
	static C(Other: UObject | any): EditorInteractiveGizmoRegistry;
}

declare class ActiveEditorGizmo { 
	Gizmo: InteractiveGizmo;
	clone() : ActiveEditorGizmo;
	static C(Other: UObject | any): ActiveEditorGizmo;
}

declare class EditorInteractiveGizmoManager extends InteractiveGizmoManager { 
	Registry: EditorInteractiveGizmoRegistry;
	ActiveEditorGizmos: ActiveEditorGizmo[];
	CachedGizmoMap: any;
	static Load(ResourceName: string): EditorInteractiveGizmoManager;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoManager;
	static GetDefaultObject(): EditorInteractiveGizmoManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoManager;
	static C(Other: UObject | any): EditorInteractiveGizmoManager;
}

declare class EditorGizmoRegistryCategoryEntry extends UObject { 
	GizmoTypes: InteractiveGizmoBuilder[];
	CategoryName: string;
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry;
}

declare class EditorGizmoRegistryCategoryEntry_ConditionalSelection extends EditorGizmoRegistryCategoryEntry { 
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry_ConditionalSelection;
}

declare class EditorGizmoRegistryCategoryEntry_Primary extends EditorGizmoRegistryCategoryEntry_ConditionalSelection { 
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry_Primary;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry_Primary;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry_Primary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry_Primary;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry_Primary;
}

declare class EditorGizmoRegistryCategoryEntry_Accessory extends EditorGizmoRegistryCategoryEntry_ConditionalSelection { 
	static Load(ResourceName: string): EditorGizmoRegistryCategoryEntry_Accessory;
	static Find(Outer: UObject, ResourceName: string): EditorGizmoRegistryCategoryEntry_Accessory;
	static GetDefaultObject(): EditorGizmoRegistryCategoryEntry_Accessory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorGizmoRegistryCategoryEntry_Accessory;
	static C(Other: UObject | any): EditorGizmoRegistryCategoryEntry_Accessory;
}

declare class EditorInteractiveGizmoSelectionBuilder extends Interface { 
	static Load(ResourceName: string): EditorInteractiveGizmoSelectionBuilder;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoSelectionBuilder;
	static GetDefaultObject(): EditorInteractiveGizmoSelectionBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoSelectionBuilder;
	static C(Other: UObject | any): EditorInteractiveGizmoSelectionBuilder;
}

declare class EditorInteractiveGizmoSubsystem extends EditorSubsystem { 
	TransformGizmoBuilder: InteractiveGizmoBuilder;
	Registry: EditorInteractiveGizmoRegistry;
	static Load(ResourceName: string): EditorInteractiveGizmoSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveGizmoSubsystem;
	static GetDefaultObject(): EditorInteractiveGizmoSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveGizmoSubsystem;
	static C(Other: UObject | any): EditorInteractiveGizmoSubsystem;
}

declare class GizmoEditorAxisTranslationParameterSource extends GizmoBaseFloatParameterSource { 
	AxisSource: any;
	Parameter: number;
	LastChange: GizmoFloatParameterChange;
	CurTranslationAxis: Vector;
	CurTranslationOrigin: Vector;
	LastPivotLocation: Vector;
	LastSnappedLocation: Vector;
	static Load(ResourceName: string): GizmoEditorAxisTranslationParameterSource;
	static Find(Outer: UObject, ResourceName: string): GizmoEditorAxisTranslationParameterSource;
	static GetDefaultObject(): GizmoEditorAxisTranslationParameterSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoEditorAxisTranslationParameterSource;
	static C(Other: UObject | any): GizmoEditorAxisTranslationParameterSource;
}

declare class EditorTransformGizmoBuilder extends InteractiveGizmoBuilder { 
	static Load(ResourceName: string): EditorTransformGizmoBuilder;
	static Find(Outer: UObject, ResourceName: string): EditorTransformGizmoBuilder;
	static GetDefaultObject(): EditorTransformGizmoBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTransformGizmoBuilder;
	static C(Other: UObject | any): EditorTransformGizmoBuilder;
}

declare class GizmoBaseObject extends UObject { 
	LocalToWorldTransform: Transform;
	Material: MaterialInterface;
	CurrentMaterial: MaterialInterface;
	GizmoScale: number;
	PixelHitDistanceThreshold: number;
	static Load(ResourceName: string): GizmoBaseObject;
	static Find(Outer: UObject, ResourceName: string): GizmoBaseObject;
	static GetDefaultObject(): GizmoBaseObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBaseObject;
	SetWorldLocalState(bWorldIn: boolean): void;
	SetVisibility(bVisibleIn: boolean): void;
	SetMaterial(InMaterial: MaterialInterface): void;
	SetLocalToWorldTransform(LocalToWorldTransformIn: Transform): void;
	SetInteractingState(bInteractingIn: boolean): void;
	SetHoverState(bHoveringIn: boolean): void;
	SetGizmoScale(InGizmoScale: number): void;
	SetCurrentMaterial(InCurrentMaterial: MaterialInterface): void;
	GetWorldLocalState(): boolean;
	GetVisibility(): boolean;
	GetMaterial(): MaterialInterface;
	GetLocalToWorldTransform(): Transform;
	GetInteractingState(): boolean;
	GetHoverState(): boolean;
	GetGizmoScale(): number;
	GetCurrentMaterial(): MaterialInterface;
	static C(Other: UObject | any): GizmoBaseObject;
}

declare class GizmoGroupObject extends GizmoBaseObject { 
	Objects: GizmoBaseObject[];
	static Load(ResourceName: string): GizmoGroupObject;
	static Find(Outer: UObject, ResourceName: string): GizmoGroupObject;
	static GetDefaultObject(): GizmoGroupObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoGroupObject;
	static C(Other: UObject | any): GizmoGroupObject;
}

declare class GizmoCylinderObject extends GizmoBaseObject { 
	Direction: Vector;
	Length: any;
	Offset: any;
	Radius: any;
	NumSides: number;
	static Load(ResourceName: string): GizmoCylinderObject;
	static Find(Outer: UObject, ResourceName: string): GizmoCylinderObject;
	static GetDefaultObject(): GizmoCylinderObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoCylinderObject;
	static C(Other: UObject | any): GizmoCylinderObject;
}

declare class GizmoConeObject extends GizmoBaseObject { 
	Direction: Vector;
	Height: any;
	Offset: any;
	Angle: any;
	NumSides: number;
	static Load(ResourceName: string): GizmoConeObject;
	static Find(Outer: UObject, ResourceName: string): GizmoConeObject;
	static GetDefaultObject(): GizmoConeObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoConeObject;
	static C(Other: UObject | any): GizmoConeObject;
}

declare class GizmoBoxObject extends GizmoBaseObject { 
	Dimensions: Vector;
	UpDirection: Vector;
	SideDirection: Vector;
	Offset: number;
	static Load(ResourceName: string): GizmoBoxObject;
	static Find(Outer: UObject, ResourceName: string): GizmoBoxObject;
	static GetDefaultObject(): GizmoBoxObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoBoxObject;
	static C(Other: UObject | any): GizmoBoxObject;
}

declare class GizmoArrowObject extends GizmoBaseObject { 
	bHasConeHead: number;
	Direction: Vector;
	Offset: number;
	CylinderObject: GizmoCylinderObject;
	ConeObject: GizmoConeObject;
	BoxObject: GizmoBoxObject;
	static Load(ResourceName: string): GizmoArrowObject;
	static Find(Outer: UObject, ResourceName: string): GizmoArrowObject;
	static GetDefaultObject(): GizmoArrowObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoArrowObject;
	static C(Other: UObject | any): GizmoArrowObject;
}

declare class GizmoObjectTransformChangeStateTarget extends UObject { 
	TransactionManager: any;
	static Load(ResourceName: string): GizmoObjectTransformChangeStateTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectTransformChangeStateTarget;
	static GetDefaultObject(): GizmoObjectTransformChangeStateTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectTransformChangeStateTarget;
	static C(Other: UObject | any): GizmoObjectTransformChangeStateTarget;
}

declare class EditorTransformGizmo extends InteractiveGizmo { 
	ActiveTarget: TransformProxy;
	bSnapToWorldGrid: boolean;
	bGridSizeIsExplicit: boolean;
	ExplicitGridSize: Vector;
	bRotationGridSizeIsExplicit: boolean;
	ExplicitRotationGridSize: Rotator;
	bSnapToWorldRotGrid: boolean;
	bUseContextCoordinateSystem: boolean;
	CurrentCoordinateSystem: EToolContextCoordinateSystem;
	ActiveObjects: GizmoBaseObject[];
	NonuniformScaleObjects: GizmoBaseObject[];
	ActiveGizmos: InteractiveGizmo[];
	CameraAxisSource: GizmoConstantFrameAxisSource;
	GizmoGroupObject: GizmoGroupObject;
	AxisXSource: GizmoEditorAxisSource;
	AxisYSource: GizmoEditorAxisSource;
	AxisZSource: GizmoEditorAxisSource;
	AxisXObject: GizmoArrowObject;
	AxisYObject: GizmoArrowObject;
	AxisZObject: GizmoArrowObject;
	UnitAxisXSource: GizmoEditorAxisSource;
	UnitAxisYSource: GizmoEditorAxisSource;
	UnitAxisZSource: GizmoEditorAxisSource;
	StateTarget: GizmoObjectTransformChangeStateTarget;
	static Load(ResourceName: string): EditorTransformGizmo;
	static Find(Outer: UObject, ResourceName: string): EditorTransformGizmo;
	static GetDefaultObject(): EditorTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTransformGizmo;
	static C(Other: UObject | any): EditorTransformGizmo;
}

declare class EditorInteractiveToolsContext extends InteractiveToolsContext { 
	StandardVertexColorMaterial: MaterialInterface;
	static Load(ResourceName: string): EditorInteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): EditorInteractiveToolsContext;
	static GetDefaultObject(): EditorInteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorInteractiveToolsContext;
	static C(Other: UObject | any): EditorInteractiveToolsContext;
}

declare class EdModeInteractiveToolsContext extends EditorInteractiveToolsContext { 
	ParentModeManagerToolsContext: ModeManagerInteractiveToolsContext;
	static Load(ResourceName: string): EdModeInteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): EdModeInteractiveToolsContext;
	static GetDefaultObject(): EdModeInteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdModeInteractiveToolsContext;
	static C(Other: UObject | any): EdModeInteractiveToolsContext;
}

declare class ModeManagerInteractiveToolsContext extends EditorInteractiveToolsContext { 
	EdModeToolsContexts: EdModeInteractiveToolsContext[];
	static Load(ResourceName: string): ModeManagerInteractiveToolsContext;
	static Find(Outer: UObject, ResourceName: string): ModeManagerInteractiveToolsContext;
	static GetDefaultObject(): ModeManagerInteractiveToolsContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModeManagerInteractiveToolsContext;
	static C(Other: UObject | any): ModeManagerInteractiveToolsContext;
}

declare class GizmoObjectHitTarget extends UObject { 
	GizmoObject: GizmoBaseObject;
	static Load(ResourceName: string): GizmoObjectHitTarget;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectHitTarget;
	static GetDefaultObject(): GizmoObjectHitTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectHitTarget;
	static C(Other: UObject | any): GizmoObjectHitTarget;
}

declare class GizmoObjectWorldTransformSource extends GizmoBaseTransformSource { 
	UObject: GizmoBaseObject;
	bModifyObjectOnTransform: boolean;
	static Load(ResourceName: string): GizmoObjectWorldTransformSource;
	static Find(Outer: UObject, ResourceName: string): GizmoObjectWorldTransformSource;
	static GetDefaultObject(): GizmoObjectWorldTransformSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoObjectWorldTransformSource;
	static C(Other: UObject | any): GizmoObjectWorldTransformSource;
}

declare class PIEPreviewSettings extends UObject { 
	WindowPosX: number;
	WindowPosY: number;
	WindowScalingFactor: number;
	static Load(ResourceName: string): PIEPreviewSettings;
	static Find(Outer: UObject, ResourceName: string): PIEPreviewSettings;
	static GetDefaultObject(): PIEPreviewSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PIEPreviewSettings;
	static C(Other: UObject | any): PIEPreviewSettings;
}

declare type EMovieSceneCaptureProtocolState = 'Idle' | 'Initialized' | 'Capturing' | 'Finalizing' | 'EMovieSceneCaptureProtocolState_MAX';
declare var EMovieSceneCaptureProtocolState : { Idle:'Idle',Initialized:'Initialized',Capturing:'Capturing',Finalizing:'Finalizing',EMovieSceneCaptureProtocolState_MAX:'EMovieSceneCaptureProtocolState_MAX', };
declare class MovieSceneCaptureProtocolBase extends UObject { 
	State: EMovieSceneCaptureProtocolState;
	static Load(ResourceName: string): MovieSceneCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureProtocolBase;
	IsCapturing(): boolean;
	GetState(): EMovieSceneCaptureProtocolState;
	static C(Other: UObject | any): MovieSceneCaptureProtocolBase;
}

declare class MovieSceneAudioCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneAudioCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneAudioCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneAudioCaptureProtocolBase;
}

declare class NullAudioCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	static Load(ResourceName: string): NullAudioCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): NullAudioCaptureProtocol;
	static GetDefaultObject(): NullAudioCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullAudioCaptureProtocol;
	static C(Other: UObject | any): NullAudioCaptureProtocol;
}

declare class MasterAudioSubmixCaptureProtocol extends MovieSceneAudioCaptureProtocolBase { 
	Filename: string;
	static Load(ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): MasterAudioSubmixCaptureProtocol;
	static GetDefaultObject(): MasterAudioSubmixCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MasterAudioSubmixCaptureProtocol;
	static C(Other: UObject | any): MasterAudioSubmixCaptureProtocol;
}

declare class MovieSceneImageCaptureProtocolBase extends MovieSceneCaptureProtocolBase { 
	static Load(ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneImageCaptureProtocolBase;
	static GetDefaultObject(): MovieSceneImageCaptureProtocolBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneImageCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneImageCaptureProtocolBase;
}

declare class CompositionGraphCapturePasses { 
	Value: string[];
	clone() : CompositionGraphCapturePasses;
	static C(Other: UObject | any): CompositionGraphCapturePasses;
}

declare type EHDRCaptureGamut = 'HCGM_Rec709' | 'HCGM_P3DCI' | 'HCGM_Rec2020' | 'HCGM_ACES' | 'HCGM_ACEScg' | 'HCGM_Linear' | 'HCGM_MAX';
declare var EHDRCaptureGamut : { HCGM_Rec709:'HCGM_Rec709',HCGM_P3DCI:'HCGM_P3DCI',HCGM_Rec2020:'HCGM_Rec2020',HCGM_ACES:'HCGM_ACES',HCGM_ACEScg:'HCGM_ACEScg',HCGM_Linear:'HCGM_Linear',HCGM_MAX:'HCGM_MAX', };
declare class CompositionGraphCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	IncludeRenderPasses: CompositionGraphCapturePasses;
	bCaptureFramesInHDR: boolean;
	HDRCompressionQuality: number;
	CaptureGamut: EHDRCaptureGamut;
	PostProcessingMaterial: SoftObjectPath;
	bDisableScreenPercentage: boolean;
	PostProcessingMaterialPtr: MaterialInterface;
	static Load(ResourceName: string): CompositionGraphCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): CompositionGraphCaptureProtocol;
	static GetDefaultObject(): CompositionGraphCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositionGraphCaptureProtocol;
	static C(Other: UObject | any): CompositionGraphCaptureProtocol;
}

declare class FrameGrabberProtocol extends MovieSceneImageCaptureProtocolBase { 
	static Load(ResourceName: string): FrameGrabberProtocol;
	static Find(Outer: UObject, ResourceName: string): FrameGrabberProtocol;
	static GetDefaultObject(): FrameGrabberProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FrameGrabberProtocol;
	static C(Other: UObject | any): FrameGrabberProtocol;
}

declare class ImageSequenceProtocol extends FrameGrabberProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol;
	static GetDefaultObject(): ImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol;
	static C(Other: UObject | any): ImageSequenceProtocol;
}

declare class CompressedImageSequenceProtocol extends ImageSequenceProtocol { 
	CompressionQuality: number;
	static Load(ResourceName: string): CompressedImageSequenceProtocol;
	static Find(Outer: UObject, ResourceName: string): CompressedImageSequenceProtocol;
	static GetDefaultObject(): CompressedImageSequenceProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompressedImageSequenceProtocol;
	static C(Other: UObject | any): CompressedImageSequenceProtocol;
}

declare class ImageSequenceProtocol_BMP extends ImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_BMP;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_BMP;
	static GetDefaultObject(): ImageSequenceProtocol_BMP;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_BMP;
	static C(Other: UObject | any): ImageSequenceProtocol_BMP;
}

declare class ImageSequenceProtocol_PNG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_PNG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_PNG;
	static GetDefaultObject(): ImageSequenceProtocol_PNG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_PNG;
	static C(Other: UObject | any): ImageSequenceProtocol_PNG;
}

declare class ImageSequenceProtocol_JPG extends CompressedImageSequenceProtocol { 
	static Load(ResourceName: string): ImageSequenceProtocol_JPG;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_JPG;
	static GetDefaultObject(): ImageSequenceProtocol_JPG;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_JPG;
	static C(Other: UObject | any): ImageSequenceProtocol_JPG;
}

declare class ImageSequenceProtocol_EXR extends ImageSequenceProtocol { 
	bCompressed: boolean;
	CaptureGamut: EHDRCaptureGamut;
	static Load(ResourceName: string): ImageSequenceProtocol_EXR;
	static Find(Outer: UObject, ResourceName: string): ImageSequenceProtocol_EXR;
	static GetDefaultObject(): ImageSequenceProtocol_EXR;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageSequenceProtocol_EXR;
	static C(Other: UObject | any): ImageSequenceProtocol_EXR;
}

declare class MovieSceneCaptureInterface extends Interface { 
	static Load(ResourceName: string): MovieSceneCaptureInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureInterface;
	static GetDefaultObject(): MovieSceneCaptureInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureInterface;
	static C(Other: UObject | any): MovieSceneCaptureInterface;
}

declare class CaptureResolution { 
	ResX: number;
	ResY: number;
	clone() : CaptureResolution;
	static C(Other: UObject | any): CaptureResolution;
}

declare class MovieSceneCaptureSettings { 
	OutputDirectory: DirectoryPath;
	GameModeOverride: UnrealEngineClass;
	OutputFormat: string;
	bOverwriteExisting: boolean;
	bUseRelativeFrameNumbers: boolean;
	HandleFrames: number;
	MovieExtension: string;
	ZeroPadFrameNumbers: number;
	FrameRate: FrameRate;
	bUseCustomFrameRate: boolean;
	CustomFrameRate: FrameRate;
	Resolution: CaptureResolution;
	bEnableTextureStreaming: boolean;
	bCinematicEngineScalability: boolean;
	bCinematicMode: boolean;
	bAllowMovement: boolean;
	bAllowTurning: boolean;
	bShowPlayer: boolean;
	bShowHUD: boolean;
	bUsePathTracer: boolean;
	PathTracerSamplePerPixel: number;
	clone() : MovieSceneCaptureSettings;
	static C(Other: UObject | any): MovieSceneCaptureSettings;
}

declare class MovieSceneCapture extends UObject { 
	ImageCaptureProtocolType: SoftClassPath;
	AudioCaptureProtocolType: SoftClassPath;
	ImageCaptureProtocol: MovieSceneImageCaptureProtocolBase;
	AudioCaptureProtocol: MovieSceneAudioCaptureProtocolBase;
	Settings: MovieSceneCaptureSettings;
	bUseSeparateProcess: boolean;
	bCloseEditorWhenCaptureStarts: boolean;
	AdditionalCommandLineArguments: string;
	InheritedCommandLineArguments: string;
	static Load(ResourceName: string): MovieSceneCapture;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCapture;
	static GetDefaultObject(): MovieSceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCapture;
	SetImageCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	SetAudioCaptureProtocolType(ProtocolType: UnrealEngineClass): void;
	GetImageCaptureProtocol(): MovieSceneCaptureProtocolBase;
	GetAudioCaptureProtocol(): MovieSceneCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCapture;
	RenderMovie(OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
	static RenderMovie(InCaptureSettings: MovieSceneCapture,OnFinishedCallback: UnrealEngineDelegate<(bSuccess: boolean) => void>): boolean;
}

declare class LevelCapture extends MovieSceneCapture { 
	bAutoStartCapture: boolean;
	PrerequisiteActorId: Guid;
	static Load(ResourceName: string): LevelCapture;
	static Find(Outer: UObject, ResourceName: string): LevelCapture;
	static GetDefaultObject(): LevelCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelCapture;
	static C(Other: UObject | any): LevelCapture;
}

declare class MovieSceneCaptureEnvironment extends UObject { 
	static Load(ResourceName: string): MovieSceneCaptureEnvironment;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureEnvironment;
	static GetDefaultObject(): MovieSceneCaptureEnvironment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureEnvironment;
	static IsCaptureInProgress(): boolean;
	static GetCaptureFrameNumber(): number;
	static GetCaptureElapsedTime(): number;
	static FindImageCaptureProtocol(): MovieSceneImageCaptureProtocolBase;
	static FindAudioCaptureProtocol(): MovieSceneAudioCaptureProtocolBase;
	static C(Other: UObject | any): MovieSceneCaptureEnvironment;
}

declare class CapturedPixelsID { 
	Identifiers: any;
	clone() : CapturedPixelsID;
	static C(Other: UObject | any): CapturedPixelsID;
}

declare class CapturedPixels { 
	clone() : CapturedPixels;
	static C(Other: UObject | any): CapturedPixels;
}

declare class FrameMetrics { 
	TotalElapsedTime: number;
	FrameDelta: number;
	FrameNumber: number;
	NumDroppedFrames: number;
	clone() : FrameMetrics;
	static C(Other: UObject | any): FrameMetrics;
}

declare class UserDefinedCaptureProtocol extends MovieSceneImageCaptureProtocolBase { 
	World: World;
	static Load(ResourceName: string): UserDefinedCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedCaptureProtocol;
	static GetDefaultObject(): UserDefinedCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedCaptureProtocol;
	StopCapturingFinalPixels(): void;
	StartCapturingFinalPixels(StreamID: CapturedPixelsID): void;
	ResolveBuffer(Buffer: Texture,BufferID: CapturedPixelsID): void;
	OnWarmUp(): void;
	OnTick(): void;
	OnStartCapture(): void;
	OnSetup(): boolean;
	OnPreTick(): void;
	OnPixelsReceived(Pixels: CapturedPixels,ID: CapturedPixelsID,FrameMetrics: FrameMetrics): void;
	OnPauseCapture(): void;
	OnFinalize(): void;
	OnCaptureFrame(): void;
	OnCanFinalize(): boolean;
	OnBeginFinalize(): void;
	GetCurrentFrameMetrics(): FrameMetrics;
	GenerateFilename(InFrameMetrics: FrameMetrics): string;
	static C(Other: UObject | any): UserDefinedCaptureProtocol;
}

declare class UserDefinedImageCaptureProtocol extends UserDefinedCaptureProtocol { 
	Format: EDesiredImageFormat;
	bEnableCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): UserDefinedImageCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): UserDefinedImageCaptureProtocol;
	static GetDefaultObject(): UserDefinedImageCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedImageCaptureProtocol;
	WriteImageToDisk(PixelData: CapturedPixels,StreamID: CapturedPixelsID,FrameMetrics: FrameMetrics,bCopyImageData: boolean): void;
	GenerateFilenameForCurrentFrame(): string;
	GenerateFilenameForBuffer(Buffer: Texture,StreamID: CapturedPixelsID): string;
	static C(Other: UObject | any): UserDefinedImageCaptureProtocol;
}

declare class VideoCaptureProtocol extends FrameGrabberProtocol { 
	bUseCompression: boolean;
	CompressionQuality: number;
	static Load(ResourceName: string): VideoCaptureProtocol;
	static Find(Outer: UObject, ResourceName: string): VideoCaptureProtocol;
	static GetDefaultObject(): VideoCaptureProtocol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VideoCaptureProtocol;
	static C(Other: UObject | any): VideoCaptureProtocol;
}

declare class SequenceRecordingBase extends UObject { 
	static Load(ResourceName: string): SequenceRecordingBase;
	static Find(Outer: UObject, ResourceName: string): SequenceRecordingBase;
	static GetDefaultObject(): SequenceRecordingBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecordingBase;
	static C(Other: UObject | any): SequenceRecordingBase;
}

declare class ActorRecordingSettings { 
	Settings: UObject[];
	clone() : ActorRecordingSettings;
	static C(Other: UObject | any): ActorRecordingSettings;
}

declare class AnimationRecordingSettings { 
	bRecordInWorldSpace: boolean;
	bRemoveRootAnimation: boolean;
	bAutoSaveAsset: boolean;
	SampleFrameRate: FrameRate;
	Length: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	bRecordTransforms: boolean;
	bRecordMorphTargets: boolean;
	bRecordAttributeCurves: boolean;
	bRecordMaterialCurves: boolean;
	clone() : AnimationRecordingSettings;
	static C(Other: UObject | any): AnimationRecordingSettings;
}

declare class ActorRecording extends SequenceRecordingBase { 
	ActorSettings: ActorRecordingSettings;
	bActive: boolean;
	bCreateLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	TargetName: string;
	TakeNumber: any;
	bSpecifyTargetAnimation: boolean;
	TargetAnimation: AnimSequence;
	AnimationSettings: AnimationRecordingSettings;
	bRecordToPossessable: boolean;
	ActorToRecord: Actor;
	static Load(ResourceName: string): ActorRecording;
	static Find(Outer: UObject, ResourceName: string): ActorRecording;
	static GetDefaultObject(): ActorRecording;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorRecording;
	static C(Other: UObject | any): ActorRecording;
}

declare class AnimationRecordingParameters extends UObject { 
	SampleFrameRate: FrameRate;
	bEndAfterDuration: boolean;
	MaximumDurationSeconds: number;
	SampleRate: number;
	static Load(ResourceName: string): AnimationRecordingParameters;
	static Find(Outer: UObject, ResourceName: string): AnimationRecordingParameters;
	static GetDefaultObject(): AnimationRecordingParameters;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationRecordingParameters;
	static C(Other: UObject | any): AnimationRecordingParameters;
}

declare class MovieScene3DTransformSectionRecorderSettings extends UObject { 
	bRecordTransforms: boolean;
	static Load(ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static GetDefaultObject(): MovieScene3DTransformSectionRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionRecorderSettings;
	static C(Other: UObject | any): MovieScene3DTransformSectionRecorderSettings;
}

declare class SequenceRecorderActorGroup extends UObject { 
	GroupName: string;
	SequenceName: string;
	SequenceRecordingBasePath: DirectoryPath;
	bSpecifyTargetLevelSequence: boolean;
	TargetLevelSequence: LevelSequence;
	bDuplicateTargetLevelSequence: boolean;
	bRecordTargetLevelSequenceLength: boolean;
	RecordedActors: ActorRecording[];
	static Load(ResourceName: string): SequenceRecorderActorGroup;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderActorGroup;
	static GetDefaultObject(): SequenceRecorderActorGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderActorGroup;
	static C(Other: UObject | any): SequenceRecorderActorGroup;
}

declare class SequenceRecorderGroup extends Actor { 
	ActorGroups: SequenceRecorderActorGroup[];
	static GetDefaultObject(): SequenceRecorderGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderGroup;
	static C(Other: UObject | any): SequenceRecorderGroup;
}

declare class BlueprintFunctionLibrary extends UObject { 
	static Load(ResourceName: string): BlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionLibrary;
	static GetDefaultObject(): BlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionLibrary;
	static C(Other: UObject | any): BlueprintFunctionLibrary;
}

declare class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceRecorderBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderBlueprintLibrary;
	static GetDefaultObject(): SequenceRecorderBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderBlueprintLibrary;
	static StopRecordingSequence(): void;
	static StartRecordingSequence(ActorsToRecord: Actor[]): void;
	static IsRecordingSequence(): boolean;
	static C(Other: UObject | any): SequenceRecorderBlueprintLibrary;
}

declare type EAudioRecordingMode = 'None' | 'AudioTrack' | 'EAudioRecordingMode_MAX';
declare var EAudioRecordingMode : { None:'None',AudioTrack:'AudioTrack',EAudioRecordingMode_MAX:'EAudioRecordingMode_MAX', };
declare class SequenceRecorderActorFilter { 
	ActorClassesToRecord: UnrealEngineClass[];
	clone() : SequenceRecorderActorFilter;
	static C(Other: UObject | any): SequenceRecorderActorFilter;
}

declare class PropertiesToRecordForClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForClass;
	static C(Other: UObject | any): PropertiesToRecordForClass;
}

declare class PropertiesToRecordForActorClass { 
	Class: UnrealEngineClass;
	Properties: string[];
	clone() : PropertiesToRecordForActorClass;
	static C(Other: UObject | any): PropertiesToRecordForActorClass;
}

declare class SettingsForActorClass { 
	Class: UnrealEngineClass;
	bRecordToPossessable: boolean;
	clone() : SettingsForActorClass;
	static C(Other: UObject | any): SettingsForActorClass;
}

declare class SequenceRecorderSettings extends UObject { 
	bCreateLevelSequence: boolean;
	bImmersiveMode: boolean;
	SequenceLength: number;
	RecordingDelay: number;
	bAllowLooping: boolean;
	GlobalTimeDilation: number;
	bIgnoreTimeDilation: boolean;
	AnimationSubDirectory: string;
	RecordAudio: EAudioRecordingMode;
	AudioGain: number;
	bSplitAudioChannelsIntoSeparateTracks: boolean;
	bReplaceRecordedAudio: boolean;
	AudioTrackName: string;
	AudioSubDirectory: string;
	bRecordNearbySpawnedActors: boolean;
	NearbyActorRecordingProximity: number;
	bRecordWorldSettingsActor: boolean;
	bReduceKeys: boolean;
	bAutoSaveAsset: boolean;
	ActorFilter: SequenceRecorderActorFilter;
	LevelSequenceActorsToTrigger: any[];
	DefaultAnimationSettings: AnimationRecordingSettings;
	bRecordSequencerSpawnedActors: boolean;
	ClassesAndPropertiesToRecord: PropertiesToRecordForClass[];
	ActorsAndPropertiesToRecord: PropertiesToRecordForActorClass[];
	PerActorSettings: SettingsForActorClass[];
	static Load(ResourceName: string): SequenceRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderSettings;
	static GetDefaultObject(): SequenceRecorderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderSettings;
	static C(Other: UObject | any): SequenceRecorderSettings;
}

declare class LevelSequenceBurnInInitSettings extends UObject { 
	static Load(ResourceName: string): LevelSequenceBurnInInitSettings;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInInitSettings;
	static GetDefaultObject(): LevelSequenceBurnInInitSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInInitSettings;
	static C(Other: UObject | any): LevelSequenceBurnInInitSettings;
}

declare class LevelSequenceBurnInOptions extends UObject { 
	bUseBurnIn: boolean;
	BurnInClass: SoftClassPath;
	Settings: LevelSequenceBurnInInitSettings;
	static Load(ResourceName: string): LevelSequenceBurnInOptions;
	static Find(Outer: UObject, ResourceName: string): LevelSequenceBurnInOptions;
	static GetDefaultObject(): LevelSequenceBurnInOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequenceBurnInOptions;
	SetBurnIn(InBurnInClass: SoftClassPath): void;
	static C(Other: UObject | any): LevelSequenceBurnInOptions;
}

declare class AutomatedLevelSequenceCapture extends MovieSceneCapture { 
	LevelSequenceAsset: SoftObjectPath;
	ShotName: string;
	bUseCustomStartFrame: boolean;
	CustomStartFrame: FrameNumber;
	bUseCustomEndFrame: boolean;
	CustomEndFrame: FrameNumber;
	WarmUpFrameCount: number;
	DelayBeforeWarmUp: number;
	DelayBeforeShotWarmUp: number;
	DelayEveryFrame: number;
	BurnInOptions: LevelSequenceBurnInOptions;
	bWriteEditDecisionList: boolean;
	bWriteFinalCutProXML: boolean;
	LevelSequenceActor: any;
	static Load(ResourceName: string): AutomatedLevelSequenceCapture;
	static Find(Outer: UObject, ResourceName: string): AutomatedLevelSequenceCapture;
	static GetDefaultObject(): AutomatedLevelSequenceCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedLevelSequenceCapture;
	static C(Other: UObject | any): AutomatedLevelSequenceCapture;
}

declare class BoolChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	bValue: boolean;
	static Load(ResourceName: string): BoolChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): BoolChannelKeyProxy;
	static GetDefaultObject(): BoolChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolChannelKeyProxy;
	static C(Other: UObject | any): BoolChannelKeyProxy;
}

declare class MovieSceneDoubleValue { 
	Value: any;
	Tangent: MovieSceneTangentData;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	PaddingByte: number;
	clone() : MovieSceneDoubleValue;
	static C(Other: UObject | any): MovieSceneDoubleValue;
}

declare class DoubleChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneDoubleValue;
	static Load(ResourceName: string): DoubleChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): DoubleChannelKeyProxy;
	static GetDefaultObject(): DoubleChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DoubleChannelKeyProxy;
	static C(Other: UObject | any): DoubleChannelKeyProxy;
}

declare class FloatChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: MovieSceneFloatValue;
	static Load(ResourceName: string): FloatChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): FloatChannelKeyProxy;
	static GetDefaultObject(): FloatChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatChannelKeyProxy;
	static C(Other: UObject | any): FloatChannelKeyProxy;
}

declare class IntegerChannelKeyProxy extends UObject { 
	Time: FrameNumber;
	Value: number;
	static Load(ResourceName: string): IntegerChannelKeyProxy;
	static Find(Outer: UObject, ResourceName: string): IntegerChannelKeyProxy;
	static GetDefaultObject(): IntegerChannelKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntegerChannelKeyProxy;
	static C(Other: UObject | any): IntegerChannelKeyProxy;
}

declare class K2Node_GetSequenceBinding extends K2Node { 
	SourceSequence: SoftObjectPath;
	Binding: MovieSceneObjectBindingID;
	static Load(ResourceName: string): K2Node_GetSequenceBinding;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSequenceBinding;
	static GetDefaultObject(): K2Node_GetSequenceBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSequenceBinding;
	static C(Other: UObject | any): K2Node_GetSequenceBinding;
}

declare class MovieSceneEventBlueprintExtension extends BlueprintExtension { 
	EventSections: any[];
	static Load(ResourceName: string): MovieSceneEventBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEventBlueprintExtension;
	static GetDefaultObject(): MovieSceneEventBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventBlueprintExtension;
	static C(Other: UObject | any): MovieSceneEventBlueprintExtension;
}

declare class MovieSceneToolsPropertyTrackSettings { 
	ComponentName: string;
	PropertyName: string;
	clone() : MovieSceneToolsPropertyTrackSettings;
	static C(Other: UObject | any): MovieSceneToolsPropertyTrackSettings;
}

declare type EMovieSceneToolsPropertyTrackType = 'FloatTrack' | 'DoubleTrack' | 'EMovieSceneToolsPropertyTrackType_MAX';
declare var EMovieSceneToolsPropertyTrackType : { FloatTrack:'FloatTrack',DoubleTrack:'DoubleTrack',EMovieSceneToolsPropertyTrackType_MAX:'EMovieSceneToolsPropertyTrackType_MAX', };
declare class MovieSceneToolsFbxSettings { 
	FbxPropertyName: string;
	PropertyPath: MovieSceneToolsPropertyTrackSettings;
	PropertyType: EMovieSceneToolsPropertyTrackType;
	clone() : MovieSceneToolsFbxSettings;
	static C(Other: UObject | any): MovieSceneToolsFbxSettings;
}

declare class MovieSceneToolsProjectSettings extends UObject { 
	DefaultStartTime: number;
	DefaultDuration: number;
	ShotDirectory: string;
	ShotPrefix: string;
	FirstShotNumber: any;
	ShotIncrement: any;
	ShotNumDigits: any;
	TakeNumDigits: any;
	FirstTakeNumber: any;
	TakeSeparator: string;
	SubSequenceSeparator: string;
	FbxSettings: MovieSceneToolsFbxSettings[];
	static Load(ResourceName: string): MovieSceneToolsProjectSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneToolsProjectSettings;
	static GetDefaultObject(): MovieSceneToolsProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneToolsProjectSettings;
	static C(Other: UObject | any): MovieSceneToolsProjectSettings;
}

declare type EThumbnailQuality = 'Draft' | 'Normal' | 'Best' | 'EThumbnailQuality_MAX';
declare var EThumbnailQuality : { Draft:'Draft',Normal:'Normal',Best:'Best',EThumbnailQuality_MAX:'EThumbnailQuality_MAX', };
declare class MovieSceneUserThumbnailSettings extends UObject { 
	bDrawThumbnails: boolean;
	bDrawSingleThumbnails: boolean;
	ThumbnailSize: IntPoint;
	Quality: EThumbnailQuality;
	static Load(ResourceName: string): MovieSceneUserThumbnailSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserThumbnailSettings;
	static GetDefaultObject(): MovieSceneUserThumbnailSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserThumbnailSettings;
	static C(Other: UObject | any): MovieSceneUserThumbnailSettings;
}

declare class InterchangeAssetImportData extends AssetImportData { 
	NodeContainer: InterchangeBaseNodeContainer;
	NodeUniqueID: string;
	Pipelines: InterchangePipelineBase[];
	static Load(ResourceName: string): InterchangeAssetImportData;
	static Find(Outer: UObject, ResourceName: string): InterchangeAssetImportData;
	static GetDefaultObject(): InterchangeAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeAssetImportData;
	ScriptGetFirstFilename(): string;
	ScriptExtractFilenames(): string[];
	ScriptExtractDisplayLabels(): string[];
	static C(Other: UObject | any): InterchangeAssetImportData;
}

declare class ImportAssetParameters { 
	ReimportAsset: UObject;
	bIsAutomated: boolean;
	OverridePipelines: InterchangePipelineBase[];
	OnAssetDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnAssetsImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	OnSceneObjectDone: UnrealEngineDelegate<(UObject: UObject) => void>;
	OnSceneImportDone: UnrealEngineDelegate<(Objects: UObject[]) => void>;
	clone() : ImportAssetParameters;
	static C(Other: UObject | any): ImportAssetParameters;
}

declare class InterchangeManager extends UObject { 
	RegisteredTranslatorsClass: any;
	RegisteredFactoryClasses: any;
	RegisteredWriters: any;
	TextureOnlyTranslatorClass: any;
	static Load(ResourceName: string): InterchangeManager;
	static Find(Outer: UObject, ResourceName: string): InterchangeManager;
	static GetDefaultObject(): InterchangeManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeManager;
	ImportScene(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	ImportAsset(ContentPath: string,SourceData: InterchangeSourceData,ImportAssetParameters: ImportAssetParameters): boolean;
	GetRegisteredFactoryClass(ClassToMake: UnrealEngineClass): UnrealEngineClass;
	static GetInterchangeManagerScripted(): InterchangeManager;
	ExportScene(World: UObject,bIsAutomated: boolean): boolean;
	ExportAsset(Asset: UObject,bIsAutomated: boolean): boolean;
	static CreateSourceData(InFilename: string): InterchangeSourceData;
	static C(Other: UObject | any): InterchangeManager;
}

declare type EInterchangePipelineConfigurationDialogResult = 'Cancel' | 'Import' | 'ImportAll' | 'EInterchangePipelineConfigurationDialogResult_MAX';
declare var EInterchangePipelineConfigurationDialogResult : { Cancel:'Cancel',Import:'Import',ImportAll:'ImportAll',EInterchangePipelineConfigurationDialogResult_MAX:'EInterchangePipelineConfigurationDialogResult_MAX', };
declare class InterchangePipelineConfigurationBase extends UObject { 
	static Load(ResourceName: string): InterchangePipelineConfigurationBase;
	static Find(Outer: UObject, ResourceName: string): InterchangePipelineConfigurationBase;
	static GetDefaultObject(): InterchangePipelineConfigurationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangePipelineConfigurationBase;
	ScriptedShowPipelineConfigurationDialog(): EInterchangePipelineConfigurationDialogResult;
	static C(Other: UObject | any): InterchangePipelineConfigurationBase;
}

declare class InterchangeProjectSettings extends DeveloperSettings { 
	PipelineStacks: any;
	DefaultPipelineStack: string;
	PipelineConfigurationDialogClass: Class;
	bShowPipelineStacksConfigurationDialog: boolean;
	bUseInterchangeWhenImportingIntoLevel: boolean;
	DefaultScenePipelineStack: string;
	static Load(ResourceName: string): InterchangeProjectSettings;
	static Find(Outer: UObject, ResourceName: string): InterchangeProjectSettings;
	static GetDefaultObject(): InterchangeProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterchangeProjectSettings;
	static C(Other: UObject | any): InterchangeProjectSettings;
}

declare class AdvancedCopyCustomization extends UObject { 
	static Load(ResourceName: string): AdvancedCopyCustomization;
	static Find(Outer: UObject, ResourceName: string): AdvancedCopyCustomization;
	static GetDefaultObject(): AdvancedCopyCustomization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AdvancedCopyCustomization;
	static C(Other: UObject | any): AdvancedCopyCustomization;
}

declare class AssetToolsImpl extends UObject { 
	static Load(ResourceName: string): AssetToolsImpl;
	static Find(Outer: UObject, ResourceName: string): AssetToolsImpl;
	static GetDefaultObject(): AssetToolsImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsImpl;
	static C(Other: UObject | any): AssetToolsImpl;
}

declare class AdvancedCopyMap { 
	ClassToCopy: SoftClassPath;
	AdvancedCopyCustomization: SoftClassPath;
	clone() : AdvancedCopyMap;
	static C(Other: UObject | any): AdvancedCopyMap;
}

declare class AssetToolsSettings extends DeveloperSettings { 
	AdvancedCopyCustomizations: AdvancedCopyMap[];
	static Load(ResourceName: string): AssetToolsSettings;
	static Find(Outer: UObject, ResourceName: string): AssetToolsSettings;
	static GetDefaultObject(): AssetToolsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsSettings;
	static C(Other: UObject | any): AssetToolsSettings;
}

declare class AssetRenameData { 
	Asset: any;
	NewPackagePath: string;
	NewName: string;
	OldObjectPath: SoftObjectPath;
	NewObjectPath: SoftObjectPath;
	bOnlyFixSoftReferences: boolean;
	clone() : AssetRenameData;
	static C(Other: UObject | any): AssetRenameData;
}

declare type EAssetRenameResult = 'Failure' | 'Success' | 'Pending' | 'EAssetRenameResult_MAX';
declare var EAssetRenameResult : { Failure:'Failure',Success:'Success',Pending:'Pending',EAssetRenameResult_MAX:'EAssetRenameResult_MAX', };
declare class AutomatedAssetImportData extends UObject { 
	GroupName: string;
	Filenames: string[];
	DestinationPath: string;
	FactoryName: string;
	bReplaceExisting: boolean;
	bSkipReadOnly: boolean;
	Factory: Factory;
	LevelToLoad: string;
	static Load(ResourceName: string): AutomatedAssetImportData;
	static Find(Outer: UObject, ResourceName: string): AutomatedAssetImportData;
	static GetDefaultObject(): AutomatedAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedAssetImportData;
	static C(Other: UObject | any): AutomatedAssetImportData;
}

declare class Factory extends UObject { 
	bCreateNew: boolean;
	SupportedClass: UnrealEngineClass;
	ContextClass: UnrealEngineClass;
	Formats: string[];
	bEditAfterNew: boolean;
	bEditorImport: boolean;
	bText: boolean;
	ImportPriority: number;
	AutomatedImportData: AutomatedAssetImportData;
	AssetImportTask: AssetImportTask;
	OverwriteYesOrNoToAllState: number;
	static Load(ResourceName: string): Factory;
	static Find(Outer: UObject, ResourceName: string): Factory;
	static GetDefaultObject(): Factory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Factory;
	ScriptFactoryCreateFile(InTask: AssetImportTask): boolean;
	ScriptFactoryCanImport(Filename: string): boolean;
	static C(Other: UObject | any): Factory;
}

declare class AssetImportTask extends UObject { 
	Filename: string;
	DestinationPath: string;
	DestinationName: string;
	bReplaceExisting: boolean;
	bReplaceExistingSettings: boolean;
	bAutomated: boolean;
	bSave: boolean;
	Factory: Factory;
	Options: UObject;
	ImportedObjectPaths: string[];
	Result: UObject[];
	static Load(ResourceName: string): AssetImportTask;
	static Find(Outer: UObject, ResourceName: string): AssetImportTask;
	static GetDefaultObject(): AssetImportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportTask;
	static C(Other: UObject | any): AssetImportTask;
}

declare class AssetTools extends Interface { 
	static Load(ResourceName: string): AssetTools;
	static Find(Outer: UObject, ResourceName: string): AssetTools;
	static GetDefaultObject(): AssetTools;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetTools;
	RenameReferencingSoftObjectPaths(PackagesToCheck: Package[],AssetRedirectorMap: any): void;
	RenameAssetsWithDialog(AssetsAndNames: AssetRenameData[],bAutoCheckout: boolean): EAssetRenameResult;
	RenameAssets(AssetsAndNames: AssetRenameData[]): boolean;
	OpenEditorForAssets(Assets: UObject[]): void;
	ImportAssetTasks(ImportTasks: AssetImportTask[]): void;
	ImportAssetsWithDialog(DestinationPath: string): UObject[];
	ImportAssetsAutomated(ImportData: AutomatedAssetImportData): UObject[];
	FindSoftReferencesToObject(TargetObject: SoftObjectPath,ReferencingObjects?: UObject[]): {ReferencingObjects: UObject[]};
	ExportAssetsWithDialog(AssetsToExport: string[],bPromptForIndividualFilenames: boolean): void;
	ExportAssets(AssetsToExport: string[],ExportPath: string): void;
	DuplicateAssetWithDialogAndTitle(AssetName: string,PackagePath: string,OriginalObject: UObject,DialogTitle: string): UObject;
	DuplicateAssetWithDialog(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	DuplicateAsset(AssetName: string,PackagePath: string,OriginalObject: UObject): UObject;
	CreateUniqueAssetName(InBasePackageName: string,InSuffix: string,OutPackageName?: string,OutAssetName?: string): {OutPackageName: string, OutAssetName: string};
	CreateAssetWithDialog(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string,bCallConfigureProperties: boolean): UObject;
	CreateAsset(AssetName: string,PackagePath: string,AssetClass: UnrealEngineClass,Factory: Factory,CallingContext: string): UObject;
	static C(Other: UObject | any): AssetTools;
}

declare class AssetToolsHelpers extends UObject { 
	static Load(ResourceName: string): AssetToolsHelpers;
	static Find(Outer: UObject, ResourceName: string): AssetToolsHelpers;
	static GetDefaultObject(): AssetToolsHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetToolsHelpers;
	static C(Other: UObject | any): AssetToolsHelpers;
}

declare class ContentBrowserFrontEndFilterExtension extends UObject { 
	static Load(ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static GetDefaultObject(): ContentBrowserFrontEndFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFrontEndFilterExtension;
	static C(Other: UObject | any): ContentBrowserFrontEndFilterExtension;
}

declare class ContentBrowserAssetContextMenuContext extends UObject { 
	SelectedObjects: any[];
	CommonClass: UnrealEngineClass;
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserAssetContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetContextMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): ContentBrowserAssetContextMenuContext;
}

declare class ContentBrowserAssetViewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAssetViewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAssetViewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAssetViewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAssetViewContextMenuContext;
}

declare class ContentBrowserMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserMenuContext;
	static GetDefaultObject(): ContentBrowserMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserMenuContext;
	static C(Other: UObject | any): ContentBrowserMenuContext;
}

declare class ContentBrowserFolderContext extends ContentBrowserMenuContext { 
	bCanBeModified: boolean;
	bNoFolderOnDisk: boolean;
	NumAssetPaths: number;
	NumClassPaths: number;
	static Load(ResourceName: string): ContentBrowserFolderContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFolderContext;
	static GetDefaultObject(): ContentBrowserFolderContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFolderContext;
	static C(Other: UObject | any): ContentBrowserFolderContext;
}

declare class ContentBrowserFilterListContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserFilterListContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFilterListContext;
	static GetDefaultObject(): ContentBrowserFilterListContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFilterListContext;
	static C(Other: UObject | any): ContentBrowserFilterListContext;
}

declare class ContentBrowserAddNewContextMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserAddNewContextMenuContext;
	static GetDefaultObject(): ContentBrowserAddNewContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserAddNewContextMenuContext;
	static C(Other: UObject | any): ContentBrowserAddNewContextMenuContext;
}

declare class ContentBrowserToolbarMenuContext extends UObject { 
	static Load(ResourceName: string): ContentBrowserToolbarMenuContext;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserToolbarMenuContext;
	static GetDefaultObject(): ContentBrowserToolbarMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserToolbarMenuContext;
	static C(Other: UObject | any): ContentBrowserToolbarMenuContext;
}

declare class TextFilterKeyValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterKeyValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandler;
	static GetDefaultObject(): TextFilterKeyValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandler;
	static C(Other: UObject | any): TextFilterKeyValueHandler;
}

declare class TextFilterKeyValueHandlerEntry { 
	Key: string;
	HandlerClass: Class;
	clone() : TextFilterKeyValueHandlerEntry;
	static C(Other: UObject | any): TextFilterKeyValueHandlerEntry;
}

declare class TextFilterKeyValueHandlers extends UObject { 
	TextFilterKeyValueHandlers: TextFilterKeyValueHandlerEntry[];
	static Load(ResourceName: string): TextFilterKeyValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterKeyValueHandlers;
	static GetDefaultObject(): TextFilterKeyValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterKeyValueHandlers;
	static C(Other: UObject | any): TextFilterKeyValueHandlers;
}

declare class TextFilterValueHandler extends UObject { 
	static Load(ResourceName: string): TextFilterValueHandler;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandler;
	static GetDefaultObject(): TextFilterValueHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandler;
	static C(Other: UObject | any): TextFilterValueHandler;
}

declare class TextFilterValueHandlers extends UObject { 
	TextFilterValueHandlers: Class[];
	static Load(ResourceName: string): TextFilterValueHandlers;
	static Find(Outer: UObject, ResourceName: string): TextFilterValueHandlers;
	static GetDefaultObject(): TextFilterValueHandlers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextFilterValueHandlers;
	static C(Other: UObject | any): TextFilterValueHandlers;
}

declare class MotionTrailToolOptions extends UObject { 
	bShowTrails: boolean;
	TrailColor: LinearColor;
	bShowFullTrail: boolean;
	TrailThickness: number;
	FramesBefore: number;
	FramesAfter: number;
	EvalsPerFrame: number;
	bShowKeys: boolean;
	bShowFrameNumber: boolean;
	KeyColor: LinearColor;
	KeySize: any;
	bShowMarks: boolean;
	MarkColor: LinearColor;
	MarkSize: any;
	bLockMarksToFrames: boolean;
	SecondsPerMark: any;
	static Load(ResourceName: string): MotionTrailToolOptions;
	static Find(Outer: UObject, ResourceName: string): MotionTrailToolOptions;
	static GetDefaultObject(): MotionTrailToolOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrailToolOptions;
	static C(Other: UObject | any): MotionTrailToolOptions;
}

declare class MovieSceneCopyableBinding extends UObject { 
	SpawnableObjectTemplate: UObject;
	Tracks: MovieSceneTrack[];
	Binding: MovieSceneBinding;
	Spawnable: MovieSceneSpawnable;
	Possessable: MovieScenePossessable;
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableBinding;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableBinding;
	static GetDefaultObject(): MovieSceneCopyableBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableBinding;
	static C(Other: UObject | any): MovieSceneCopyableBinding;
}

declare class MovieSceneCopyableTrack extends UObject { 
	Track: MovieSceneTrack;
	bIsAMasterTrack: boolean;
	bIsACameraCutTrack: boolean;
	FolderPath: string[];
	static Load(ResourceName: string): MovieSceneCopyableTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCopyableTrack;
	static GetDefaultObject(): MovieSceneCopyableTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCopyableTrack;
	static C(Other: UObject | any): MovieSceneCopyableTrack;
}

declare class Exporter extends UObject { 
	SupportedClass: UnrealEngineClass;
	ExportRootScope: UObject;
	FormatExtension: string[];
	FormatDescription: string[];
	PreferredFormatIndex: number;
	TextIndent: number;
	bText: boolean;
	bSelectedOnly: boolean;
	bForceFileOperations: boolean;
	ExportTask: AssetExportTask;
	static Load(ResourceName: string): Exporter;
	static Find(Outer: UObject, ResourceName: string): Exporter;
	static GetDefaultObject(): Exporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Exporter;
	ScriptRunAssetExportTask(Task: AssetExportTask): boolean;
	static RunAssetExportTasks(ExportTasks: AssetExportTask[]): boolean;
	static RunAssetExportTask(Task: AssetExportTask): boolean;
	static C(Other: UObject | any): Exporter;
}

declare class AssetExportTask extends UObject { 
	UObject: UObject;
	Exporter: Exporter;
	Filename: string;
	bSelected: boolean;
	bReplaceIdentical: boolean;
	bPrompt: boolean;
	bAutomated: boolean;
	bUseFileArchive: boolean;
	bWriteEmptyFiles: boolean;
	IgnoreObjectList: UObject[];
	Options: UObject;
	Errors: string[];
	static Load(ResourceName: string): AssetExportTask;
	static Find(Outer: UObject, ResourceName: string): AssetExportTask;
	static GetDefaultObject(): AssetExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetExportTask;
	static C(Other: UObject | any): AssetExportTask;
}

declare class SequencerExportTask extends AssetExportTask { 
	SequencerContext: UObject;
	static Load(ResourceName: string): SequencerExportTask;
	static Find(Outer: UObject, ResourceName: string): SequencerExportTask;
	static GetDefaultObject(): SequencerExportTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerExportTask;
	static C(Other: UObject | any): SequencerExportTask;
}

declare class MovieSceneDoubleChannel extends MovieSceneChannel { 
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	Times: FrameNumber[];
	Values: MovieSceneDoubleValue[];
	DefaultValue: any;
	bHasDefaultValue: boolean;
	KeyHandles: MovieSceneKeyHandleMap;
	TickResolution: FrameRate;
	bShowCurve: boolean;
	clone() : MovieSceneDoubleChannel;
	static C(Other: UObject | any): MovieSceneDoubleChannel;
}

declare type EShow3DTrajectory = 'EST_OnlyWhenSelected' | 'EST_Always' | 'EST_Never' | 'EST_MAX';
declare var EShow3DTrajectory : { EST_OnlyWhenSelected:'EST_OnlyWhenSelected',EST_Always:'EST_Always',EST_Never:'EST_Never',EST_MAX:'EST_MAX', };
declare class MovieScene3DTransformSection extends MovieSceneSection { 
	TransformMask: MovieSceneTransformMask;
	Translation: MovieSceneDoubleChannel;
	Rotation: MovieSceneDoubleChannel;
	Scale: MovieSceneDoubleChannel;
	ManualWeight: MovieSceneFloatChannel;
	bUseQuaternionInterpolation: boolean;
	Show3DTrajectory: EShow3DTrajectory;
	static Load(ResourceName: string): MovieScene3DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSection;
	static GetDefaultObject(): MovieScene3DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSection;
	static C(Other: UObject | any): MovieScene3DTransformSection;
}

declare class SequencerKeyActor extends Actor { 
	KeyMeshComponent: StaticMeshComponent;
	AssociatedActor: Actor;
	TrackSection: MovieScene3DTransformSection;
	KeyTime: number;
	static GetDefaultObject(): SequencerKeyActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerKeyActor;
	static C(Other: UObject | any): SequencerKeyActor;
}

declare class MovieSceneKeyStructType extends ScriptStruct { 
	SourceTimesProperty: any;
	SourceValuesProperty: any;
	DestTimeProperty: any;
	DestValueProperty: any;
	static Load(ResourceName: string): MovieSceneKeyStructType;
	static Find(Outer: UObject, ResourceName: string): MovieSceneKeyStructType;
	static GetDefaultObject(): MovieSceneKeyStructType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneKeyStructType;
	static C(Other: UObject | any): MovieSceneKeyStructType;
}

declare class SequencerMeshTrail extends Actor { 
	static GetDefaultObject(): SequencerMeshTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerMeshTrail;
	static C(Other: UObject | any): SequencerMeshTrail;
}

declare class SequencerSettingsContainer extends UObject { 
	static Load(ResourceName: string): SequencerSettingsContainer;
	static Find(Outer: UObject, ResourceName: string): SequencerSettingsContainer;
	static GetDefaultObject(): SequencerSettingsContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettingsContainer;
	static C(Other: UObject | any): SequencerSettingsContainer;
}

declare type EAutoChangeMode = 'AutoKey' | 'AutoTrack' | 'All' | 'None' | 'EAutoChangeMode_MAX';
declare var EAutoChangeMode : { AutoKey:'AutoKey',AutoTrack:'AutoTrack',All:'All',None:'None',EAutoChangeMode_MAX:'EAutoChangeMode_MAX', };
declare type EAllowEditsMode = 'AllEdits' | 'AllowSequencerEditsOnly' | 'AllowLevelEditsOnly' | 'EAllowEditsMode_MAX';
declare var EAllowEditsMode : { AllEdits:'AllEdits',AllowSequencerEditsOnly:'AllowSequencerEditsOnly',AllowLevelEditsOnly:'AllowLevelEditsOnly',EAllowEditsMode_MAX:'EAllowEditsMode_MAX', };
declare type EKeyGroupMode = 'KeyChanged' | 'KeyGroup' | 'KeyAll' | 'EKeyGroupMode_MAX';
declare var EKeyGroupMode : { KeyChanged:'KeyChanged',KeyGroup:'KeyGroup',KeyAll:'KeyAll',EKeyGroupMode_MAX:'EKeyGroupMode_MAX', };
declare type EMovieSceneKeyInterpolation = 'Auto' | 'User' | 'Break' | 'Linear' | 'Constant' | 'EMovieSceneKeyInterpolation_MAX';
declare var EMovieSceneKeyInterpolation : { Auto:'Auto',User:'User',Break:'Break',Linear:'Linear',Constant:'Constant',EMovieSceneKeyInterpolation_MAX:'EMovieSceneKeyInterpolation_MAX', };
declare type ESequencerSpawnPosition = 'SSP_Origin' | 'SSP_PlaceInFrontOfCamera' | 'SSP_MAX';
declare var ESequencerSpawnPosition : { SSP_Origin:'SSP_Origin',SSP_PlaceInFrontOfCamera:'SSP_PlaceInFrontOfCamera',SSP_MAX:'SSP_MAX', };
declare type ESequencerZoomPosition = 'SZP_CurrentTime' | 'SZP_MousePosition' | 'SZP_MAX';
declare var ESequencerZoomPosition : { SZP_CurrentTime:'SZP_CurrentTime',SZP_MousePosition:'SZP_MousePosition',SZP_MAX:'SZP_MAX', };
declare type ESequencerLoopMode = 'SLM_NoLoop' | 'SLM_Loop' | 'SLM_LoopSelectionRange' | 'SLM_MAX';
declare var ESequencerLoopMode : { SLM_NoLoop:'SLM_NoLoop',SLM_Loop:'SLM_Loop',SLM_LoopSelectionRange:'SLM_LoopSelectionRange',SLM_MAX:'SLM_MAX', };
declare type EFrameNumberDisplayFormats = 'NonDropFrameTimecode' | 'DropFrameTimecode' | 'Seconds' | 'Frames' | 'MAX_Count' | 'EFrameNumberDisplayFormats_MAX';
declare var EFrameNumberDisplayFormats : { NonDropFrameTimecode:'NonDropFrameTimecode',DropFrameTimecode:'DropFrameTimecode',Seconds:'Seconds',Frames:'Frames',MAX_Count:'MAX_Count',EFrameNumberDisplayFormats_MAX:'EFrameNumberDisplayFormats_MAX', };
declare class SequencerSettings extends UObject { 
	AutoChangeMode: EAutoChangeMode;
	AllowEditsMode: EAllowEditsMode;
	KeyGroupMode: EKeyGroupMode;
	KeyInterpolation: EMovieSceneKeyInterpolation;
	bAutoSetTrackDefaults: boolean;
	SpawnPosition: ESequencerSpawnPosition;
	bCreateSpawnableCameras: boolean;
	bShowRangeSlider: boolean;
	bIsSnapEnabled: boolean;
	bSnapKeyTimesToInterval: boolean;
	bSnapKeyTimesToKeys: boolean;
	bSnapSectionTimesToInterval: boolean;
	bSnapSectionTimesToSections: boolean;
	bSnapKeysAndSectionsToPlayRange: boolean;
	bSnapPlayTimeToKeys: boolean;
	bSnapPlayTimeToSections: boolean;
	bSnapPlayTimeToMarkers: boolean;
	bSnapPlayTimeToInterval: boolean;
	bSnapPlayTimeToPressedKey: boolean;
	bSnapPlayTimeToDraggedKey: boolean;
	bSnapCurveValueToInterval: boolean;
	bShowSelectedNodesOnly: boolean;
	bRewindOnRecord: boolean;
	ZoomPosition: ESequencerZoomPosition;
	bAutoScrollEnabled: boolean;
	bLinkCurveEditorTimeRange: boolean;
	bSynchronizeCurveEditorSelection: boolean;
	bIsolateCurveEditorToSelection: boolean;
	LoopMode: ESequencerLoopMode;
	bKeepCursorInPlayRangeWhileScrubbing: boolean;
	bKeepPlayRangeInSectionBounds: boolean;
	ZeroPadFrames: number;
	JumpFrameIncrement: FrameNumber;
	bShowCombinedKeyframes: boolean;
	bInfiniteKeyAreas: boolean;
	bShowChannelColors: boolean;
	KeyAreaCurveExtents: string;
	KeyAreaHeightWithCurves: number;
	ReduceKeysTolerance: number;
	bDeleteKeysWhenTrimming: boolean;
	bDisableSectionsAfterBaking: boolean;
	bCleanPlaybackMode: boolean;
	bActivateRealtimeViewports: boolean;
	bEvaluateSubSequencesInIsolation: boolean;
	bRerunConstructionScripts: boolean;
	bShowDebugVisualization: boolean;
	bVisualizePreAndPostRoll: boolean;
	bCompileDirectorOnEvaluate: boolean;
	TrajectoryPathCap: any;
	FrameNumberDisplayFormat: EFrameNumberDisplayFormats;
	MovieRendererName: string;
	static Load(ResourceName: string): SequencerSettings;
	static Find(Outer: UObject, ResourceName: string): SequencerSettings;
	static GetDefaultObject(): SequencerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettings;
	static C(Other: UObject | any): SequencerSettings;
}

declare class SequencerTrackFilterExtension extends UObject { 
	static Load(ResourceName: string): SequencerTrackFilterExtension;
	static Find(Outer: UObject, ResourceName: string): SequencerTrackFilterExtension;
	static GetDefaultObject(): SequencerTrackFilterExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerTrackFilterExtension;
	static C(Other: UObject | any): SequencerTrackFilterExtension;
}

declare class SoundNode extends UObject { 
	ChildNodes: SoundNode[];
	GraphNode: EdGraphNode;
	static Load(ResourceName: string): SoundNode;
	static Find(Outer: UObject, ResourceName: string): SoundNode;
	static GetDefaultObject(): SoundNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNode;
	static C(Other: UObject | any): SoundNode;
}

declare class SoundCue extends SoundBase { 
	bPrimeOnLoad: boolean;
	FirstNode: SoundNode;
	VolumeMultiplier: number;
	PitchMultiplier: number;
	AttenuationOverrides: SoundAttenuationSettings;
	AllNodes: SoundNode[];
	SoundCueGraph: EdGraph;
	SubtitlePriority: number;
	bOverrideAttenuation: boolean;
	bExcludeFromRandomNodeBranchCulling: boolean;
	CookedQualityIndex: number;
	bHasPlayWhenSilent: boolean;
	static Load(ResourceName: string): SoundCue;
	static Find(Outer: UObject, ResourceName: string): SoundCue;
	static GetDefaultObject(): SoundCue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCue;
	static C(Other: UObject | any): SoundCue;
	PrimeSoundCueForPlayback(): void;
	static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
}

declare class VREditorAssetContainer extends DataAsset { 
	DockableWindowCloseSound: SoundBase;
	DockableWindowOpenSound: SoundBase;
	DockableWindowDropSound: SoundBase;
	DockableWindowDragSound: SoundBase;
	DropFromContentBrowserSound: SoundBase;
	RadialMenuOpenSound: SoundBase;
	RadialMenuCloseSound: SoundBase;
	TeleportSound: SoundBase;
	ButtonPressSound: SoundCue;
	AutoScaleSound: SoundBase;
	GenericHMDMesh: StaticMesh;
	PlaneMesh: StaticMesh;
	CylinderMesh: StaticMesh;
	LaserPointerStartMesh: StaticMesh;
	LaserPointerMesh: StaticMesh;
	LaserPointerEndMesh: StaticMesh;
	LaserPointerHoverMesh: StaticMesh;
	VivePreControllerMesh: StaticMesh;
	OculusControllerMesh: StaticMesh;
	GenericControllerMesh: StaticMesh;
	TeleportRootMesh: StaticMesh;
	WindowMesh: StaticMesh;
	WindowSelectionBarMesh: StaticMesh;
	WindowCloseButtonMesh: StaticMesh;
	RadialMenuMainMesh: StaticMesh;
	RadialMenuPointerMesh: StaticMesh;
	PointerCursorMesh: StaticMesh;
	LineSegmentCylinderMesh: StaticMesh;
	JointSphereMesh: StaticMesh;
	DockingButtonMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	LaserPointerMaterial: MaterialInterface;
	LaserPointerTranslucentMaterial: MaterialInterface;
	WorldMovementPostProcessMaterial: Material;
	TextMaterial: MaterialInterface;
	VivePreControllerMaterial: MaterialInterface;
	OculusControllerMaterial: MaterialInterface;
	TeleportMaterial: MaterialInterface;
	WindowMaterial: MaterialInterface;
	WindowTranslucentMaterial: MaterialInterface;
	LineMaterial: Material;
	TranslucentTextMaterial: MaterialInterface;
	TextFont: Font;
	static Load(ResourceName: string): VREditorAssetContainer;
	static Find(Outer: UObject, ResourceName: string): VREditorAssetContainer;
	static GetDefaultObject(): VREditorAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAssetContainer;
	static C(Other: UObject | any): VREditorAssetContainer;
}

declare class EditorWorldExtensionActorData { 
	Actor: Actor;
	bValidForPIE: boolean;
	clone() : EditorWorldExtensionActorData;
	static C(Other: UObject | any): EditorWorldExtensionActorData;
}

declare class EditorWorldExtension extends UObject { 
	ExtensionActors: EditorWorldExtensionActorData[];
	static Load(ResourceName: string): EditorWorldExtension;
	static Find(Outer: UObject, ResourceName: string): EditorWorldExtension;
	static GetDefaultObject(): EditorWorldExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorWorldExtension;
	static C(Other: UObject | any): EditorWorldExtension;
}

declare class PostProcessComponent extends SceneComponent { 
	Settings: PostProcessSettings;
	Priority: number;
	BlendRadius: number;
	BlendWeight: number;
	bEnabled: boolean;
	bUnbound: boolean;
	static Load(ResourceName: string): PostProcessComponent;
	static Find(Outer: UObject, ResourceName: string): PostProcessComponent;
	static GetDefaultObject(): PostProcessComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PostProcessComponent;
	static C(Other: UObject | any): PostProcessComponent;
}

declare class VREditorAvatarActor extends Actor { 
	HeadMeshComponent: StaticMeshComponent;
	WorldMovementGridMeshComponent: StaticMeshComponent;
	WorldMovementGridMID: MaterialInstanceDynamic;
	WorldMovementGridOpacity: number;
	bIsDrawingWorldMovementPostProcess: boolean;
	WorldMovementPostProcessMaterial: MaterialInstanceDynamic;
	ScaleProgressMeshComponent: StaticMeshComponent;
	CurrentScaleProgressMeshComponent: StaticMeshComponent;
	UserScaleIndicatorText: TextRenderComponent;
	FixedUserScaleMID: MaterialInstanceDynamic;
	TranslucentFixedUserScaleMID: MaterialInstanceDynamic;
	CurrentUserScaleMID: MaterialInstanceDynamic;
	TranslucentCurrentUserScaleMID: MaterialInstanceDynamic;
	PostProcessComponent: PostProcessComponent;
	VRMode: VREditorMode;
	static GetDefaultObject(): VREditorAvatarActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAvatarActor;
	static C(Other: UObject | any): VREditorAvatarActor;
}

declare class VREditorBaseActor extends Actor { 
	VRMode: VREditorMode;
	static GetDefaultObject(): VREditorBaseActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorBaseActor;
	static C(Other: UObject | any): VREditorBaseActor;
}

declare class VREditorFloatingUICreationContext { 
	WidgetClass: UnrealEngineClass;
	PanelID: string;
	ParentActor: Actor;
	PanelSpawnOffset: Transform;
	PanelSize: Vector2D;
	PanelMesh: StaticMesh;
	EditorUISize: number;
	bHideWindowHandles: boolean;
	bMaskOutWidgetBackground: boolean;
	bNoCloseButton: boolean;
	clone() : VREditorFloatingUICreationContext;
	static C(Other: UObject | any): VREditorFloatingUICreationContext;
}

declare type EWidgetSpace = 'World' | 'Screen' | 'EWidgetSpace_MAX';
declare var EWidgetSpace : { World:'World',Screen:'Screen',EWidgetSpace_MAX:'EWidgetSpace_MAX', };
declare type EWidgetTimingPolicy = 'RealTime' | 'GameTime' | 'EWidgetTimingPolicy_MAX';
declare var EWidgetTimingPolicy : { RealTime:'RealTime',GameTime:'GameTime',EWidgetTimingPolicy_MAX:'EWidgetTimingPolicy_MAX', };
declare type EWindowVisibility = 'Visible' | 'SelfHitTestInvisible' | 'EWindowVisibility_MAX';
declare var EWindowVisibility : { Visible:'Visible',SelfHitTestInvisible:'SelfHitTestInvisible',EWindowVisibility_MAX:'EWindowVisibility_MAX', };
declare type EWidgetBlendMode = 'Opaque' | 'Masked' | 'Transparent' | 'EWidgetBlendMode_MAX';
declare var EWidgetBlendMode : { Opaque:'Opaque',Masked:'Masked',Transparent:'Transparent',EWidgetBlendMode_MAX:'EWidgetBlendMode_MAX', };
declare type EWidgetGeometryMode = 'Plane' | 'Cylinder' | 'EWidgetGeometryMode_MAX';
declare var EWidgetGeometryMode : { Plane:'Plane',Cylinder:'Cylinder',EWidgetGeometryMode_MAX:'EWidgetGeometryMode_MAX', };
declare type ETickMode = 'Disabled' | 'Enabled' | 'Automatic' | 'ETickMode_MAX';
declare var ETickMode : { Disabled:'Disabled',Enabled:'Enabled',Automatic:'Automatic',ETickMode_MAX:'ETickMode_MAX', };
declare class WidgetComponent extends MeshComponent { 
	Space: EWidgetSpace;
	TimingPolicy: EWidgetTimingPolicy;
	WidgetClass: UnrealEngineClass;
	DrawSize: IntPoint;
	bManuallyRedraw: boolean;
	bRedrawRequested: boolean;
	RedrawTime: number;
	CurrentDrawSize: IntPoint;
	bDrawAtDesiredSize: boolean;
	Pivot: Vector2D;
	bReceiveHardwareInput: boolean;
	bWindowFocusable: boolean;
	WindowVisibility: EWindowVisibility;
	bApplyGammaCorrection: boolean;
	OwnerPlayer: LocalPlayer;
	BackgroundColor: LinearColor;
	TintColorAndOpacity: LinearColor;
	OpacityFromTexture: number;
	BlendMode: EWidgetBlendMode;
	bIsTwoSided: boolean;
	TickWhenOffscreen: boolean;
	BodySetup: BodySetup;
	TranslucentMaterial: MaterialInterface;
	TranslucentMaterial_OneSided: MaterialInterface;
	OpaqueMaterial: MaterialInterface;
	OpaqueMaterial_OneSided: MaterialInterface;
	MaskedMaterial: MaterialInterface;
	MaskedMaterial_OneSided: MaterialInterface;
	RenderTarget: TextureRenderTarget2D;
	MaterialInstance: MaterialInstanceDynamic;
	bAddedToScreen: boolean;
	bEditTimeUsable: boolean;
	SharedLayerName: string;
	LayerZOrder: number;
	GeometryMode: EWidgetGeometryMode;
	CylinderArcAngle: number;
	TickMode: ETickMode;
	Widget: UserWidget;
	static Load(ResourceName: string): WidgetComponent;
	static Find(Outer: UObject, ResourceName: string): WidgetComponent;
	static GetDefaultObject(): WidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetComponent;
	SetWindowVisibility(InVisibility: EWindowVisibility): void;
	SetWindowFocusable(bInWindowFocusable: boolean): void;
	SetWidgetSpace(NewSpace: EWidgetSpace): void;
	SetWidget(Widget: UserWidget): void;
	SetTwoSided(bWantTwoSided: boolean): void;
	SetTintColorAndOpacity(NewTintColorAndOpacity: LinearColor): void;
	SetTickWhenOffscreen(bWantTickWhenOffscreen: boolean): void;
	SetTickMode(InTickMode: ETickMode): void;
	SetRedrawTime(InRedrawTime: number): void;
	SetPivot(InPivot: Vector2D): void;
	SetOwnerPlayer(LocalPlayer: LocalPlayer): void;
	SetManuallyRedraw(bUseManualRedraw: boolean): void;
	SetGeometryMode(InGeometryMode: EWidgetGeometryMode): void;
	SetDrawSize(Size: Vector2D): void;
	SetDrawAtDesiredSize(bInDrawAtDesiredSize: boolean): void;
	SetCylinderArcAngle(InCylinderArcAngle: number): void;
	SetBackgroundColor(NewBackgroundColor: LinearColor): void;
	RequestRenderUpdate(): void;
	RequestRedraw(): void;
	IsWidgetVisible(): boolean;
	GetWindowVisiblility(): EWindowVisibility;
	GetWindowFocusable(): boolean;
	GetWidgetSpace(): EWidgetSpace;
	GetWidget(): UserWidget;
	GetUserWidgetObject(): UserWidget;
	GetTwoSided(): boolean;
	GetTickWhenOffscreen(): boolean;
	GetRenderTarget(): TextureRenderTarget2D;
	GetRedrawTime(): number;
	GetPivot(): Vector2D;
	GetOwnerPlayer(): LocalPlayer;
	GetMaterialInstance(): MaterialInstanceDynamic;
	GetManuallyRedraw(): boolean;
	GetGeometryMode(): EWidgetGeometryMode;
	GetDrawSize(): Vector2D;
	GetDrawAtDesiredSize(): boolean;
	GetCylinderArcAngle(): number;
	GetCurrentDrawSize(): Vector2D;
	static C(Other: UObject | any): WidgetComponent;
}

declare type EVREditorWidgetDrawingPolicy = 'Always' | 'Hovering' | 'EVREditorWidgetDrawingPolicy_MAX';
declare var EVREditorWidgetDrawingPolicy : { Always:'Always',Hovering:'Hovering',EVREditorWidgetDrawingPolicy_MAX:'EVREditorWidgetDrawingPolicy_MAX', };
declare class VREditorWidgetComponent extends WidgetComponent { 
	DrawingPolicy: EVREditorWidgetDrawingPolicy;
	bIsHovering: boolean;
	bHasEverDrawn: boolean;
	static Load(ResourceName: string): VREditorWidgetComponent;
	static Find(Outer: UObject, ResourceName: string): VREditorWidgetComponent;
	static GetDefaultObject(): VREditorWidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorWidgetComponent;
	static C(Other: UObject | any): VREditorWidgetComponent;
}

declare class VREditorFloatingUI extends VREditorBaseActor { 
	CreationContext: VREditorFloatingUICreationContext;
	UserWidget: UserWidget;
	WidgetComponent: VREditorWidgetComponent;
	WindowMeshComponent: StaticMeshComponent;
	UserWidgetClass: UnrealEngineClass;
	static GetDefaultObject(): VREditorFloatingUI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorFloatingUI;
	static C(Other: UObject | any): VREditorFloatingUI;
}

declare class VREditorRadialFloatingUI extends VREditorBaseActor { 
	WidgetComponents: VREditorWidgetComponent[];
	WindowMeshComponent: StaticMeshComponent;
	ArrowMeshComponent: StaticMeshComponent;
	CentralWidgetComponent: VREditorWidgetComponent;
	static GetDefaultObject(): VREditorRadialFloatingUI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorRadialFloatingUI;
	static C(Other: UObject | any): VREditorRadialFloatingUI;
}

declare class ViewportDragOperation extends UObject { 
	static Load(ResourceName: string): ViewportDragOperation;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperation;
	static GetDefaultObject(): ViewportDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperation;
	static C(Other: UObject | any): ViewportDragOperation;
}

declare class ViewportDragOperationComponent extends ActorComponent { 
	DragOperation: ViewportDragOperation;
	DragOperationSubclass: UnrealEngineClass;
	static Load(ResourceName: string): ViewportDragOperationComponent;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperationComponent;
	static GetDefaultObject(): ViewportDragOperationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperationComponent;
	static C(Other: UObject | any): ViewportDragOperationComponent;
}

declare class VREditorDockableWindow extends VREditorFloatingUI { 
	DockButtonMeshComponent: StaticMeshComponent;
	SelectionBarMeshComponent: StaticMeshComponent;
	CloseButtonMeshComponent: StaticMeshComponent;
	DockButtonMID: MaterialInstanceDynamic;
	SelectionBarMID: MaterialInstanceDynamic;
	SelectionBarTranslucentMID: MaterialInstanceDynamic;
	CloseButtonMID: MaterialInstanceDynamic;
	CloseButtonTranslucentMID: MaterialInstanceDynamic;
	DragOperationComponent: ViewportDragOperationComponent;
	static GetDefaultObject(): VREditorDockableWindow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorDockableWindow;
	static C(Other: UObject | any): VREditorDockableWindow;
}

declare class ViewportTransformer extends UObject { 
	ViewportWorldInteraction: ViewportWorldInteraction;
	static Load(ResourceName: string): ViewportTransformer;
	static Find(Outer: UObject, ResourceName: string): ViewportTransformer;
	static GetDefaultObject(): ViewportTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportTransformer;
	Shutdown(): void;
	ShouldCenterTransformGizmoPivot(): boolean;
	OnStopDragging(Interactor: ViewportInteractor): void;
	OnStartDragging(Interactor: ViewportInteractor): void;
	Init(InitViewportWorldInteraction: ViewportWorldInteraction): void;
	CanAlignToActors(): boolean;
	static C(Other: UObject | any): ViewportTransformer;
}

declare class GizmoHandle { 
	clone() : GizmoHandle;
	static C(Other: UObject | any): GizmoHandle;
}

declare class GizmoHandleGroup extends SceneComponent { 
	GizmoMaterial: MaterialInterface;
	TranslucentGizmoMaterial: MaterialInterface;
	Handles: GizmoHandle[];
	OwningTransformGizmoActor: BaseTransformGizmo;
	DragOperationComponent: ViewportDragOperationComponent;
	static Load(ResourceName: string): GizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleGroup;
	static GetDefaultObject(): GizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleGroup;
	static C(Other: UObject | any): GizmoHandleGroup;
}

declare class BaseTransformGizmo extends Actor { 
	SceneComponent: SceneComponent;
	AllHandleGroups: GizmoHandleGroup[];
	WorldInteraction: ViewportWorldInteraction;
	static GetDefaultObject(): BaseTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseTransformGizmo;
	static C(Other: UObject | any): BaseTransformGizmo;
}

declare class MouseCursorInteractor extends ViewportInteractor { 
	static Load(ResourceName: string): MouseCursorInteractor;
	static Find(Outer: UObject, ResourceName: string): MouseCursorInteractor;
	static GetDefaultObject(): MouseCursorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorInteractor;
	static C(Other: UObject | any): MouseCursorInteractor;
}

declare class ViewportInteractionAssetContainer extends DataAsset { 
	GizmoHandleSelectedSound: SoundBase;
	GizmoHandleDropSound: SoundBase;
	SelectionChangeSound: SoundBase;
	SelectionDropSound: SoundBase;
	SelectionStartDragSound: SoundBase;
	GridSnapSound: SoundBase;
	ActorSnapSound: SoundBase;
	UndoSound: SoundBase;
	RedoSound: SoundBase;
	GridMesh: StaticMesh;
	TranslationHandleMesh: StaticMesh;
	UniformScaleHandleMesh: StaticMesh;
	ScaleHandleMesh: StaticMesh;
	PlaneTranslationHandleMesh: StaticMesh;
	RotationHandleMesh: StaticMesh;
	RotationHandleSelectedMesh: StaticMesh;
	StartRotationIndicatorMesh: StaticMesh;
	CurrentRotationIndicatorMesh: StaticMesh;
	FreeRotationHandleMesh: StaticMesh;
	GridMaterial: MaterialInterface;
	TransformGizmoMaterial: MaterialInterface;
	TranslucentTransformGizmoMaterial: MaterialInterface;
	static Load(ResourceName: string): ViewportInteractionAssetContainer;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractionAssetContainer;
	static GetDefaultObject(): ViewportInteractionAssetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractionAssetContainer;
	static C(Other: UObject | any): ViewportInteractionAssetContainer;
}

declare class ViewportWorldInteraction extends EditorWorldExtension { 
	Interactors: ViewportInteractor[];
	ViewportTransformer: ViewportTransformer;
	TransformGizmoActor: BaseTransformGizmo;
	SnapGridActor: Actor;
	SnapGridMeshComponent: StaticMeshComponent;
	SnapGridMID: MaterialInstanceDynamic;
	DefaultMouseCursorInteractor: MouseCursorInteractor;
	ActorsToExcludeFromHitTest: any[];
	AssetContainer: ViewportInteractionAssetContainer;
	static Load(ResourceName: string): ViewportWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteraction;
	static GetDefaultObject(): ViewportWorldInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteraction;
	SetWorldToMetersScale(NewWorldToMetersScale: number,bCompensateRoomWorldScale: boolean): void;
	SetRoomTransformForNextFrame(NewRoomTransform: Transform): void;
	SetHeadTransform(NewHeadTransform: Transform): void;
	RemoveInteractor(Interactor: ViewportInteractor): void;
	GetWorldScaleFactor(): number;
	GetTransformGizmoActor(): BaseTransformGizmo;
	GetRoomTransform(): Transform;
	GetRoomSpaceHeadTransform(): Transform;
	GetInteractors(): ViewportInteractor[];
	GetHeadTransform(): Transform;
	AddInteractor(Interactor: ViewportInteractor): void;
	AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: Actor): void;
	static C(Other: UObject | any): ViewportWorldInteraction;
}

declare type EHitResultGizmoFilterMode = 'All' | 'NoGizmos' | 'GizmosOnly' | 'EHitResultGizmoFilterMode_MAX';
declare var EHitResultGizmoFilterMode : { All:'All',NoGizmos:'NoGizmos',GizmosOnly:'GizmosOnly',EHitResultGizmoFilterMode_MAX:'EHitResultGizmoFilterMode_MAX', };
declare type EViewportInteractionDraggingMode = 'Nothing' | 'TransformablesWithGizmo' | 'TransformablesAtLaserImpact' | 'AssistingDrag' | 'TransformablesFreely' | 'World' | 'Interactable' | 'Material' | 'EViewportInteractionDraggingMode_MAX';
declare var EViewportInteractionDraggingMode : { Nothing:'Nothing',TransformablesWithGizmo:'TransformablesWithGizmo',TransformablesAtLaserImpact:'TransformablesAtLaserImpact',AssistingDrag:'AssistingDrag',TransformablesFreely:'TransformablesFreely',World:'World',Interactable:'Interactable',Material:'Material',EViewportInteractionDraggingMode_MAX:'EViewportInteractionDraggingMode_MAX', };
declare class ViewportActionKeyInput { 
	ActionType: string;
	Event: EInputEvent;
	bIsInputCaptured: boolean;
	clone() : ViewportActionKeyInput;
	static C(Other: UObject | any): ViewportActionKeyInput;
}

declare class ViewportInteractor extends UObject { 
	KeyToActionMap: any;
	WorldInteraction: ViewportWorldInteraction;
	OtherInteractor: ViewportInteractor;
	static Load(ResourceName: string): ViewportInteractor;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractor;
	static GetDefaultObject(): ViewportInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractor;
	Tick(DeltaTime: number): void;
	Shutdown(): void;
	SetHitResultGizmoFilterMode(newFilter: EHitResultGizmoFilterMode): void;
	SetDraggingMode(NewDraggingMode: EViewportInteractionDraggingMode): void;
	SetCanCarry(bInCanCarry: boolean): void;
	IsHoveringOverGizmo(): boolean;
	HandleInputKey_BP(Action: ViewportActionKeyInput,Key: Key,Event: EInputEvent,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	HandleInputAxis_BP(Action: ViewportActionKeyInput,Key: Key,Delta: number,DeltaTime: number,bOutWasHandled?: boolean): {bOutWasHandled: boolean};
	GetWorldInteraction(): ViewportWorldInteraction;
	GetTransformAndForwardVector(OutHandTransform?: Transform,OutForwardVector?: Vector): {OutHandTransform: Transform, OutForwardVector: Vector, $: boolean};
	GetTransform(): Transform;
	GetRoomSpaceTransform(): Transform;
	GetOtherInteractor(): ViewportInteractor;
	GetLastTransform(): Transform;
	GetLastRoomSpaceTransform(): Transform;
	GetLaserPointer(LaserPointerStart?: Vector,LaserPointerEnd?: Vector,bEvenIfBlocked?: boolean,LaserLengthOverride?: number): {LaserPointerStart: Vector, LaserPointerEnd: Vector, $: boolean};
	GetHoverLocation(): Vector;
	GetHitResultGizmoFilterMode(): EHitResultGizmoFilterMode;
	GetDraggingMode(): EViewportInteractionDraggingMode;
	CanCarry(): boolean;
	static C(Other: UObject | any): ViewportInteractor;
}

declare class MotionControllerComponent extends PrimitiveComponent { 
	PlayerIndex: number;
	Hand: EControllerHand;
	MotionSource: string;
	bDisableLowLatencyUpdate: boolean;
	CurrentTrackingStatus: ETrackingStatus;
	bDisplayDeviceModel: boolean;
	DisplayModelSource: string;
	CustomDisplayMesh: StaticMesh;
	DisplayMeshMaterialOverrides: MaterialInterface[];
	DisplayComponent: PrimitiveComponent;
	static Load(ResourceName: string): MotionControllerComponent;
	static Find(Outer: UObject, ResourceName: string): MotionControllerComponent;
	static GetDefaultObject(): MotionControllerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionControllerComponent;
	SetTrackingSource(NewSource: EControllerHand): void;
	SetTrackingMotionSource(NewSource: string): void;
	SetShowDeviceModel(bShowControllerModel: boolean): void;
	SetDisplayModelSource(NewDisplayModelSource: string): void;
	SetCustomDisplayMesh(NewDisplayMesh: StaticMesh): void;
	SetAssociatedPlayerIndex(NewPlayer: number): void;
	OnMotionControllerUpdated(): void;
	IsTracked(): boolean;
	GetTrackingSource(): EControllerHand;
	GetParameterValue(InName: string,bValueFound?: boolean): {bValueFound: boolean, $: number};
	GetHandJointPosition(jointIndex: number,bValueFound?: boolean): {bValueFound: boolean, $: Vector};
	static C(Other: UObject | any): MotionControllerComponent;
	DisableMotionTrackingForComponent(): void;
	EnableMotionTrackingForComponent(): boolean;
	IsMotionTrackingEnabledForComponent(): boolean;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
}

declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointQuat;
	static C(Other: UObject | any): InterpCurvePointQuat;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveQuat;
	static C(Other: UObject | any): InterpCurveQuat;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointFloat;
	static C(Other: UObject | any): InterpCurvePointFloat;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveFloat;
	static C(Other: UObject | any): InterpCurveFloat;
}

declare class SplineMetadata extends UObject { 
	static Load(ResourceName: string): SplineMetadata;
	static Find(Outer: UObject, ResourceName: string): SplineMetadata;
	static GetDefaultObject(): SplineMetadata;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadata;
	static C(Other: UObject | any): SplineMetadata;
}

declare class SplineCurves { 
	position: InterpCurveVector;
	Rotation: InterpCurveQuat;
	Scale: InterpCurveVector;
	ReparamTable: InterpCurveFloat;
	MetaData: SplineMetadata;
	Version: any;
	clone() : SplineCurves;
	static C(Other: UObject | any): SplineCurves;
}

declare type ESplineCoordinateSpace = 'Local' | 'World' | 'ESplineCoordinateSpace_MAX';
declare var ESplineCoordinateSpace : { Local:'Local',World:'World',ESplineCoordinateSpace_MAX:'ESplineCoordinateSpace_MAX', };
declare type ESplinePointType = 'Linear' | 'Curve' | 'Constant' | 'CurveClamped' | 'CurveCustomTangent' | 'ESplinePointType_MAX';
declare var ESplinePointType : { Linear:'Linear',Curve:'Curve',Constant:'Constant',CurveClamped:'CurveClamped',CurveCustomTangent:'CurveCustomTangent',ESplinePointType_MAX:'ESplinePointType_MAX', };
declare class SplinePoint { 
	InputKey: number;
	position: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	Rotation: Rotator;
	Scale: Vector;
	Type: ESplinePointType;
	clone() : SplinePoint;
	static C(Other: UObject | any): SplinePoint;
}

declare class SplineComponent extends PrimitiveComponent { 
	SplineCurves: SplineCurves;
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bModifiedByConstructionScript: boolean;
	bInputSplinePointsToConstructionScript: boolean;
	bDrawDebug: boolean;
	bClosedLoop: boolean;
	bLoopPositionOverride: boolean;
	LoopPosition: number;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	EditorTangentColor: LinearColor;
	bAllowDiscontinuousSpline: boolean;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	static Load(ResourceName: string): SplineComponent;
	static Find(Outer: UObject, ResourceName: string): SplineComponent;
	static GetDefaultObject(): SplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	UpdateSpline(): void;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUpVectorAtSplinePoint(PointIndex: number,InUpVector: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentsAtSplinePoint(PointIndex: number,InArriveTangent: Vector,InLeaveTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetTangentColor(TangentColor: LinearColor): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType,bUpdateSpline: boolean): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetScaleAtSplinePoint(PointIndex: number,InScaleVector: Vector,bUpdateSpline: boolean): void;
	SetRotationAtSplinePoint(PointIndex: number,InRotation: Rotator,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetDrawDebug(bShow: boolean): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoopAtPosition(bInClosedLoop: boolean,Key: number,bUpdateSpline: boolean): void;
	SetClosedLoop(bInClosedLoop: boolean,bUpdateSpline: boolean): void;
	RemoveSplinePoint(index: number,bUpdateSpline: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetVectorPropertyAtSplinePoint(index: number,PropertyName: string): Vector;
	GetVectorPropertyAtSplineInputKey(InKey: number,PropertyName: string): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtSplineInputKey(InKey: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetNumberOfSplineSegments(): number;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetLeaveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetFloatPropertyAtSplinePoint(index: number,PropertyName: string): number;
	GetFloatPropertyAtSplineInputKey(InKey: number,PropertyName: string): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDistanceAlongSplineAtSplineInputKey(InKey: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetArriveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindUpVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindTransformClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	FindTangentClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
	FindRotationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	FindRollClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): number;
	FindRightVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindLocationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
	FindDirectionClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	DivideSplineIntoPolylineRecursive(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineToPolyLine(CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineSegmentToPolyLine(SplinePointStartIndex: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ClearSplinePoints(bUpdateSpline: boolean): void;
	AddSplineWorldPoint(position: Vector): void;
	AddSplinePointAtIndex(position: Vector,index: number,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplinePoint(position: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplineLocalPoint(position: Vector): void;
	AddPoints(Points: SplinePoint[],bUpdateSpline: boolean): void;
	AddPoint(Point: SplinePoint,bUpdateSpline: boolean): void;
	static C(Other: UObject | any): SplineComponent;
}

declare class SplineMeshParams { 
	StartPos: Vector;
	StartTangent: Vector;
	StartScale: Vector2D;
	StartRoll: number;
	StartOffset: Vector2D;
	EndPos: Vector;
	EndScale: Vector2D;
	EndTangent: Vector;
	EndRoll: number;
	EndOffset: Vector2D;
	clone() : SplineMeshParams;
	static C(Other: UObject | any): SplineMeshParams;
}

declare type ESplineMeshAxis = 'X' | 'Y' | 'Z' | 'ESplineMeshAxis_MAX';
declare var ESplineMeshAxis : { X:'X',Y:'Y',Z:'Z',ESplineMeshAxis_MAX:'ESplineMeshAxis_MAX', };
declare class SplineMeshComponent extends StaticMeshComponent { 
	SplineParams: SplineMeshParams;
	SplineUpDir: Vector;
	SplineBoundaryMin: number;
	CachedMeshBodySetupGuid: Guid;
	BodySetup: BodySetup;
	SplineBoundaryMax: number;
	bAllowSplineEditingPerInstance: boolean;
	bSmoothInterpRollScale: boolean;
	bMeshDirty: boolean;
	ForwardAxis: ESplineMeshAxis;
	VirtualTextureMainPassMaxDrawDistance: number;
	bSelected: boolean;
	static Load(ResourceName: string): SplineMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SplineMeshComponent;
	static GetDefaultObject(): SplineMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshComponent;
	UpdateMesh(): void;
	SetStartTangent(StartTangent: Vector,bUpdateMesh: boolean): void;
	SetStartScale(StartScale: Vector2D,bUpdateMesh: boolean): void;
	SetStartRoll(StartRoll: number,bUpdateMesh: boolean): void;
	SetStartPosition(StartPos: Vector,bUpdateMesh: boolean): void;
	SetStartOffset(StartOffset: Vector2D,bUpdateMesh: boolean): void;
	SetStartAndEnd(StartPos: Vector,StartTangent: Vector,EndPos: Vector,EndTangent: Vector,bUpdateMesh: boolean): void;
	SetSplineUpDir(InSplineUpDir: Vector,bUpdateMesh: boolean): void;
	SetForwardAxis(InForwardAxis: ESplineMeshAxis,bUpdateMesh: boolean): void;
	SetEndTangent(EndTangent: Vector,bUpdateMesh: boolean): void;
	SetEndScale(EndScale: Vector2D,bUpdateMesh: boolean): void;
	SetEndRoll(EndRoll: number,bUpdateMesh: boolean): void;
	SetEndPosition(EndPos: Vector,bUpdateMesh: boolean): void;
	SetEndOffset(EndOffset: Vector2D,bUpdateMesh: boolean): void;
	SetBoundaryMin(InBoundaryMin: number,bUpdateMesh: boolean): void;
	SetBoundaryMax(InBoundaryMax: number,bUpdateMesh: boolean): void;
	GetStartTangent(): Vector;
	GetStartScale(): Vector2D;
	GetStartRoll(): number;
	GetStartPosition(): Vector;
	GetStartOffset(): Vector2D;
	GetSplineUpDir(): Vector;
	GetForwardAxis(): ESplineMeshAxis;
	GetEndTangent(): Vector;
	GetEndScale(): Vector2D;
	GetEndRoll(): number;
	GetEndPosition(): Vector;
	GetEndOffset(): Vector2D;
	GetBoundaryMin(): number;
	GetBoundaryMax(): number;
	static C(Other: UObject | any): SplineMeshComponent;
}

declare type ECastRayTracedShadow = 'Disabled' | 'UseProjectSetting' | 'Enabled' | 'ECastRayTracedShadow_MAX';
declare var ECastRayTracedShadow : { Disabled:'Disabled',UseProjectSetting:'UseProjectSetting',Enabled:'Enabled',ECastRayTracedShadow_MAX:'ECastRayTracedShadow_MAX', };
declare class LightComponentBase extends SceneComponent { 
	LightGuid: Guid;
	Brightness: number;
	Intensity: number;
	LightColor: Color;
	bAffectsWorld: boolean;
	CastShadows: boolean;
	CastStaticShadows: boolean;
	CastDynamicShadows: boolean;
	bAffectTranslucentLighting: boolean;
	bTransmission: boolean;
	bCastVolumetricShadow: boolean;
	bCastDeepShadow: boolean;
	bCastRaytracedShadow: boolean;
	CastRaytracedShadow: ECastRayTracedShadow;
	bAffectReflection: boolean;
	bAffectGlobalIllumination: boolean;
	DeepShadowLayerDistribution: number;
	IndirectLightingIntensity: number;
	VolumetricScatteringIntensity: number;
	SamplesPerPixel: number;
	StaticEditorTexture: Texture2D;
	StaticEditorTextureScale: number;
	DynamicEditorTexture: Texture2D;
	DynamicEditorTextureScale: number;
	static Load(ResourceName: string): LightComponentBase;
	static Find(Outer: UObject, ResourceName: string): LightComponentBase;
	static GetDefaultObject(): LightComponentBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponentBase;
	SetSamplesPerPixel(NewValue: number): void;
	SetCastVolumetricShadow(bNewValue: boolean): void;
	SetCastShadows(bNewValue: boolean): void;
	SetCastRaytracedShadows(bNewValue: ECastRayTracedShadow): void;
	SetCastRaytracedShadow(bNewValue: boolean): void;
	SetCastDeepShadow(bNewValue: boolean): void;
	SetAffectReflection(bNewValue: boolean): void;
	SetAffectGlobalIllumination(bNewValue: boolean): void;
	GetLightColor(): LinearColor;
	static C(Other: UObject | any): LightComponentBase;
}

declare class TextureLightProfile extends Texture2D { 
	Brightness: number;
	TextureMultiplier: number;
	static Load(ResourceName: string): TextureLightProfile;
	static Find(Outer: UObject, ResourceName: string): TextureLightProfile;
	static GetDefaultObject(): TextureLightProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureLightProfile;
	static C(Other: UObject | any): TextureLightProfile;
}

declare class LightComponent extends LightComponentBase { 
	Temperature: number;
	MaxDrawDistance: number;
	MaxDistanceFadeRange: number;
	bUseTemperature: boolean;
	ShadowMapChannel: number;
	MinRoughness: number;
	SpecularScale: number;
	ShadowResolutionScale: number;
	ShadowBias: number;
	ShadowSlopeBias: number;
	ShadowSharpen: number;
	ContactShadowLength: number;
	ContactShadowLengthInWS: boolean;
	InverseSquaredFalloff: boolean;
	CastTranslucentShadows: boolean;
	bCastShadowsFromCinematicObjectsOnly: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bForceCachedShadowsForMovablePrimitives: boolean;
	LightingChannels: LightingChannels;
	LightFunctionMaterial: MaterialInterface;
	LightFunctionScale: Vector;
	IESTexture: TextureLightProfile;
	bUseIESBrightness: boolean;
	IESBrightnessScale: number;
	LightFunctionFadeDistance: number;
	DisabledBrightness: number;
	bEnableLightShaftBloom: boolean;
	BloomScale: number;
	BloomThreshold: number;
	BloomMaxBrightness: number;
	BloomTint: Color;
	bUseRayTracedDistanceFieldShadows: boolean;
	RayStartOffsetDepthScale: number;
	static Load(ResourceName: string): LightComponent;
	static Find(Outer: UObject, ResourceName: string): LightComponent;
	static GetDefaultObject(): LightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightComponent;
	SetVolumetricScatteringIntensity(NewIntensity: number): void;
	SetUseTemperature(bNewValue: boolean): void;
	SetUseIESBrightness(bNewValue: boolean): void;
	SetTransmission(bNewValue: boolean): void;
	SetTemperature(NewTemperature: number): void;
	SetSpecularScale(NewValue: number): void;
	SetShadowSlopeBias(NewValue: number): void;
	SetShadowBias(NewValue: number): void;
	SetLightingChannels(bChannel0: boolean,bChannel1: boolean,bChannel2: boolean): void;
	SetLightFunctionScale(NewLightFunctionScale: Vector): void;
	SetLightFunctionMaterial(NewLightFunctionMaterial: MaterialInterface): void;
	SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;
	SetLightFunctionDisabledBrightness(NewValue: number): void;
	SetLightColor(NewLightColor: LinearColor,bSRGB: boolean): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetIESTexture(NewValue: TextureLightProfile): void;
	SetIESBrightnessScale(NewValue: number): void;
	SetForceCachedShadowsForMovablePrimitives(bNewValue: boolean): void;
	SetEnableLightShaftBloom(bNewValue: boolean): void;
	SetBloomTint(NewValue: Color): void;
	SetBloomThreshold(NewValue: number): void;
	SetBloomScale(NewValue: number): void;
	SetBloomMaxBrightness(NewValue: number): void;
	SetAffectTranslucentLighting(bNewValue: boolean): void;
	SetAffectDynamicIndirectLighting(bNewValue: boolean): void;
	static C(Other: UObject | any): LightComponent;
}

declare type ELightUnits = 'Unitless' | 'Candelas' | 'Lumens' | 'ELightUnits_MAX';
declare var ELightUnits : { Unitless:'Unitless',Candelas:'Candelas',Lumens:'Lumens',ELightUnits_MAX:'ELightUnits_MAX', };
declare class LightmassLightSettings { 
	IndirectLightingSaturation: number;
	ShadowExponent: number;
	bUseAreaShadowsForStationaryLight: boolean;
	clone() : LightmassLightSettings;
	static C(Other: UObject | any): LightmassLightSettings;
}

declare class LightmassPointLightSettings extends LightmassLightSettings { 
	clone() : LightmassPointLightSettings;
	static C(Other: UObject | any): LightmassPointLightSettings;
}

declare class LocalLightComponent extends LightComponent { 
	IntensityUnits: ELightUnits;
	Radius: number;
	AttenuationRadius: number;
	LightmassSettings: LightmassPointLightSettings;
	static Load(ResourceName: string): LocalLightComponent;
	static Find(Outer: UObject, ResourceName: string): LocalLightComponent;
	static GetDefaultObject(): LocalLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalLightComponent;
	SetIntensityUnits(NewIntensityUnits: ELightUnits): void;
	SetAttenuationRadius(NewRadius: number): void;
	static GetUnitsConversionFactor(SrcUnits: ELightUnits,TargetUnits: ELightUnits,CosHalfConeAngle: number): number;
	static C(Other: UObject | any): LocalLightComponent;
}

declare class PointLightComponent extends LocalLightComponent { 
	bUseInverseSquaredFalloff: boolean;
	LightFalloffExponent: number;
	SourceRadius: number;
	SoftSourceRadius: number;
	SourceLength: number;
	static Load(ResourceName: string): PointLightComponent;
	static Find(Outer: UObject, ResourceName: string): PointLightComponent;
	static GetDefaultObject(): PointLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PointLightComponent;
	SetSourceRadius(bNewValue: number): void;
	SetSourceLength(NewValue: number): void;
	SetSoftSourceRadius(bNewValue: number): void;
	SetLightFalloffExponent(NewLightFalloffExponent: number): void;
	static C(Other: UObject | any): PointLightComponent;
}

declare type EControllerType = 'Laser' | 'AssistingLaser' | 'UI' | 'Navigation' | 'Unknown' | 'EControllerType_MAX';
declare var EControllerType : { Laser:'Laser',AssistingLaser:'AssistingLaser',UI:'UI',Navigation:'Navigation',Unknown:'Unknown',EControllerType_MAX:'EControllerType_MAX', };
declare class VREditorTeleporter extends Actor { 
	VRMode: VREditorMode;
	TeleportDirectionMeshComponent: StaticMeshComponent;
	HMDMeshComponent: StaticMeshComponent;
	LeftMotionControllerMeshComponent: StaticMeshComponent;
	RightMotionControllerMeshComponent: StaticMeshComponent;
	TeleportMID: MaterialInstanceDynamic;
	InteractorTryingTeleport: ViewportInteractor;
	static GetDefaultObject(): VREditorTeleporter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorTeleporter;
	TeleportDone(): void;
	StopAiming(): void;
	StartTeleport(): void;
	StartAiming(Interactor: ViewportInteractor): void;
	Shutdown(): void;
	SetVisibility(bVisible: boolean): void;
	SetColor(Color: LinearColor): void;
	IsTeleporting(): boolean;
	IsAiming(): boolean;
	Init(InMode: VREditorMode): void;
	GetVRMode(): VREditorMode;
	GetSlideDelta(Interactor: VREditorInteractor,Axis: boolean): number;
	GetInteractorTryingTeleport(): ViewportInteractor;
	DoTeleport(): void;
	static C(Other: UObject | any): VREditorTeleporter;
}

declare class VREditorInteractor extends ViewportInteractor { 
	bIsUndoRedoSwipeEnabled: boolean;
	MotionControllerComponent: MotionControllerComponent;
	HandMeshComponent: StaticMeshComponent;
	LaserSplineComponent: SplineComponent;
	LaserSplineMeshComponents: SplineMeshComponent[];
	LaserPointerMID: MaterialInstanceDynamic;
	TranslucentLaserPointerMID: MaterialInstanceDynamic;
	HoverMeshComponent: StaticMeshComponent;
	HoverPointLightComponent: PointLightComponent;
	HandMeshMID: MaterialInstanceDynamic;
	OwningAvatar: Actor;
	ControllerType: EControllerType;
	OverrideControllerType: EControllerType;
	ControllerMotionSource: string;
	VRMode: VREditorMode;
	static Load(ResourceName: string): VREditorInteractor;
	static Find(Outer: UObject, ResourceName: string): VREditorInteractor;
	static GetDefaultObject(): VREditorInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorInteractor;
	TryOverrideControllerType(InControllerType: EControllerType): boolean;
	SetupComponent(OwningActor: Actor): void;
	SetForceShowLaser(bInForceShow: boolean): void;
	SetForceLaserColor(InColor: LinearColor): void;
	SetControllerType(InControllerType: EControllerType): void;
	SetControllerHandSide(InControllerHandSide: string): void;
	ReplaceHandMeshComponent(NewMesh: StaticMesh): void;
	IsTouchingTrackpad(): boolean;
	IsHoveringOverUI(): boolean;
	IsClickingOnUI(): boolean;
	Init(InVRMode: VREditorMode): void;
	GetTrackpadPosition(): Vector2D;
	GetTeleportActor(): VREditorTeleporter;
	GetSlideDelta(): number;
	GetSelectAndMoveTriggerValue(): number;
	GetMotionControllerComponent(): MotionControllerComponent;
	GetLastTrackpadPosition(): Vector2D;
	GetLaserStart(): Vector;
	GetLaserEnd(): Vector;
	GetHMDDeviceType(): string;
	GetControllerType(): EControllerType;
	GetControllerSide(): EControllerHand;
	GetControllerHandSide(): string;
	static C(Other: UObject | any): VREditorInteractor;
}

declare class VRButton { 
	ButtonWidget: VREditorWidgetComponent;
	clone() : VRButton;
	static C(Other: UObject | any): VRButton;
}

declare class VRRadialMenuHandler extends UObject { 
	static Load(ResourceName: string): VRRadialMenuHandler;
	static Find(Outer: UObject, ResourceName: string): VRRadialMenuHandler;
	static GetDefaultObject(): VRRadialMenuHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRRadialMenuHandler;
	static C(Other: UObject | any): VRRadialMenuHandler;
}

declare class VREditorUISystem extends UObject { 
	VRMode: VREditorMode;
	FloatingUIs: any;
	PreviewWindowInfo: any;
	InfoDisplayPanel: VREditorFloatingUI;
	QuickRadialMenu: VREditorRadialFloatingUI;
	DraggingUI: VREditorDockableWindow;
	ColorPickerUI: VREditorDockableWindow;
	LaserInteractor: VREditorInteractor;
	UIInteractor: VREditorInteractor;
	VRButtons: VRButton[];
	RadialMenuHandler: VRRadialMenuHandler;
	static Load(ResourceName: string): VREditorUISystem;
	static Find(Outer: UObject, ResourceName: string): VREditorUISystem;
	static GetDefaultObject(): VREditorUISystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorUISystem;
	static C(Other: UObject | any): VREditorUISystem;
}

declare class VREditorPlacement extends UObject { 
	VRMode: VREditorMode;
	ViewportWorldInteraction: ViewportWorldInteraction;
	FloatingUIAssetDraggedFrom: WidgetComponent;
	PlacingMaterialOrTextureAsset: UObject;
	static Load(ResourceName: string): VREditorPlacement;
	static Find(Outer: UObject, ResourceName: string): VREditorPlacement;
	static GetDefaultObject(): VREditorPlacement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorPlacement;
	static C(Other: UObject | any): VREditorPlacement;
}

declare class VREditorMode extends EditorWorldExtension { 
	AvatarActor: VREditorAvatarActor;
	UISystem: VREditorUISystem;
	TeleportActor: VREditorTeleporter;
	AutoScalerSystem: VREditorAutoScaler;
	WorldInteraction: ViewportWorldInteraction;
	PlacementSystem: VREditorPlacement;
	Interactors: VREditorInteractor[];
	AssetContainer: VREditorAssetContainer;
	static Load(ResourceName: string): VREditorMode;
	static Find(Outer: UObject, ResourceName: string): VREditorMode;
	static GetDefaultObject(): VREditorMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorMode;
	GetWorldScaleFactor(): number;
	static C(Other: UObject | any): VREditorMode;
}

declare class VREditorAutoScaler extends UObject { 
	VRMode: VREditorMode;
	static Load(ResourceName: string): VREditorAutoScaler;
	static Find(Outer: UObject, ResourceName: string): VREditorAutoScaler;
	static GetDefaultObject(): VREditorAutoScaler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAutoScaler;
	static C(Other: UObject | any): VREditorAutoScaler;
}

declare class VREditorBaseUserWidget extends UserWidget { 
	Owner: any;
	static Load(ResourceName: string): VREditorBaseUserWidget;
	static Find(Outer: UObject, ResourceName: string): VREditorBaseUserWidget;
	static GetDefaultObject(): VREditorBaseUserWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorBaseUserWidget;
	static C(Other: UObject | any): VREditorBaseUserWidget;
}

declare class VREditorCameraWidgetComponent extends VREditorWidgetComponent { 
	static Load(ResourceName: string): VREditorCameraWidgetComponent;
	static Find(Outer: UObject, ResourceName: string): VREditorCameraWidgetComponent;
	static GetDefaultObject(): VREditorCameraWidgetComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorCameraWidgetComponent;
	static C(Other: UObject | any): VREditorCameraWidgetComponent;
}

declare class VREditorDockableCameraWindow extends VREditorDockableWindow { 
	static GetDefaultObject(): VREditorDockableCameraWindow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorDockableCameraWindow;
	static C(Other: UObject | any): VREditorDockableCameraWindow;
}

declare class DockableWindowDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): DockableWindowDragOperation;
	static Find(Outer: UObject, ResourceName: string): DockableWindowDragOperation;
	static GetDefaultObject(): DockableWindowDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DockableWindowDragOperation;
	static C(Other: UObject | any): DockableWindowDragOperation;
}

declare class VREditorFloatingCameraUI extends VREditorFloatingUI { 
	OffsetFromCamera: Vector;
	LinkedActor: any;
	static GetDefaultObject(): VREditorFloatingCameraUI;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorFloatingCameraUI;
	static C(Other: UObject | any): VREditorFloatingCameraUI;
}

declare class FloatingText extends Actor { 
	SceneComponent: SceneComponent;
	FirstLineComponent: StaticMeshComponent;
	JointSphereComponent: StaticMeshComponent;
	SecondLineComponent: StaticMeshComponent;
	TextComponent: TextRenderComponent;
	MaskedTextMaterial: MaterialInterface;
	TranslucentTextMaterial: MaterialInterface;
	LineMaterial: MaterialInterface;
	LineMaterialMID: MaterialInstanceDynamic;
	static GetDefaultObject(): FloatingText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatingText;
	static C(Other: UObject | any): FloatingText;
}

declare class VISettings extends UObject { 
	bScaleWorldFromFloor: boolean;
	bScaleWorldWithDynamicPivot: boolean;
	bAllowSimultaneousWorldScalingAndRotation: boolean;
	static Load(ResourceName: string): VISettings;
	static Find(Outer: UObject, ResourceName: string): VISettings;
	static GetDefaultObject(): VISettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VISettings;
	static C(Other: UObject | any): VISettings;
}

declare type EInteractorHand = 'Right' | 'Left' | 'EInteractorHand_MAX';
declare var EInteractorHand : { Right:'Right',Left:'Left',EInteractorHand_MAX:'EInteractorHand_MAX', };
declare class VRModeSettings extends VISettings { 
	bEnableAutoVREditMode: boolean;
	bAutokeySequences: boolean;
	InteractorHand: EInteractorHand;
	bShowWorldMovementGrid: boolean;
	bShowWorldMovementPostProcess: boolean;
	bShowWorldScaleProgressBar: boolean;
	UIBrightness: number;
	GizmoScale: number;
	DoubleClickTime: number;
	TriggerPressedThreshold_Vive: number;
	TriggerPressedThreshold_Rift: number;
	InteractorClass: Class;
	TeleporterClass: Class;
	static Load(ResourceName: string): VRModeSettings;
	static Find(Outer: UObject, ResourceName: string): VRModeSettings;
	static GetDefaultObject(): VRModeSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRModeSettings;
	static C(Other: UObject | any): VRModeSettings;
}

declare type EGizmoHandleTypes = 'All' | 'Translate' | 'Rotate' | 'Scale' | 'EGizmoHandleTypes_MAX';
declare var EGizmoHandleTypes : { All:'All',Translate:'Translate',Rotate:'Rotate',Scale:'Scale',EGizmoHandleTypes_MAX:'EGizmoHandleTypes_MAX', };
declare class VRScoutingInteractor extends VREditorInteractor { 
	FlyingIndicatorComponent: StaticMeshComponent;
	static Load(ResourceName: string): VRScoutingInteractor;
	static Find(Outer: UObject, ResourceName: string): VRScoutingInteractor;
	static GetDefaultObject(): VRScoutingInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRScoutingInteractor;
	SetGizmoMode(InGizmoMode: EGizmoHandleTypes): void;
	static GetSelectedActors(): Actor[];
	GetGizmoMode(): EGizmoHandleTypes;
	static C(Other: UObject | any): VRScoutingInteractor;
}

declare class RuntimeVirtualTextureFactory extends Factory { 
	static Load(ResourceName: string): RuntimeVirtualTextureFactory;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureFactory;
	static GetDefaultObject(): RuntimeVirtualTextureFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureFactory;
	static C(Other: UObject | any): RuntimeVirtualTextureFactory;
}

declare class ThumbnailRenderer extends UObject { 
	static Load(ResourceName: string): ThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): ThumbnailRenderer;
	static GetDefaultObject(): ThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailRenderer;
	static C(Other: UObject | any): ThumbnailRenderer;
}

declare class DefaultSizedThumbnailRenderer extends ThumbnailRenderer { 
	DefaultSizeX: number;
	DefaultSizeY: number;
	static Load(ResourceName: string): DefaultSizedThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): DefaultSizedThumbnailRenderer;
	static GetDefaultObject(): DefaultSizedThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultSizedThumbnailRenderer;
	static C(Other: UObject | any): DefaultSizedThumbnailRenderer;
}

declare class RuntimeVirtualTextureThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): RuntimeVirtualTextureThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureThumbnailRenderer;
	static GetDefaultObject(): RuntimeVirtualTextureThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureThumbnailRenderer;
	static C(Other: UObject | any): RuntimeVirtualTextureThumbnailRenderer;
}

declare class VirtualTextureBuilderFactory extends Factory { 
	static Load(ResourceName: string): VirtualTextureBuilderFactory;
	static Find(Outer: UObject, ResourceName: string): VirtualTextureBuilderFactory;
	static GetDefaultObject(): VirtualTextureBuilderFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTextureBuilderFactory;
	static C(Other: UObject | any): VirtualTextureBuilderFactory;
}

declare class TextureThumbnailRenderer extends ThumbnailRenderer { 
	static Load(ResourceName: string): TextureThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): TextureThumbnailRenderer;
	static GetDefaultObject(): TextureThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureThumbnailRenderer;
	static C(Other: UObject | any): TextureThumbnailRenderer;
}

declare class VirtualTextureBuilderThumbnailRenderer extends TextureThumbnailRenderer { 
	static Load(ResourceName: string): VirtualTextureBuilderThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): VirtualTextureBuilderThumbnailRenderer;
	static GetDefaultObject(): VirtualTextureBuilderThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTextureBuilderThumbnailRenderer;
	static C(Other: UObject | any): VirtualTextureBuilderThumbnailRenderer;
}

declare class MeshReconstructorBase extends UObject { 
	static Load(ResourceName: string): MeshReconstructorBase;
	static Find(Outer: UObject, ResourceName: string): MeshReconstructorBase;
	static GetDefaultObject(): MeshReconstructorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshReconstructorBase;
	StopReconstruction(): void;
	StartReconstruction(): void;
	PauseReconstruction(): void;
	IsReconstructionStarted(): boolean;
	IsReconstructionPaused(): boolean;
	DisconnectMRMesh(): void;
	ConnectMRMesh(Mesh: MRMeshComponent): void;
	static C(Other: UObject | any): MeshReconstructorBase;
}

declare type EMeshTrackerVertexColorMode = 'None' | 'Confidence' | 'Block' | 'EMeshTrackerVertexColorMode_MAX';
declare var EMeshTrackerVertexColorMode : { None:'None',Confidence:'Confidence',Block:'Block',EMeshTrackerVertexColorMode_MAX:'EMeshTrackerVertexColorMode_MAX', };
declare class MockDataMeshTrackerComponent extends SceneComponent { 
	OnMeshTrackerUpdated: UnrealEngineMulticastDelegate<(index: number, Vertices: Vector[], Triangles: number[], Normals: Vector[], Confidence: number[]) => void>;
	ScanWorld: boolean;
	RequestNormals: boolean;
	RequestVertexConfidence: boolean;
	VertexColorMode: EMeshTrackerVertexColorMode;
	BlockVertexColors: Color[];
	VertexColorFromConfidenceZero: LinearColor;
	VertexColorFromConfidenceOne: LinearColor;
	UpdateInterval: number;
	MRMesh: MRMeshComponent;
	static Load(ResourceName: string): MockDataMeshTrackerComponent;
	static Find(Outer: UObject, ResourceName: string): MockDataMeshTrackerComponent;
	static GetDefaultObject(): MockDataMeshTrackerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MockDataMeshTrackerComponent;
	DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	ConnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
	static C(Other: UObject | any): MockDataMeshTrackerComponent;
}

declare class ARComponent extends SceneComponent { 
	NativeID: Guid;
	bUseDefaultReplication: boolean;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	MRMeshComponent: MRMeshComponent;
	MyTrackedGeometry: ARTrackedGeometry;
	static Load(ResourceName: string): ARComponent;
	static Find(Outer: UObject, ResourceName: string): ARComponent;
	static GetDefaultObject(): ARComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARComponent;
	UpdateVisualization(): void;
	SetNativeID(NativeID: Guid): void;
	ReceiveRemove(): void;
	OnRep_Payload(): void;
	GetMRMesh(): MRMeshComponent;
	static C(Other: UObject | any): ARComponent;
}

declare class ARActor extends Actor { 
	static GetDefaultObject(): ARActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARActor;
	AddARComponent(InComponentClass: UnrealEngineClass,NativeID: Guid): ARComponent;
	static C(Other: UObject | any): ARActor;
}

declare type EARCaptureType = 'Camera' | 'QRCode' | 'SpatialMapping' | 'SceneUnderstanding' | 'HandMesh' | 'EARCaptureType_MAX';
declare var EARCaptureType : { Camera:'Camera',QRCode:'QRCode',SpatialMapping:'SpatialMapping',SceneUnderstanding:'SceneUnderstanding',HandMesh:'HandMesh',EARCaptureType_MAX:'EARCaptureType_MAX', };
declare type EARWorldAlignment = 'Gravity' | 'GravityAndHeading' | 'Camera' | 'EARWorldAlignment_MAX';
declare var EARWorldAlignment : { Gravity:'Gravity',GravityAndHeading:'GravityAndHeading',Camera:'Camera',EARWorldAlignment_MAX:'EARWorldAlignment_MAX', };
declare type EARSessionType = 'None' | 'Orientation' | 'World' | 'Face' | 'Image' | 'ObjectScanning' | 'PoseTracking' | 'GeoTracking' | 'EARSessionType_MAX';
declare var EARSessionType : { None:'None',Orientation:'Orientation',World:'World',Face:'Face',Image:'Image',ObjectScanning:'ObjectScanning',PoseTracking:'PoseTracking',GeoTracking:'GeoTracking',EARSessionType_MAX:'EARSessionType_MAX', };
declare type EARPlaneDetectionMode = 'None' | 'HorizontalPlaneDetection' | 'VerticalPlaneDetection' | 'EARPlaneDetectionMode_MAX';
declare var EARPlaneDetectionMode : { None:'None',HorizontalPlaneDetection:'HorizontalPlaneDetection',VerticalPlaneDetection:'VerticalPlaneDetection',EARPlaneDetectionMode_MAX:'EARPlaneDetectionMode_MAX', };
declare type EARLightEstimationMode = 'None' | 'AmbientLightEstimate' | 'DirectionalLightEstimate' | 'EARLightEstimationMode_MAX';
declare var EARLightEstimationMode : { None:'None',AmbientLightEstimate:'AmbientLightEstimate',DirectionalLightEstimate:'DirectionalLightEstimate',EARLightEstimationMode_MAX:'EARLightEstimationMode_MAX', };
declare type EARFrameSyncMode = 'SyncTickWithCameraImage' | 'SyncTickWithoutCameraImage' | 'EARFrameSyncMode_MAX';
declare var EARFrameSyncMode : { SyncTickWithCameraImage:'SyncTickWithCameraImage',SyncTickWithoutCameraImage:'SyncTickWithoutCameraImage',EARFrameSyncMode_MAX:'EARFrameSyncMode_MAX', };
declare type EARCandidateImageOrientation = 'Landscape' | 'Portrait' | 'EARCandidateImageOrientation_MAX';
declare var EARCandidateImageOrientation : { Landscape:'Landscape',Portrait:'Portrait',EARCandidateImageOrientation_MAX:'EARCandidateImageOrientation_MAX', };
declare class ARCandidateImage extends DataAsset { 
	CandidateTexture: Texture2D;
	FriendlyName: string;
	Width: number;
	Height: number;
	Orientation: EARCandidateImageOrientation;
	static Load(ResourceName: string): ARCandidateImage;
	static Find(Outer: UObject, ResourceName: string): ARCandidateImage;
	static GetDefaultObject(): ARCandidateImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateImage;
	GetPhysicalWidth(): number;
	GetPhysicalHeight(): number;
	GetOrientation(): EARCandidateImageOrientation;
	GetFriendlyName(): string;
	GetCandidateTexture(): Texture2D;
	static C(Other: UObject | any): ARCandidateImage;
}

declare type EAREnvironmentCaptureProbeType = 'None' | 'Manual' | 'Automatic' | 'EAREnvironmentCaptureProbeType_MAX';
declare var EAREnvironmentCaptureProbeType : { None:'None',Manual:'Manual',Automatic:'Automatic',EAREnvironmentCaptureProbeType_MAX:'EAREnvironmentCaptureProbeType_MAX', };
declare class ARCandidateObject extends DataAsset { 
	CandidateObjectData: number[];
	FriendlyName: string;
	BoundingBox: Box;
	static Load(ResourceName: string): ARCandidateObject;
	static Find(Outer: UObject, ResourceName: string): ARCandidateObject;
	static GetDefaultObject(): ARCandidateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARCandidateObject;
	SetFriendlyName(NewName: string): void;
	SetCandidateObjectData(InCandidateObject: number[]): void;
	SetBoundingBox(InBoundingBox: Box): void;
	GetFriendlyName(): string;
	GetCandidateObjectData(): number[];
	GetBoundingBox(): Box;
	static C(Other: UObject | any): ARCandidateObject;
}

declare class ARVideoFormat { 
	FPS: number;
	Width: number;
	Height: number;
	clone() : ARVideoFormat;
	static C(Other: UObject | any): ARVideoFormat;
}

declare type EARFaceTrackingDirection = 'FaceRelative' | 'FaceMirrored' | 'EARFaceTrackingDirection_MAX';
declare var EARFaceTrackingDirection : { FaceRelative:'FaceRelative',FaceMirrored:'FaceMirrored',EARFaceTrackingDirection_MAX:'EARFaceTrackingDirection_MAX', };
declare type EARFaceTrackingUpdate = 'CurvesAndGeo' | 'CurvesOnly' | 'EARFaceTrackingUpdate_MAX';
declare var EARFaceTrackingUpdate : { CurvesAndGeo:'CurvesAndGeo',CurvesOnly:'CurvesOnly',EARFaceTrackingUpdate_MAX:'EARFaceTrackingUpdate_MAX', };
declare type EARSessionTrackingFeature = 'None' | 'PoseDetection2D' | 'PersonSegmentation' | 'PersonSegmentationWithDepth' | 'SceneDepth' | 'SmoothedSceneDepth' | 'EARSessionTrackingFeature_MAX';
declare var EARSessionTrackingFeature : { None:'None',PoseDetection2D:'PoseDetection2D',PersonSegmentation:'PersonSegmentation',PersonSegmentationWithDepth:'PersonSegmentationWithDepth',SceneDepth:'SceneDepth',SmoothedSceneDepth:'SmoothedSceneDepth',EARSessionTrackingFeature_MAX:'EARSessionTrackingFeature_MAX', };
declare type EARSceneReconstruction = 'None' | 'MeshOnly' | 'MeshWithClassification' | 'EARSceneReconstruction_MAX';
declare var EARSceneReconstruction : { None:'None',MeshOnly:'MeshOnly',MeshWithClassification:'MeshWithClassification',EARSceneReconstruction_MAX:'EARSceneReconstruction_MAX', };
declare class ARSessionPayload { 
	ConfigFlags: number;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	clone() : ARSessionPayload;
	static C(Other: UObject | any): ARSessionPayload;
}

declare class ARPlaneUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Center: Vector;
	Extents: Vector;
	BoundaryVertices: Vector[];
	ObjectClassification: EARObjectClassification;
	clone() : ARPlaneUpdatePayload;
	static C(Other: UObject | any): ARPlaneUpdatePayload;
}

declare type EPlaneComponentDebugMode = 'None' | 'ShowNetworkRole' | 'ShowClassification' | 'EPlaneComponentDebugMode_MAX';
declare var EPlaneComponentDebugMode : { None:'None',ShowNetworkRole:'ShowNetworkRole',ShowClassification:'ShowClassification',EPlaneComponentDebugMode_MAX:'EPlaneComponentDebugMode_MAX', };
declare class ARPlaneComponent extends ARComponent { 
	ReplicatedPayload: ARPlaneUpdatePayload;
	static Load(ResourceName: string): ARPlaneComponent;
	static Find(Outer: UObject, ResourceName: string): ARPlaneComponent;
	static GetDefaultObject(): ARPlaneComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneComponent;
	static SetPlaneComponentDebugMode(NewDebugMode: EPlaneComponentDebugMode): void;
	static SetObjectClassificationDebugColors(InColors: any): void;
	ServerUpdatePayload(NewPayload: ARPlaneUpdatePayload): void;
	ReceiveUpdate(Payload: ARPlaneUpdatePayload): void;
	ReceiveAdd(Payload: ARPlaneUpdatePayload): void;
	static GetObjectClassificationDebugColors(): any;
	static C(Other: UObject | any): ARPlaneComponent;
}

declare class ARPointUpdatePayload { 
	clone() : ARPointUpdatePayload;
	static C(Other: UObject | any): ARPointUpdatePayload;
}

declare class ARPointComponent extends ARComponent { 
	ReplicatedPayload: ARPointUpdatePayload;
	static Load(ResourceName: string): ARPointComponent;
	static Find(Outer: UObject, ResourceName: string): ARPointComponent;
	static GetDefaultObject(): ARPointComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPointComponent;
	ServerUpdatePayload(NewPayload: ARPointUpdatePayload): void;
	ReceiveUpdate(Payload: ARPointUpdatePayload): void;
	ReceiveAdd(Payload: ARPointUpdatePayload): void;
	static C(Other: UObject | any): ARPointComponent;
}

declare type EARFaceTransformMixing = 'ComponentOnly' | 'ComponentLocationTrackedRotation' | 'ComponentWithTracked' | 'TrackingOnly' | 'EARFaceTransformMixing_MAX';
declare var EARFaceTransformMixing : { ComponentOnly:'ComponentOnly',ComponentLocationTrackedRotation:'ComponentLocationTrackedRotation',ComponentWithTracked:'ComponentWithTracked',TrackingOnly:'TrackingOnly',EARFaceTransformMixing_MAX:'EARFaceTransformMixing_MAX', };
declare class ARFaceUpdatePayload { 
	SessionPayload: ARSessionPayload;
	LeftEyePosition: Vector;
	RightEyePosition: Vector;
	LookAtTarget: Vector;
	clone() : ARFaceUpdatePayload;
	static C(Other: UObject | any): ARFaceUpdatePayload;
}

declare type EFaceComponentDebugMode = 'None' | 'ShowEyeVectors' | 'ShowFaceMesh' | 'EFaceComponentDebugMode_MAX';
declare var EFaceComponentDebugMode : { None:'None',ShowEyeVectors:'ShowEyeVectors',ShowFaceMesh:'ShowFaceMesh',EFaceComponentDebugMode_MAX:'EFaceComponentDebugMode_MAX', };
declare class ARFaceComponent extends ARComponent { 
	TransformSetting: EARFaceTransformMixing;
	bUpdateVertexNormal: boolean;
	bFaceOutOfScreen: boolean;
	ReplicatedPayload: ARFaceUpdatePayload;
	static Load(ResourceName: string): ARFaceComponent;
	static Find(Outer: UObject, ResourceName: string): ARFaceComponent;
	static GetDefaultObject(): ARFaceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceComponent;
	static SetFaceComponentDebugMode(NewDebugMode: EFaceComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARFaceUpdatePayload): void;
	ReceiveUpdate(Payload: ARFaceUpdatePayload): void;
	ReceiveAdd(Payload: ARFaceUpdatePayload): void;
	static C(Other: UObject | any): ARFaceComponent;
}

declare class ARImageUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	clone() : ARImageUpdatePayload;
	static C(Other: UObject | any): ARImageUpdatePayload;
}

declare type EImageComponentDebugMode = 'None' | 'ShowDetectedImage' | 'EImageComponentDebugMode_MAX';
declare var EImageComponentDebugMode : { None:'None',ShowDetectedImage:'ShowDetectedImage',EImageComponentDebugMode_MAX:'EImageComponentDebugMode_MAX', };
declare class ARImageComponent extends ARComponent { 
	ReplicatedPayload: ARImageUpdatePayload;
	static Load(ResourceName: string): ARImageComponent;
	static Find(Outer: UObject, ResourceName: string): ARImageComponent;
	static GetDefaultObject(): ARImageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARImageComponent;
	static SetImageComponentDebugMode(NewDebugMode: EImageComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARImageUpdatePayload): void;
	ReceiveUpdate(Payload: ARImageUpdatePayload): void;
	ReceiveAdd(Payload: ARImageUpdatePayload): void;
	static C(Other: UObject | any): ARImageComponent;
}

declare class ARQRCodeUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Extents: Vector;
	QRCode: string;
	clone() : ARQRCodeUpdatePayload;
	static C(Other: UObject | any): ARQRCodeUpdatePayload;
}

declare type EQRCodeComponentDebugMode = 'None' | 'ShowQRCode' | 'EQRCodeComponentDebugMode_MAX';
declare var EQRCodeComponentDebugMode : { None:'None',ShowQRCode:'ShowQRCode',EQRCodeComponentDebugMode_MAX:'EQRCodeComponentDebugMode_MAX', };
declare class ARQRCodeComponent extends ARComponent { 
	ReplicatedPayload: ARQRCodeUpdatePayload;
	static Load(ResourceName: string): ARQRCodeComponent;
	static Find(Outer: UObject, ResourceName: string): ARQRCodeComponent;
	static GetDefaultObject(): ARQRCodeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARQRCodeComponent;
	static SetQRCodeComponentDebugMode(NewDebugMode: EQRCodeComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARQRCodeUpdatePayload): void;
	ReceiveUpdate(Payload: ARQRCodeUpdatePayload): void;
	ReceiveAdd(Payload: ARQRCodeUpdatePayload): void;
	static C(Other: UObject | any): ARQRCodeComponent;
}

declare class ARPoseUpdatePayload { 
	WorldTransform: Transform;
	JointTransforms: Transform[];
	clone() : ARPoseUpdatePayload;
	static C(Other: UObject | any): ARPoseUpdatePayload;
}

declare type EPoseComponentDebugMode = 'None' | 'ShowSkeleton' | 'EPoseComponentDebugMode_MAX';
declare var EPoseComponentDebugMode : { None:'None',ShowSkeleton:'ShowSkeleton',EPoseComponentDebugMode_MAX:'EPoseComponentDebugMode_MAX', };
declare class ARPoseComponent extends ARComponent { 
	ReplicatedPayload: ARPoseUpdatePayload;
	static Load(ResourceName: string): ARPoseComponent;
	static Find(Outer: UObject, ResourceName: string): ARPoseComponent;
	static GetDefaultObject(): ARPoseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPoseComponent;
	static SetPoseComponentDebugMode(NewDebugMode: EPoseComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARPoseUpdatePayload): void;
	ReceiveUpdate(Payload: ARPoseUpdatePayload): void;
	ReceiveAdd(Payload: ARPoseUpdatePayload): void;
	static C(Other: UObject | any): ARPoseComponent;
}

declare class AREnvironmentProbeUpdatePayload { 
	WorldTransform: Transform;
	clone() : AREnvironmentProbeUpdatePayload;
	static C(Other: UObject | any): AREnvironmentProbeUpdatePayload;
}

declare class AREnvironmentProbeComponent extends ARComponent { 
	ReplicatedPayload: AREnvironmentProbeUpdatePayload;
	static Load(ResourceName: string): AREnvironmentProbeComponent;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentProbeComponent;
	static GetDefaultObject(): AREnvironmentProbeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentProbeComponent;
	ServerUpdatePayload(NewPayload: AREnvironmentProbeUpdatePayload): void;
	ReceiveUpdate(Payload: AREnvironmentProbeUpdatePayload): void;
	ReceiveAdd(Payload: AREnvironmentProbeUpdatePayload): void;
	static C(Other: UObject | any): AREnvironmentProbeComponent;
}

declare class ARObjectUpdatePayload { 
	WorldTransform: Transform;
	clone() : ARObjectUpdatePayload;
	static C(Other: UObject | any): ARObjectUpdatePayload;
}

declare class ARObjectComponent extends ARComponent { 
	ReplicatedPayload: ARObjectUpdatePayload;
	static Load(ResourceName: string): ARObjectComponent;
	static Find(Outer: UObject, ResourceName: string): ARObjectComponent;
	static GetDefaultObject(): ARObjectComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARObjectComponent;
	ServerUpdatePayload(NewPayload: ARObjectUpdatePayload): void;
	ReceiveUpdate(Payload: ARObjectUpdatePayload): void;
	ReceiveAdd(Payload: ARObjectUpdatePayload): void;
	static C(Other: UObject | any): ARObjectComponent;
}

declare class ARMeshUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	ObjectClassification: EARObjectClassification;
	clone() : ARMeshUpdatePayload;
	static C(Other: UObject | any): ARMeshUpdatePayload;
}

declare class ARMeshComponent extends ARComponent { 
	ReplicatedPayload: ARMeshUpdatePayload;
	static Load(ResourceName: string): ARMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ARMeshComponent;
	static GetDefaultObject(): ARMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshComponent;
	ServerUpdatePayload(NewPayload: ARMeshUpdatePayload): void;
	ReceiveUpdate(Payload: ARMeshUpdatePayload): void;
	ReceiveAdd(Payload: ARMeshUpdatePayload): void;
	static C(Other: UObject | any): ARMeshComponent;
}

declare type EARAltitudeSource = 'Precise' | 'Coarse' | 'UserDefined' | 'Unknown' | 'EARAltitudeSource_MAX';
declare var EARAltitudeSource : { Precise:'Precise',Coarse:'Coarse',UserDefined:'UserDefined',Unknown:'Unknown',EARAltitudeSource_MAX:'EARAltitudeSource_MAX', };
declare class ARGeoAnchorUpdatePayload { 
	SessionPayload: ARSessionPayload;
	WorldTransform: Transform;
	Longitude: number;
	Latitude: number;
	AltitudeMeters: number;
	AltitudeSource: EARAltitudeSource;
	AnchorName: string;
	clone() : ARGeoAnchorUpdatePayload;
	static C(Other: UObject | any): ARGeoAnchorUpdatePayload;
}

declare type EGeoAnchorComponentDebugMode = 'None' | 'ShowGeoData' | 'EGeoAnchorComponentDebugMode_MAX';
declare var EGeoAnchorComponentDebugMode : { None:'None',ShowGeoData:'ShowGeoData',EGeoAnchorComponentDebugMode_MAX:'EGeoAnchorComponentDebugMode_MAX', };
declare class ARGeoAnchorComponent extends ARComponent { 
	ReplicatedPayload: ARGeoAnchorUpdatePayload;
	static Load(ResourceName: string): ARGeoAnchorComponent;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchorComponent;
	static GetDefaultObject(): ARGeoAnchorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchorComponent;
	static SetGeoAnchorComponentDebugMode(NewDebugMode: EGeoAnchorComponentDebugMode): void;
	ServerUpdatePayload(NewPayload: ARGeoAnchorUpdatePayload): void;
	ReceiveUpdate(Payload: ARGeoAnchorUpdatePayload): void;
	ReceiveAdd(Payload: ARGeoAnchorUpdatePayload): void;
	static C(Other: UObject | any): ARGeoAnchorComponent;
}

declare class ARSessionConfig extends DataAsset { 
	bGenerateMeshDataFromTrackedGeometry: boolean;
	bGenerateCollisionForMeshData: boolean;
	bGenerateNavMeshForMeshData: boolean;
	bUseMeshDataForOcclusion: boolean;
	bRenderMeshDataInWireframe: boolean;
	bTrackSceneObjects: boolean;
	bUsePersonSegmentationForOcclusion: boolean;
	bUseSceneDepthForOcclusion: boolean;
	bUseAutomaticImageScaleEstimation: boolean;
	bUseStandardOnboardingUX: boolean;
	WorldAlignment: EARWorldAlignment;
	SessionType: EARSessionType;
	PlaneDetectionMode: EARPlaneDetectionMode;
	bHorizontalPlaneDetection: boolean;
	bVerticalPlaneDetection: boolean;
	bEnableAutoFocus: boolean;
	LightEstimationMode: EARLightEstimationMode;
	FrameSyncMode: EARFrameSyncMode;
	bEnableAutomaticCameraOverlay: boolean;
	bEnableAutomaticCameraTracking: boolean;
	bResetCameraTracking: boolean;
	bResetTrackedObjects: boolean;
	CandidateImages: ARCandidateImage[];
	MaxNumSimultaneousImagesTracked: number;
	EnvironmentCaptureProbeType: EAREnvironmentCaptureProbeType;
	WorldMapData: number[];
	CandidateObjects: ARCandidateObject[];
	DesiredVideoFormat: ARVideoFormat;
	bUseOptimalVideoFormat: boolean;
	FaceTrackingDirection: EARFaceTrackingDirection;
	FaceTrackingUpdate: EARFaceTrackingUpdate;
	MaxNumberOfTrackedFaces: number;
	SerializedARCandidateImageDatabase: number[];
	EnabledSessionTrackingFeature: EARSessionTrackingFeature;
	SceneReconstructionMethod: EARSceneReconstruction;
	PlaneComponentClass: UnrealEngineClass;
	PointComponentClass: UnrealEngineClass;
	FaceComponentClass: UnrealEngineClass;
	ImageComponentClass: UnrealEngineClass;
	QRCodeComponentClass: UnrealEngineClass;
	PoseComponentClass: UnrealEngineClass;
	EnvironmentProbeComponentClass: UnrealEngineClass;
	ObjectComponentClass: UnrealEngineClass;
	MeshComponentClass: UnrealEngineClass;
	GeoAnchorComponentClass: UnrealEngineClass;
	DefaultMeshMaterial: MaterialInterface;
	DefaultWireframeMeshMaterial: MaterialInterface;
	static Load(ResourceName: string): ARSessionConfig;
	static Find(Outer: UObject, ResourceName: string): ARSessionConfig;
	static GetDefaultObject(): ARSessionConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSessionConfig;
	ShouldResetTrackedObjects(): boolean;
	ShouldResetCameraTracking(): boolean;
	ShouldRenderCameraOverlay(): boolean;
	ShouldEnableCameraTracking(): boolean;
	ShouldEnableAutoFocus(): boolean;
	SetWorldMapData(WorldMapData: number[]): void;
	SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: EARSessionTrackingFeature): void;
	SetSceneReconstructionMethod(InSceneReconstructionMethod: EARSceneReconstruction): void;
	SetResetTrackedObjects(bNewValue: boolean): void;
	SetResetCameraTracking(bNewValue: boolean): void;
	SetFaceTrackingUpdate(InUpdate: EARFaceTrackingUpdate): void;
	SetFaceTrackingDirection(InDirection: EARFaceTrackingDirection): void;
	SetEnableAutoFocus(bNewValue: boolean): void;
	SetDesiredVideoFormat(NewFormat: ARVideoFormat): void;
	SetCandidateObjectList(InCandidateObjects: ARCandidateObject[]): void;
	GetWorldMapData(): number[];
	GetWorldAlignment(): EARWorldAlignment;
	GetSessionType(): EARSessionType;
	GetSceneReconstructionMethod(): EARSceneReconstruction;
	GetPlaneDetectionMode(): EARPlaneDetectionMode;
	GetMaxNumSimultaneousImagesTracked(): number;
	GetLightEstimationMode(): EARLightEstimationMode;
	GetFrameSyncMode(): EARFrameSyncMode;
	GetFaceTrackingUpdate(): EARFaceTrackingUpdate;
	GetFaceTrackingDirection(): EARFaceTrackingDirection;
	GetEnvironmentCaptureProbeType(): EAREnvironmentCaptureProbeType;
	GetEnabledSessionTrackingFeature(): EARSessionTrackingFeature;
	GetDesiredVideoFormat(): ARVideoFormat;
	GetCandidateObjectList(): ARCandidateObject[];
	GetCandidateImageList(): ARCandidateImage[];
	AddCandidateObject(CandidateObject: ARCandidateObject): void;
	AddCandidateImage(NewCandidateImage: ARCandidateImage): void;
	static C(Other: UObject | any): ARSessionConfig;
	AddRuntimeCandidateImage(CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	StartARSession(): void;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static StartARSession(SessionConfig: ARSessionConfig): void;
}

declare type EARWorldMappingState = 'NotAvailable' | 'StillMappingNotRelocalizable' | 'StillMappingRelocalizable' | 'Mapped' | 'EARWorldMappingState_MAX';
declare var EARWorldMappingState : { NotAvailable:'NotAvailable',StillMappingNotRelocalizable:'StillMappingNotRelocalizable',StillMappingRelocalizable:'StillMappingRelocalizable',Mapped:'Mapped',EARWorldMappingState_MAX:'EARWorldMappingState_MAX', };
declare type EARTrackingQualityReason = 'None' | 'Initializing' | 'Relocalizing' | 'ExcessiveMotion' | 'InsufficientFeatures' | 'InsufficientLight' | 'BadState' | 'EARTrackingQualityReason_MAX';
declare var EARTrackingQualityReason : { None:'None',Initializing:'Initializing',Relocalizing:'Relocalizing',ExcessiveMotion:'ExcessiveMotion',InsufficientFeatures:'InsufficientFeatures',InsufficientLight:'InsufficientLight',BadState:'BadState',EARTrackingQualityReason_MAX:'EARTrackingQualityReason_MAX', };
declare type EARTrackingQuality = 'NotTracking' | 'OrientationOnly' | 'OrientationAndPosition' | 'EARTrackingQuality_MAX';
declare var EARTrackingQuality : { NotTracking:'NotTracking',OrientationOnly:'OrientationOnly',OrientationAndPosition:'OrientationAndPosition',EARTrackingQuality_MAX:'EARTrackingQuality_MAX', };
declare type EARTextureType = 'Unknown' | 'CameraImage' | 'CameraDepth' | 'EnvironmentCapture' | 'PersonSegmentationImage' | 'PersonSegmentationDepth' | 'SceneDepthMap' | 'SceneDepthConfidenceMap' | 'EARTextureType_MAX';
declare var EARTextureType : { Unknown:'Unknown',CameraImage:'CameraImage',CameraDepth:'CameraDepth',EnvironmentCapture:'EnvironmentCapture',PersonSegmentationImage:'PersonSegmentationImage',PersonSegmentationDepth:'PersonSegmentationDepth',SceneDepthMap:'SceneDepthMap',SceneDepthConfidenceMap:'SceneDepthConfidenceMap',EARTextureType_MAX:'EARTextureType_MAX', };
declare class ARTexture extends Texture { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): ARTexture;
	static Find(Outer: UObject, ResourceName: string): ARTexture;
	static GetDefaultObject(): ARTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTexture;
	static C(Other: UObject | any): ARTexture;
}

declare class ARLightEstimate extends UObject { 
	static Load(ResourceName: string): ARLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARLightEstimate;
	static GetDefaultObject(): ARLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLightEstimate;
	static C(Other: UObject | any): ARLightEstimate;
}

declare class ARCameraIntrinsics { 
	ImageResolution: IntPoint;
	FocalLength: Vector2D;
	PrincipalPoint: Vector2D;
	clone() : ARCameraIntrinsics;
	static C(Other: UObject | any): ARCameraIntrinsics;
	GetCameraIntrinsics(): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
}

declare class ARTextureCameraImage extends ARTexture { 
	static Load(ResourceName: string): ARTextureCameraImage;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraImage;
	static GetDefaultObject(): ARTextureCameraImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraImage;
	static C(Other: UObject | any): ARTextureCameraImage;
}

declare type EARDepthQuality = 'Unkown' | 'Low' | 'High' | 'EARDepthQuality_MAX';
declare var EARDepthQuality : { Unkown:'Unkown',Low:'Low',High:'High',EARDepthQuality_MAX:'EARDepthQuality_MAX', };
declare type EARDepthAccuracy = 'Unkown' | 'Approximate' | 'Accurate' | 'EARDepthAccuracy_MAX';
declare var EARDepthAccuracy : { Unkown:'Unkown',Approximate:'Approximate',Accurate:'Accurate',EARDepthAccuracy_MAX:'EARDepthAccuracy_MAX', };
declare class ARTextureCameraDepth extends ARTexture { 
	DepthQuality: EARDepthQuality;
	DepthAccuracy: EARDepthAccuracy;
	bIsTemporallySmoothed: boolean;
	static Load(ResourceName: string): ARTextureCameraDepth;
	static Find(Outer: UObject, ResourceName: string): ARTextureCameraDepth;
	static GetDefaultObject(): ARTextureCameraDepth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTextureCameraDepth;
	static C(Other: UObject | any): ARTextureCameraDepth;
}

declare type EARSessionStatus = 'NotStarted' | 'Running' | 'NotSupported' | 'FatalError' | 'PermissionNotGranted' | 'UnsupportedConfiguration' | 'Other' | 'EARSessionStatus_MAX';
declare var EARSessionStatus : { NotStarted:'NotStarted',Running:'Running',NotSupported:'NotSupported',FatalError:'FatalError',PermissionNotGranted:'PermissionNotGranted',UnsupportedConfiguration:'UnsupportedConfiguration',Other:'Other',EARSessionStatus_MAX:'EARSessionStatus_MAX', };
declare class ARSessionStatus { 
	AdditionalInfo: string;
	Status: EARSessionStatus;
	clone() : ARSessionStatus;
	static C(Other: UObject | any): ARSessionStatus;
	static GetARSessionStatus(): ARSessionStatus;
}

declare class ARSkeletonDefinition { 
	NumJoints: number;
	JointNames: string[];
	ParentIndices: number[];
	clone() : ARSkeletonDefinition;
	static C(Other: UObject | any): ARSkeletonDefinition;
}

declare type EARJointTransformSpace = 'Model' | 'ParentJoint' | 'EARJointTransformSpace_MAX';
declare var EARJointTransformSpace : { Model:'Model',ParentJoint:'ParentJoint',EARJointTransformSpace_MAX:'EARJointTransformSpace_MAX', };
declare class ARPose3D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointTransforms: Transform[];
	IsJointTracked: boolean[];
	JointTransformSpace: EARJointTransformSpace;
	clone() : ARPose3D;
	static C(Other: UObject | any): ARPose3D;
}

declare class ARTrackedPose extends ARTrackedGeometry { 
	TrackedPose: ARPose3D;
	static Load(ResourceName: string): ARTrackedPose;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPose;
	static GetDefaultObject(): ARTrackedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPose;
	GetTrackedPoseData(): ARPose3D;
	static C(Other: UObject | any): ARTrackedPose;
}

declare class ARTrackedPoint extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARTrackedPoint;
	static Find(Outer: UObject, ResourceName: string): ARTrackedPoint;
	static GetDefaultObject(): ARTrackedPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedPoint;
	static C(Other: UObject | any): ARTrackedPoint;
}

declare type EARPlaneOrientation = 'Horizontal' | 'Vertical' | 'Diagonal' | 'EARPlaneOrientation_MAX';
declare var EARPlaneOrientation : { Horizontal:'Horizontal',Vertical:'Vertical',Diagonal:'Diagonal',EARPlaneOrientation_MAX:'EARPlaneOrientation_MAX', };
declare class ARPlaneGeometry extends ARTrackedGeometry { 
	Orientation: EARPlaneOrientation;
	Center: Vector;
	Extent: Vector;
	BoundaryPolygon: Vector[];
	SubsumedBy: ARPlaneGeometry;
	static Load(ResourceName: string): ARPlaneGeometry;
	static Find(Outer: UObject, ResourceName: string): ARPlaneGeometry;
	static GetDefaultObject(): ARPlaneGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARPlaneGeometry;
	GetSubsumedBy(): ARPlaneGeometry;
	GetOrientation(): EARPlaneOrientation;
	GetExtent(): Vector;
	GetCenter(): Vector;
	GetBoundaryPolygonInLocalSpace(): Vector[];
	static C(Other: UObject | any): ARPlaneGeometry;
}

declare class ARTrackedImage extends ARTrackedGeometry { 
	DetectedImage: ARCandidateImage;
	EstimatedSize: Vector2D;
	static Load(ResourceName: string): ARTrackedImage;
	static Find(Outer: UObject, ResourceName: string): ARTrackedImage;
	static GetDefaultObject(): ARTrackedImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedImage;
	GetEstimateSize(): Vector2D;
	GetDetectedImage(): ARCandidateImage;
	static C(Other: UObject | any): ARTrackedImage;
}

declare class AREnvironmentCaptureProbeTexture extends TextureCube { 
	TextureType: EARTextureType;
	Timestamp: number;
	ExternalTextureGuid: Guid;
	Size: Vector2D;
	static Load(ResourceName: string): AREnvironmentCaptureProbeTexture;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbeTexture;
	static GetDefaultObject(): AREnvironmentCaptureProbeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbeTexture;
}

declare class AREnvironmentCaptureProbe extends ARTrackedGeometry { 
	Extent: Vector;
	EnvironmentCaptureTexture: AREnvironmentCaptureProbeTexture;
	static Load(ResourceName: string): AREnvironmentCaptureProbe;
	static Find(Outer: UObject, ResourceName: string): AREnvironmentCaptureProbe;
	static GetDefaultObject(): AREnvironmentCaptureProbe;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AREnvironmentCaptureProbe;
	GetExtent(): Vector;
	GetEnvironmentCaptureTexture(): AREnvironmentCaptureProbeTexture;
	static C(Other: UObject | any): AREnvironmentCaptureProbe;
}

declare class ARPose2D { 
	SkeletonDefinition: ARSkeletonDefinition;
	JointLocations: Vector2D[];
	IsJointTracked: boolean[];
	clone() : ARPose2D;
	static C(Other: UObject | any): ARPose2D;
}

declare class ARBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ARBlueprintLibrary;
	static GetDefaultObject(): ARBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBlueprintLibrary;
	static UnpinComponent(ComponentToUnpin: SceneComponent): void;
	static ToggleARCapture(bOnOff: boolean,CaptureType: EARCaptureType): boolean;
	static StopARSession(): void;
	static StartARSession(SessionConfig: ARSessionConfig): void;
	static SetEnabledXRCamera(bOnOff: boolean): void;
	static SetARWorldScale(InWorldScale: number): void;
	static SetARWorldOriginLocationAndRotation(OriginLocation: Vector,OriginRotation: Rotator,bIsTransformInWorldSpace: boolean,bMaintainUpDirection: boolean): void;
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static SaveARPinToLocalStore(InSaveName: string,InPin: ARPin): boolean;
	static ResizeXRCamera(InSize: IntPoint): IntPoint;
	static RemovePin(PinToRemove: ARPin): void;
	static RemoveARPinFromLocalStore(InSaveName: string): void;
	static RemoveAllARPinsFromLocalStore(): void;
	static PinComponentToTraceResult(ComponentToPin: SceneComponent,TraceResult: ARTraceResult,DebugName: string): ARPin;
	static PinComponentToARPin(ComponentToPin: SceneComponent,Pin: ARPin): boolean;
	static PinComponent(ComponentToPin: SceneComponent,PinToWorldTransform: Transform,TrackedGeometry: ARTrackedGeometry,DebugName: string): ARPin;
	static PauseARSession(): void;
	static LoadARPinsFromLocalStore(): any;
	static LineTraceTrackedObjects3D(Start: Vector,End: Vector,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static LineTraceTrackedObjects(ScreenCoord: Vector2D,bTestFeaturePoints: boolean,bTestGroundPlane: boolean,bTestPlaneExtents: boolean,bTestPlaneBoundaryPolygon: boolean): ARTraceResult[];
	static IsSessionTypeSupported(SessionType: EARSessionType): boolean;
	static IsSessionTrackingFeatureSupported(SessionType: EARSessionType,SessionTrackingFeature: EARSessionTrackingFeature): boolean;
	static IsSceneReconstructionSupported(SessionType: EARSessionType,SceneReconstructionMethod: EARSceneReconstruction): boolean;
	static IsARSupported(): boolean;
	static IsARPinLocalStoreSupported(): boolean;
	static IsARPinLocalStoreReady(): boolean;
	static GetWorldMappingStatus(): EARWorldMappingState;
	static GetTrackingQualityReason(): EARTrackingQualityReason;
	static GetTrackingQuality(): EARTrackingQuality;
	static GetSupportedVideoFormats(SessionType: EARSessionType): ARVideoFormat[];
	static GetSessionConfig(): ARSessionConfig;
	static GetPointCloud(): Vector[];
	static GetPersonSegmentationImage(): ARTexture;
	static GetPersonSegmentationDepthImage(): ARTexture;
	static GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static GetNumberOfTrackedFacesSupported(): number;
	static GetCurrentLightEstimate(): ARLightEstimate;
	static GetCameraIntrinsics(OutCameraIntrinsics?: ARCameraIntrinsics): {OutCameraIntrinsics: ARCameraIntrinsics, $: boolean};
	static GetCameraImage(): ARTextureCameraImage;
	static GetCameraDepth(): ARTextureCameraDepth;
	static GetARWorldScale(): number;
	static GetARTexture(TextureType: EARTextureType): ARTexture;
	static GetARSessionStatus(): ARSessionStatus;
	static GetAllTrackedPoses(): ARTrackedPose[];
	static GetAllTrackedPoints(): ARTrackedPoint[];
	static GetAllTrackedPlanes(): ARPlaneGeometry[];
	static GetAllTrackedImages(): ARTrackedImage[];
	static GetAllTrackedEnvironmentCaptureProbes(): AREnvironmentCaptureProbe[];
	static GetAllTracked2DPoses(): ARPose2D[];
	static GetAllPins(): ARPin[];
	static GetAllGeometriesByClass(GeometryClass: UnrealEngineClass): ARTrackedGeometry[];
	static GetAllGeometries(): ARTrackedGeometry[];
	static GetAlignmentTransform(): Transform;
	static FindTrackedPointsByName(PointName: string): ARTrackedPoint[];
	static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry,WorldContextObject: UObject,Color: LinearColor,OutlineThickness: number,PersistForSeconds: number): void;
	static DebugDrawPin(ARPin: ARPin,WorldContextObject: UObject,Color: LinearColor,Scale: number,PersistForSeconds: number): void;
	static CalculateClosestIntersection(StartPoints: Vector[],EndPoints: Vector[],ClosestIntersection?: Vector): {ClosestIntersection: Vector};
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig,CandidateTexture: Texture2D,FriendlyName: string,PhysicalWidth: number): ARCandidateImage;
	static AddManualEnvironmentCaptureProbe(Location: Vector,Extent: Vector): boolean;
	static C(Other: UObject | any): ARBlueprintLibrary;
}

declare class ARTraceResultLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ARTraceResultLibrary;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultLibrary;
	static GetDefaultObject(): ARTraceResultLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultLibrary;
	static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
	static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
	static GetLocalTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
	static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
	static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
	static C(Other: UObject | any): ARTraceResultLibrary;
}

declare class BlueprintAsyncActionBase extends UObject { 
	static Load(ResourceName: string): BlueprintAsyncActionBase;
	static Find(Outer: UObject, ResourceName: string): BlueprintAsyncActionBase;
	static GetDefaultObject(): BlueprintAsyncActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintAsyncActionBase;
	Activate(): void;
	static C(Other: UObject | any): BlueprintAsyncActionBase;
}

declare class ARBaseAsyncTaskBlueprintProxy extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARBaseAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARBaseAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBaseAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARBaseAsyncTaskBlueprintProxy;
}

declare class ARSaveWorldAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedWorld: number[]) => void>;
	static Load(ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARSaveWorldAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARSaveWorldAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSaveWorldAsyncTaskBlueprintProxy;
	static ARSaveWorld(WorldContextObject: UObject): ARSaveWorldAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARSaveWorldAsyncTaskBlueprintProxy;
}

declare class ARGetCandidateObjectAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(SavedObject: ARCandidateObject) => void>;
	static Load(ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static GetDefaultObject(): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static ARGetCandidateObject(WorldContextObject: UObject,Location: Vector,Extent: Vector): ARGetCandidateObjectAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): ARGetCandidateObjectAsyncTaskBlueprintProxy;
}

declare type EARServicePermissionRequestResult = 'Granted' | 'Denied' | 'EARServicePermissionRequestResult_MAX';
declare var EARServicePermissionRequestResult : { Granted:'Granted',Denied:'Denied',EARServicePermissionRequestResult_MAX:'EARServicePermissionRequestResult_MAX', };
declare type EARServiceInstallRequestResult = 'Installed' | 'DeviceNotCompatible' | 'UserDeclinedInstallation' | 'FatalError' | 'EARServiceInstallRequestResult_MAX';
declare var EARServiceInstallRequestResult : { Installed:'Installed',DeviceNotCompatible:'DeviceNotCompatible',UserDeclinedInstallation:'UserDeclinedInstallation',FatalError:'FatalError',EARServiceInstallRequestResult_MAX:'EARServiceInstallRequestResult_MAX', };
declare type EARServiceAvailability = 'UnknownError' | 'UnknownChecking' | 'UnknownTimedOut' | 'UnsupportedDeviceNotCapable' | 'SupportedNotInstalled' | 'SupportedVersionTooOld' | 'SupportedInstalled' | 'EARServiceAvailability_MAX';
declare var EARServiceAvailability : { UnknownError:'UnknownError',UnknownChecking:'UnknownChecking',UnknownTimedOut:'UnknownTimedOut',UnsupportedDeviceNotCapable:'UnsupportedDeviceNotCapable',SupportedNotInstalled:'SupportedNotInstalled',SupportedVersionTooOld:'SupportedVersionTooOld',SupportedInstalled:'SupportedInstalled',EARServiceAvailability_MAX:'EARServiceAvailability_MAX', };
declare class ARDependencyHandler extends UObject { 
	static Load(ResourceName: string): ARDependencyHandler;
	static Find(Outer: UObject, ResourceName: string): ARDependencyHandler;
	static GetDefaultObject(): ARDependencyHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARDependencyHandler;
	StartARSessionLatent(WorldContextObject: UObject,SessionConfig: ARSessionConfig,LatentInfo: LatentActionInfo): void;
	RequestARSessionPermission(WorldContextObject: UObject,SessionConfig: ARSessionConfig,LatentInfo: LatentActionInfo,OutPermissionResult?: EARServicePermissionRequestResult): {OutPermissionResult: EARServicePermissionRequestResult};
	InstallARService(WorldContextObject: UObject,LatentInfo: LatentActionInfo,OutInstallResult?: EARServiceInstallRequestResult): {OutInstallResult: EARServiceInstallRequestResult};
	static GetARDependencyHandler(): ARDependencyHandler;
	CheckARServiceAvailability(WorldContextObject: UObject,LatentInfo: LatentActionInfo,OutAvailability?: EARServiceAvailability): {OutAvailability: EARServiceAvailability};
	static C(Other: UObject | any): ARDependencyHandler;
}

declare type EARGeoTrackingStateReason = 'None' | 'NotAvailableAtLocation' | 'NeedLocationPermissions' | 'DevicePointedTooLow' | 'WorldTrackingUnstable' | 'WaitingForLocation' | 'GeoDataNotLoaded' | 'VisualLocalizationFailed' | 'WaitingForAvailabilityCheck' | 'EARGeoTrackingStateReason_MAX';
declare var EARGeoTrackingStateReason : { None:'None',NotAvailableAtLocation:'NotAvailableAtLocation',NeedLocationPermissions:'NeedLocationPermissions',DevicePointedTooLow:'DevicePointedTooLow',WorldTrackingUnstable:'WorldTrackingUnstable',WaitingForLocation:'WaitingForLocation',GeoDataNotLoaded:'GeoDataNotLoaded',VisualLocalizationFailed:'VisualLocalizationFailed',WaitingForAvailabilityCheck:'WaitingForAvailabilityCheck',EARGeoTrackingStateReason_MAX:'EARGeoTrackingStateReason_MAX', };
declare type EARGeoTrackingState = 'Initializing' | 'Localized' | 'Localizing' | 'NotAvailable' | 'EARGeoTrackingState_MAX';
declare var EARGeoTrackingState : { Initializing:'Initializing',Localized:'Localized',Localizing:'Localizing',NotAvailable:'NotAvailable',EARGeoTrackingState_MAX:'EARGeoTrackingState_MAX', };
declare type EARGeoTrackingAccuracy = 'Undetermined' | 'Low' | 'Medium' | 'High' | 'EARGeoTrackingAccuracy_MAX';
declare var EARGeoTrackingAccuracy : { Undetermined:'Undetermined',Low:'Low',Medium:'Medium',High:'High',EARGeoTrackingAccuracy_MAX:'EARGeoTrackingAccuracy_MAX', };
declare class ARGeoTrackingSupport extends UObject { 
	static Load(ResourceName: string): ARGeoTrackingSupport;
	static Find(Outer: UObject, ResourceName: string): ARGeoTrackingSupport;
	static GetDefaultObject(): ARGeoTrackingSupport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoTrackingSupport;
	static GetGeoTrackingSupport(): ARGeoTrackingSupport;
	GetGeoTrackingStateReason(): EARGeoTrackingStateReason;
	GetGeoTrackingState(): EARGeoTrackingState;
	GetGeoTrackingAccuracy(): EARGeoTrackingAccuracy;
	AddGeoAnchorAtLocationWithAltitude(Longitude: number,Latitude: number,AltitudeMeters: number,OptionalAnchorName: string): boolean;
	AddGeoAnchorAtLocation(Longitude: number,Latitude: number,OptionalAnchorName: string): boolean;
	static C(Other: UObject | any): ARGeoTrackingSupport;
}

declare class CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(bIsAvailable: boolean, Error: string) => void>;
	static Load(ResourceName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static GetDefaultObject(): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CheckGeoTrackingAvailabilityAtLocation(WorldContextObject: UObject,Longitude: number,Latitude: number): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static CheckGeoTrackingAvailability(WorldContextObject: UObject): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): CheckGeoTrackingAvailabilityAsyncTaskBlueprintProxy;
}

declare class GetGeoLocationAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy { 
	OnSuccess: UnrealEngineMulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
	OnFailed: UnrealEngineMulticastDelegate<(Longitude: number, Latitude: number, Altitude: number, Error: string) => void>;
	static Load(ResourceName: string): GetGeoLocationAsyncTaskBlueprintProxy;
	static Find(Outer: UObject, ResourceName: string): GetGeoLocationAsyncTaskBlueprintProxy;
	static GetDefaultObject(): GetGeoLocationAsyncTaskBlueprintProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GetGeoLocationAsyncTaskBlueprintProxy;
	static GetGeoLocationAtWorldPosition(WorldContextObject: UObject,WorldPosition: Vector): GetGeoLocationAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): GetGeoLocationAsyncTaskBlueprintProxy;
}

declare class ARLifeCycleComponent extends SceneComponent { 
	OnARActorSpawnedDelegate: UnrealEngineMulticastDelegate<(ComponentClass: UnrealEngineClass, NativeID: Guid, SpawnedActor: ARActor) => void>;
	OnARActorToBeDestroyedDelegate: UnrealEngineMulticastDelegate<(Actor: ARActor) => void>;
	static Load(ResourceName: string): ARLifeCycleComponent;
	static Find(Outer: UObject, ResourceName: string): ARLifeCycleComponent;
	static GetDefaultObject(): ARLifeCycleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARLifeCycleComponent;
	ServerSpawnARActor(ComponentClass: UnrealEngineClass,NativeID: Guid): void;
	ServerDestroyARActor(Actor: ARActor): void;
	static C(Other: UObject | any): ARLifeCycleComponent;
}

declare class ARBasicLightEstimate extends ARLightEstimate { 
	AmbientIntensityLumens: number;
	AmbientColorTemperatureKelvin: number;
	AmbientColor: LinearColor;
	static Load(ResourceName: string): ARBasicLightEstimate;
	static Find(Outer: UObject, ResourceName: string): ARBasicLightEstimate;
	static GetDefaultObject(): ARBasicLightEstimate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARBasicLightEstimate;
	GetAmbientIntensityLumens(): number;
	GetAmbientColorTemperatureKelvin(): number;
	GetAmbientColor(): LinearColor;
	static C(Other: UObject | any): ARBasicLightEstimate;
}

declare class AROriginActor extends Actor { 
	static GetDefaultObject(): AROriginActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AROriginActor;
	static C(Other: UObject | any): AROriginActor;
}

declare class GameMode extends GameModeBase { 
	MatchState: string;
	bDelayedStart: boolean;
	NumSpectators: number;
	NumPlayers: number;
	NumBots: number;
	MinRespawnDelay: number;
	NumTravellingPlayers: number;
	EngineMessageClass: UnrealEngineClass;
	InactivePlayerArray: PlayerState[];
	InactivePlayerStateLifeSpan: number;
	MaxInactivePlayers: number;
	bHandleDedicatedServerReplays: boolean;
	static GetDefaultObject(): GameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMode;
	StartMatch(): void;
	Say(Msg: string): void;
	RestartGame(): void;
	ReadyToStartMatch(): boolean;
	ReadyToEndMatch(): boolean;
	K2_OnSetMatchState(NewState: string): void;
	IsMatchInProgress(): boolean;
	GetMatchState(): string;
	EndMatch(): void;
	AbortMatch(): void;
	static C(Other: UObject | any): GameMode;
}

declare class GameState extends GameStateBase { 
	MatchState: string;
	PreviousMatchState: string;
	ElapsedTime: number;
	static GetDefaultObject(): GameState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameState;
	OnRep_MatchState(): void;
	OnRep_ElapsedTime(): void;
	static C(Other: UObject | any): GameState;
}

declare class ARSharedWorldGameState extends GameState { 
	PreviewImageData: number[];
	ARWorldData: number[];
	PreviewImageBytesTotal: number;
	ARWorldBytesTotal: number;
	PreviewImageBytesDelivered: number;
	ARWorldBytesDelivered: number;
	static GetDefaultObject(): ARSharedWorldGameState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldGameState;
	K2_OnARWorldMapIsReady(): void;
	static C(Other: UObject | any): ARSharedWorldGameState;
}

declare class ARSharedWorldGameMode extends GameMode { 
	BufferSizePerChunk: number;
	static GetDefaultObject(): ARSharedWorldGameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldGameMode;
	SetPreviewImageData(ImageData: number[]): void;
	SetARWorldSharingIsReady(): void;
	SetARSharedWorldData(ARWorldData: number[]): void;
	GetARSharedWorldGameState(): ARSharedWorldGameState;
	static C(Other: UObject | any): ARSharedWorldGameMode;
}

declare class ARSharedWorldPlayerController extends PlayerController { 
	static GetDefaultObject(): ARSharedWorldPlayerController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSharedWorldPlayerController;
	ServerMarkReadyForReceiving(): void;
	ClientUpdatePreviewImageData(Offset: number,Buffer: number[]): void;
	ClientUpdateARWorldData(Offset: number,Buffer: number[]): void;
	ClientInitSharedWorld(PreviewImageSize: number,ARWorldDataSize: number): void;
	static C(Other: UObject | any): ARSharedWorldPlayerController;
}

declare type ESkyLightSourceType = 'SLS_CapturedScene' | 'SLS_SpecifiedCubemap' | 'SLS_MAX';
declare var ESkyLightSourceType : { SLS_CapturedScene:'SLS_CapturedScene',SLS_SpecifiedCubemap:'SLS_SpecifiedCubemap',SLS_MAX:'SLS_MAX', };
declare type EOcclusionCombineMode = 'OCM_Minimum' | 'OCM_Multiply' | 'OCM_MAX';
declare var EOcclusionCombineMode : { OCM_Minimum:'OCM_Minimum',OCM_Multiply:'OCM_Multiply',OCM_MAX:'OCM_MAX', };
declare class SkyLightComponent extends LightComponentBase { 
	bRealTimeCapture: boolean;
	SourceType: ESkyLightSourceType;
	Cubemap: TextureCube;
	SourceCubemapAngle: number;
	CubemapResolution: number;
	SkyDistanceThreshold: number;
	bCaptureEmissiveOnly: boolean;
	bLowerHemisphereIsBlack: boolean;
	LowerHemisphereColor: LinearColor;
	OcclusionMaxDistance: number;
	Contrast: number;
	OcclusionExponent: number;
	MinOcclusion: number;
	OcclusionTint: Color;
	bCloudAmbientOcclusion: boolean;
	CloudAmbientOcclusionStrength: number;
	CloudAmbientOcclusionExtent: number;
	CloudAmbientOcclusionMapResolutionScale: number;
	CloudAmbientOcclusionApertureScale: number;
	OcclusionCombineMode: EOcclusionCombineMode;
	BlendDestinationCubemap: TextureCube;
	static Load(ResourceName: string): SkyLightComponent;
	static Find(Outer: UObject, ResourceName: string): SkyLightComponent;
	static GetDefaultObject(): SkyLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLightComponent;
	SetVolumetricScatteringIntensity(NewIntensity: number): void;
	SetOcclusionTint(InTint: Color): void;
	SetOcclusionExponent(InOcclusionExponent: number): void;
	SetOcclusionContrast(InOcclusionContrast: number): void;
	SetMinOcclusion(InMinOcclusion: number): void;
	SetLowerHemisphereColor(InLowerHemisphereColor: LinearColor): void;
	SetLightColor(NewLightColor: LinearColor): void;
	SetIntensity(NewIntensity: number): void;
	SetIndirectLightingIntensity(NewIntensity: number): void;
	SetCubemapBlend(SourceCubemap: TextureCube,DestinationCubemap: TextureCube,InBlendFraction: number): void;
	SetCubemap(NewCubemap: TextureCube): void;
	RecaptureSky(): void;
	static C(Other: UObject | any): SkyLightComponent;
}

declare class SkyLight extends Info { 
	LightComponent: SkyLightComponent;
	bEnabled: boolean;
	static GetDefaultObject(): SkyLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyLight;
	OnRep_bEnabled(): void;
	static C(Other: UObject | any): SkyLight;
}

declare class ARSkyLight extends SkyLight { 
	CaptureProbe: AREnvironmentCaptureProbe;
	static GetDefaultObject(): ARSkyLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARSkyLight;
	SetEnvironmentCaptureProbe(InCaptureProbe: AREnvironmentCaptureProbe): void;
	static C(Other: UObject | any): ARSkyLight;
}

declare class ARTraceResultDummy extends UObject { 
	static Load(ResourceName: string): ARTraceResultDummy;
	static Find(Outer: UObject, ResourceName: string): ARTraceResultDummy;
	static GetDefaultObject(): ARTraceResultDummy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTraceResultDummy;
	static C(Other: UObject | any): ARTraceResultDummy;
}

declare class ARTrackedQRCode extends ARTrackedImage { 
	QRCode: string;
	Version: number;
	static Load(ResourceName: string): ARTrackedQRCode;
	static Find(Outer: UObject, ResourceName: string): ARTrackedQRCode;
	static GetDefaultObject(): ARTrackedQRCode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedQRCode;
	static C(Other: UObject | any): ARTrackedQRCode;
}

declare type EAREye = 'LeftEye' | 'RightEye' | 'EAREye_MAX';
declare var EAREye : { LeftEye:'LeftEye',RightEye:'RightEye',EAREye_MAX:'EAREye_MAX', };
declare type EARFaceBlendShape = 'EyeBlinkLeft' | 'EyeLookDownLeft' | 'EyeLookInLeft' | 'EyeLookOutLeft' | 'EyeLookUpLeft' | 'EyeSquintLeft' | 'EyeWideLeft' | 'EyeBlinkRight' | 'EyeLookDownRight' | 'EyeLookInRight' | 'EyeLookOutRight' | 'EyeLookUpRight' | 'EyeSquintRight' | 'EyeWideRight' | 'JawForward' | 'JawLeft' | 'JawRight' | 'JawOpen' | 'MouthClose' | 'MouthFunnel' | 'MouthPucker' | 'MouthLeft' | 'MouthRight' | 'MouthSmileLeft' | 'MouthSmileRight' | 'MouthFrownLeft' | 'MouthFrownRight' | 'MouthDimpleLeft' | 'MouthDimpleRight' | 'MouthStretchLeft' | 'MouthStretchRight' | 'MouthRollLower' | 'MouthRollUpper' | 'MouthShrugLower' | 'MouthShrugUpper' | 'MouthPressLeft' | 'MouthPressRight' | 'MouthLowerDownLeft' | 'MouthLowerDownRight' | 'MouthUpperUpLeft' | 'MouthUpperUpRight' | 'BrowDownLeft' | 'BrowDownRight' | 'BrowInnerUp' | 'BrowOuterUpLeft' | 'BrowOuterUpRight' | 'CheekPuff' | 'CheekSquintLeft' | 'CheekSquintRight' | 'NoseSneerLeft' | 'NoseSneerRight' | 'TongueOut' | 'HeadYaw' | 'HeadPitch' | 'HeadRoll' | 'LeftEyeYaw' | 'LeftEyePitch' | 'LeftEyeRoll' | 'RightEyeYaw' | 'RightEyePitch' | 'RightEyeRoll' | 'MAX';
declare var EARFaceBlendShape : { EyeBlinkLeft:'EyeBlinkLeft',EyeLookDownLeft:'EyeLookDownLeft',EyeLookInLeft:'EyeLookInLeft',EyeLookOutLeft:'EyeLookOutLeft',EyeLookUpLeft:'EyeLookUpLeft',EyeSquintLeft:'EyeSquintLeft',EyeWideLeft:'EyeWideLeft',EyeBlinkRight:'EyeBlinkRight',EyeLookDownRight:'EyeLookDownRight',EyeLookInRight:'EyeLookInRight',EyeLookOutRight:'EyeLookOutRight',EyeLookUpRight:'EyeLookUpRight',EyeSquintRight:'EyeSquintRight',EyeWideRight:'EyeWideRight',JawForward:'JawForward',JawLeft:'JawLeft',JawRight:'JawRight',JawOpen:'JawOpen',MouthClose:'MouthClose',MouthFunnel:'MouthFunnel',MouthPucker:'MouthPucker',MouthLeft:'MouthLeft',MouthRight:'MouthRight',MouthSmileLeft:'MouthSmileLeft',MouthSmileRight:'MouthSmileRight',MouthFrownLeft:'MouthFrownLeft',MouthFrownRight:'MouthFrownRight',MouthDimpleLeft:'MouthDimpleLeft',MouthDimpleRight:'MouthDimpleRight',MouthStretchLeft:'MouthStretchLeft',MouthStretchRight:'MouthStretchRight',MouthRollLower:'MouthRollLower',MouthRollUpper:'MouthRollUpper',MouthShrugLower:'MouthShrugLower',MouthShrugUpper:'MouthShrugUpper',MouthPressLeft:'MouthPressLeft',MouthPressRight:'MouthPressRight',MouthLowerDownLeft:'MouthLowerDownLeft',MouthLowerDownRight:'MouthLowerDownRight',MouthUpperUpLeft:'MouthUpperUpLeft',MouthUpperUpRight:'MouthUpperUpRight',BrowDownLeft:'BrowDownLeft',BrowDownRight:'BrowDownRight',BrowInnerUp:'BrowInnerUp',BrowOuterUpLeft:'BrowOuterUpLeft',BrowOuterUpRight:'BrowOuterUpRight',CheekPuff:'CheekPuff',CheekSquintLeft:'CheekSquintLeft',CheekSquintRight:'CheekSquintRight',NoseSneerLeft:'NoseSneerLeft',NoseSneerRight:'NoseSneerRight',TongueOut:'TongueOut',HeadYaw:'HeadYaw',HeadPitch:'HeadPitch',HeadRoll:'HeadRoll',LeftEyeYaw:'LeftEyeYaw',LeftEyePitch:'LeftEyePitch',LeftEyeRoll:'LeftEyeRoll',RightEyeYaw:'RightEyeYaw',RightEyePitch:'RightEyePitch',RightEyeRoll:'RightEyeRoll',MAX:'MAX', };
declare class ARFaceGeometry extends ARTrackedGeometry { 
	LookAtTarget: Vector;
	bIsTracked: boolean;
	BlendShapes: any;
	LeftEyeTransform: Transform;
	RightEyeTransform: Transform;
	static Load(ResourceName: string): ARFaceGeometry;
	static Find(Outer: UObject, ResourceName: string): ARFaceGeometry;
	static GetDefaultObject(): ARFaceGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARFaceGeometry;
	GetWorldSpaceEyeTransform(Eye: EAREye): Transform;
	GetLocalSpaceEyeTransform(Eye: EAREye): Transform;
	GetBlendShapeValue(BlendShape: EARFaceBlendShape): number;
	GetBlendShapes(): any;
	static C(Other: UObject | any): ARFaceGeometry;
}

declare class ARTrackedObject extends ARTrackedGeometry { 
	DetectedObject: ARCandidateObject;
	static Load(ResourceName: string): ARTrackedObject;
	static Find(Outer: UObject, ResourceName: string): ARTrackedObject;
	static GetDefaultObject(): ARTrackedObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackedObject;
	GetDetectedObject(): ARCandidateObject;
	static C(Other: UObject | any): ARTrackedObject;
}

declare class ARMeshGeometry extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARMeshGeometry;
	static Find(Outer: UObject, ResourceName: string): ARMeshGeometry;
	static GetDefaultObject(): ARMeshGeometry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARMeshGeometry;
	GetObjectClassificationAtLocation(InWorldLocation: Vector,OutClassification?: EARObjectClassification,OutClassificationLocation?: Vector,MaxLocationDiff?: number): {OutClassification: EARObjectClassification, OutClassificationLocation: Vector, $: boolean};
	static C(Other: UObject | any): ARMeshGeometry;
}

declare class ARGeoAnchor extends ARTrackedGeometry { 
	static Load(ResourceName: string): ARGeoAnchor;
	static Find(Outer: UObject, ResourceName: string): ARGeoAnchor;
	static GetDefaultObject(): ARGeoAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARGeoAnchor;
	GetLongitude(): number;
	GetLatitude(): number;
	GetAltitudeSource(): EARAltitudeSource;
	GetAltitudeMeters(): number;
	static C(Other: UObject | any): ARGeoAnchor;
}

declare class ARTrackableNotifyComponent extends ActorComponent { 
	OnAddTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnUpdateTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnRemoveTrackedGeometry: UnrealEngineMulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
	OnAddTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnUpdateTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnRemoveTrackedPlane: UnrealEngineMulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
	OnAddTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnUpdateTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnRemoveTrackedPoint: UnrealEngineMulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
	OnAddTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnUpdateTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnRemoveTrackedImage: UnrealEngineMulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
	OnAddTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnUpdateTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnRemoveTrackedFace: UnrealEngineMulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
	OnAddTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnUpdateTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnRemoveTrackedEnvProbe: UnrealEngineMulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
	OnAddTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	OnUpdateTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	OnRemoveTrackedObject: UnrealEngineMulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
	static Load(ResourceName: string): ARTrackableNotifyComponent;
	static Find(Outer: UObject, ResourceName: string): ARTrackableNotifyComponent;
	static GetDefaultObject(): ARTrackableNotifyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTrackableNotifyComponent;
	static C(Other: UObject | any): ARTrackableNotifyComponent;
}

declare class ARTypesDummyClass extends UObject { 
	static Load(ResourceName: string): ARTypesDummyClass;
	static Find(Outer: UObject, ResourceName: string): ARTypesDummyClass;
	static GetDefaultObject(): ARTypesDummyClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ARTypesDummyClass;
	static C(Other: UObject | any): ARTypesDummyClass;
}

declare type ESpectatorScreenMode = 'Disabled' | 'SingleEyeLetterboxed' | 'Undistorted' | 'Distorted' | 'SingleEye' | 'SingleEyeCroppedToFill' | 'Texture' | 'TexturePlusEye' | 'ESpectatorScreenMode_MAX';
declare var ESpectatorScreenMode : { Disabled:'Disabled',SingleEyeLetterboxed:'SingleEyeLetterboxed',Undistorted:'Undistorted',Distorted:'Distorted',SingleEye:'SingleEye',SingleEyeCroppedToFill:'SingleEyeCroppedToFill',Texture:'Texture',TexturePlusEye:'TexturePlusEye',ESpectatorScreenMode_MAX:'ESpectatorScreenMode_MAX', };
declare type EOrientPositionSelector = 'Orientation' | 'Position' | 'OrientationAndPosition' | 'EOrientPositionSelector_MAX';
declare var EOrientPositionSelector : { Orientation:'Orientation',Position:'Position',OrientationAndPosition:'OrientationAndPosition',EOrientPositionSelector_MAX:'EOrientPositionSelector_MAX', };
declare type EHMDWornState = 'Unknown' | 'Worn' | 'NotWorn' | 'EHMDWornState_MAX';
declare var EHMDWornState : { Unknown:'Unknown',Worn:'Worn',NotWorn:'NotWorn',EHMDWornState_MAX:'EHMDWornState_MAX', };
declare type EXRTrackedDeviceType = 'HeadMountedDisplay' | 'Controller' | 'TrackingReference' | 'Other' | 'Invalid' | 'Any' | 'EXRTrackedDeviceType_MAX';
declare var EXRTrackedDeviceType : { HeadMountedDisplay:'HeadMountedDisplay',Controller:'Controller',TrackingReference:'TrackingReference',Other:'Other',Invalid:'Invalid',Any:'Any',EXRTrackedDeviceType_MAX:'EXRTrackedDeviceType_MAX', };
declare type EXRDeviceConnectionResult = 'NoTrackingSystem' | 'FeatureNotSupported' | 'NoValidViewport' | 'MiscFailure' | 'Success' | 'EXRDeviceConnectionResult_MAX';
declare var EXRDeviceConnectionResult : { NoTrackingSystem:'NoTrackingSystem',FeatureNotSupported:'FeatureNotSupported',NoValidViewport:'NoValidViewport',MiscFailure:'MiscFailure',Success:'Success',EXRDeviceConnectionResult_MAX:'EXRDeviceConnectionResult_MAX', };
declare type ESpatialInputGestureAxis = 'None' | 'Manipulation' | 'Navigation' | 'NavigationRails' | 'ESpatialInputGestureAxis_MAX';
declare var ESpatialInputGestureAxis : { None:'None',Manipulation:'Manipulation',Navigation:'Navigation',NavigationRails:'NavigationRails',ESpatialInputGestureAxis_MAX:'ESpatialInputGestureAxis_MAX', };
declare class XRGestureConfig { 
	bTap: boolean;
	bHold: boolean;
	AxisGesture: ESpatialInputGestureAxis;
	bNavigationAxisX: boolean;
	bNavigationAxisY: boolean;
	bNavigationAxisZ: boolean;
	clone() : XRGestureConfig;
	static C(Other: UObject | any): XRGestureConfig;
	ConfigureGestures(): boolean;
	static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;
}

declare class HeadMountedDisplayFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): HeadMountedDisplayFunctionLibrary;
	static GetDefaultObject(): HeadMountedDisplayFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HeadMountedDisplayFunctionLibrary;
	static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
	static SetWorldToMetersScale(WorldContext: UObject,NewScale: number): void;
	static SetTrackingOrigin(Origin: EHMDTrackingOrigin): void;
	static SetSpectatorScreenTexture(InTexture: Texture): void;
	static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D,EyeRectMax: Vector2D,TextureRectMin: Vector2D,TextureRectMax: Vector2D,bDrawEyeFirst: boolean,bClearBlack: boolean,bUseAlpha: boolean): void;
	static SetSpectatorScreenMode(Mode: ESpectatorScreenMode): void;
	static SetClippingPlanes(Near: number,Far: number): void;
	static ResetOrientationAndPosition(Yaw: number,Options: EOrientPositionSelector): void;
	static IsSpectatorScreenModeControllable(): boolean;
	static IsInLowPersistenceMode(): boolean;
	static IsHeadMountedDisplayEnabled(): boolean;
	static IsHeadMountedDisplayConnected(): boolean;
	static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;
	static HasValidTrackingPosition(): boolean;
	static GetXRSystemFlags(): number;
	static GetWorldToMetersScale(WorldContext: UObject): number;
	static GetVRFocusState(bUseFocus?: boolean,bHasFocus?: boolean): {bUseFocus: boolean, bHasFocus: boolean};
	static GetVersionString(): string;
	static GetTrackingToWorldTransform(WorldContext: UObject): Transform;
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,LeftFOV?: number,RightFOV?: number,TopFOV?: number,BottomFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,index?: number): {Origin: Vector, Rotation: Rotator, LeftFOV: number, RightFOV: number, TopFOV: number, BottomFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	static GetTrackingOrigin(): EHMDTrackingOrigin;
	static GetScreenPercentage(): number;
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	static GetPlayAreaBounds(Origin: EHMDTrackingOrigin): Vector2D;
	static GetPixelDensity(): number;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static GetNumOfTrackingSensors(): number;
	static GetMotionControllerData(WorldContext: UObject,Hand: EControllerHand,MotionControllerData?: XRMotionControllerData): {MotionControllerData: XRMotionControllerData};
	static GetHMDWornState(): EHMDWornState;
	static GetHMDDeviceName(): string;
	static GetHMDData(WorldContext: UObject,HMDData?: XRHMDData): {HMDData: XRHMDData};
	static GetDeviceWorldPose(WorldContext: UObject,XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, position: Vector};
	static GetDevicePose(XRDeviceId: XRDeviceId,bIsTracked?: boolean,Orientation?: Rotator,bHasPositionalTracking?: boolean,position?: Vector): {bIsTracked: boolean, Orientation: Rotator, bHasPositionalTracking: boolean, position: Vector};
	static GetControllerTransformForTime(WorldContext: UObject,ControllerIndex: number,MotionSource: string,Time: Timespan,bTimeWasUsed?: boolean,Orientation?: Rotator,position?: Vector,bProvidedLinearVelocity?: boolean,LinearVelocity?: Vector,bProvidedAngularVelocity?: boolean,AngularVelocityRadPerSec?: Vector,bProvidedLinearAcceleration?: boolean,LinearAcceleration?: Vector): {bTimeWasUsed: boolean, Orientation: Rotator, position: Vector, bProvidedLinearVelocity: boolean, LinearVelocity: Vector, bProvidedAngularVelocity: boolean, AngularVelocityRadPerSec: Vector, bProvidedLinearAcceleration: boolean, LinearAcceleration: Vector, $: boolean};
	static EnumerateTrackedDevices(SystemId: string,DeviceType: EXRTrackedDeviceType): XRDeviceId[];
	static EnableLowPersistenceMode(bEnable: boolean): void;
	static EnableHMD(bEnable: boolean): boolean;
	static DisconnectRemoteXRDevice(): void;
	static ConnectRemoteXRDevice(IpAddress: string,BitRate: number): EXRDeviceConnectionResult;
	static ConfigureGestures(GestureConfig: XRGestureConfig): boolean;
	static ClearXRTimedInputActionDelegate(ActionPath: string): void;
	static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
	static BreakKey(InKey: Key,InteractionProfile?: string,Hand?: EControllerHand,MotionSource?: string,Indentifier?: string,Component?: string): {InteractionProfile: string, Hand: EControllerHand, MotionSource: string, Indentifier: string, Component: string};
	static C(Other: UObject | any): HeadMountedDisplayFunctionLibrary;
}

declare type EHandKeypoint = 'Palm' | 'Wrist' | 'ThumbMetacarpal' | 'ThumbProximal' | 'ThumbDistal' | 'ThumbTip' | 'IndexMetacarpal' | 'IndexProximal' | 'IndexIntermediate' | 'IndexDistal' | 'IndexTip' | 'MiddleMetacarpal' | 'MiddleProximal' | 'MiddleIntermediate' | 'MiddleDistal' | 'MiddleTip' | 'RingMetacarpal' | 'RingProximal' | 'RingIntermediate' | 'RingDistal' | 'RingTip' | 'LittleMetacarpal' | 'LittleProximal' | 'LittleIntermediate' | 'LittleDistal' | 'LittleTip' | 'EHandKeypoint_MAX';
declare var EHandKeypoint : { Palm:'Palm',Wrist:'Wrist',ThumbMetacarpal:'ThumbMetacarpal',ThumbProximal:'ThumbProximal',ThumbDistal:'ThumbDistal',ThumbTip:'ThumbTip',IndexMetacarpal:'IndexMetacarpal',IndexProximal:'IndexProximal',IndexIntermediate:'IndexIntermediate',IndexDistal:'IndexDistal',IndexTip:'IndexTip',MiddleMetacarpal:'MiddleMetacarpal',MiddleProximal:'MiddleProximal',MiddleIntermediate:'MiddleIntermediate',MiddleDistal:'MiddleDistal',MiddleTip:'MiddleTip',RingMetacarpal:'RingMetacarpal',RingProximal:'RingProximal',RingIntermediate:'RingIntermediate',RingDistal:'RingDistal',RingTip:'RingTip',LittleMetacarpal:'LittleMetacarpal',LittleProximal:'LittleProximal',LittleIntermediate:'LittleIntermediate',LittleDistal:'LittleDistal',LittleTip:'LittleTip',EHandKeypoint_MAX:'EHandKeypoint_MAX', };
declare class HandKeypointConversion extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HandKeypointConversion;
	static Find(Outer: UObject, ResourceName: string): HandKeypointConversion;
	static GetDefaultObject(): HandKeypointConversion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HandKeypointConversion;
	static Conv_HandKeypointToInt32(Input: EHandKeypoint): number;
	static C(Other: UObject | any): HandKeypointConversion;
}

declare class MotionTrackedDeviceFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MotionTrackedDeviceFunctionLibrary;
	static GetDefaultObject(): MotionTrackedDeviceFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionTrackedDeviceFunctionLibrary;
	static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean): void;
	static IsMotionTrackingEnabledForSource(PlayerIndex: number,SourceName: string): boolean;
	static IsMotionTrackingEnabledForDevice(PlayerIndex: number,Hand: EControllerHand): boolean;
	static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static IsMotionTrackedDeviceCountManagementNecessary(): boolean;
	static IsMotionSourceTracking(PlayerIndex: number,SourceName: string): boolean;
	static GetMotionTrackingEnabledControllerCount(): number;
	static GetMaximumMotionTrackedControllerCount(): number;
	static GetActiveTrackingSystemName(): string;
	static EnumerateMotionSources(): string[];
	static EnableMotionTrackingOfSource(PlayerIndex: number,SourceName: string): boolean;
	static EnableMotionTrackingOfDevice(PlayerIndex: number,Hand: EControllerHand): boolean;
	static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
	static DisableMotionTrackingOfSource(PlayerIndex: number,SourceName: string): void;
	static DisableMotionTrackingOfDevice(PlayerIndex: number,Hand: EControllerHand): void;
	static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number): void;
	static DisableMotionTrackingOfAllControllers(): void;
	static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
	static C(Other: UObject | any): MotionTrackedDeviceFunctionLibrary;
}

declare class VRNotificationsComponent extends ActorComponent { 
	HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDTrackingInitializedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDLostDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDReconnectedDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDConnectCanceledDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDPutOnHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	HMDRemovedFromHeadDelegate: UnrealEngineMulticastDelegate<() => void>;
	VRControllerRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): VRNotificationsComponent;
	static Find(Outer: UObject, ResourceName: string): VRNotificationsComponent;
	static GetDefaultObject(): VRNotificationsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRNotificationsComponent;
	static C(Other: UObject | any): VRNotificationsComponent;
}

declare class XRAssetFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): XRAssetFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): XRAssetFunctionLibrary;
	static GetDefaultObject(): XRAssetFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): XRAssetFunctionLibrary;
	static AddNamedDeviceVisualizationComponentBlocking(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId): {XRDeviceId: XRDeviceId, $: PrimitiveComponent};
	static AddDeviceVisualizationComponentBlocking(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform): PrimitiveComponent;
	static C(Other: UObject | any): XRAssetFunctionLibrary;
}

declare class AsyncTask_LoadXRDeviceVisComponent extends BlueprintAsyncActionBase { 
	OnModelLoaded: UnrealEngineMulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
	OnLoadFailure: UnrealEngineMulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
	SpawnedComponent: PrimitiveComponent;
	static Load(ResourceName: string): AsyncTask_LoadXRDeviceVisComponent;
	static Find(Outer: UObject, ResourceName: string): AsyncTask_LoadXRDeviceVisComponent;
	static GetDefaultObject(): AsyncTask_LoadXRDeviceVisComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTask_LoadXRDeviceVisComponent;
	static AddNamedDeviceVisualizationComponentAsync(Target: Actor,SystemName: string,DeviceName: string,bManualAttachment: boolean,RelativeTransform: Transform,XRDeviceId?: XRDeviceId,NewComponent?: PrimitiveComponent): {XRDeviceId: XRDeviceId, NewComponent: PrimitiveComponent, $: AsyncTask_LoadXRDeviceVisComponent};
	static AddDeviceVisualizationComponentAsync(Target: Actor,XRDeviceId: XRDeviceId,bManualAttachment: boolean,RelativeTransform: Transform,NewComponent?: PrimitiveComponent): {NewComponent: PrimitiveComponent, $: AsyncTask_LoadXRDeviceVisComponent};
	static C(Other: UObject | any): AsyncTask_LoadXRDeviceVisComponent;
}

declare class XRLoadingScreenFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): XRLoadingScreenFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): XRLoadingScreenFunctionLibrary;
	static GetDefaultObject(): XRLoadingScreenFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): XRLoadingScreenFunctionLibrary;
	static ShowLoadingScreen(): void;
	static SetLoadingScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static HideLoadingScreen(): void;
	static ClearLoadingScreenSplashes(): void;
	static AddLoadingScreenSplash(Texture: Texture,Translation: Vector,Rotation: Rotator,Size: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	static C(Other: UObject | any): XRLoadingScreenFunctionLibrary;
}

declare class ActorTransformer extends ViewportTransformer { 
	static Load(ResourceName: string): ActorTransformer;
	static Find(Outer: UObject, ResourceName: string): ActorTransformer;
	static GetDefaultObject(): ActorTransformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorTransformer;
	static C(Other: UObject | any): ActorTransformer;
}

declare class ViewportInteractableInterface extends Interface { 
	static Load(ResourceName: string): ViewportInteractableInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractableInterface;
	static GetDefaultObject(): ViewportInteractableInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractableInterface;
	static C(Other: UObject | any): ViewportInteractableInterface;
}

declare class TranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): TranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): TranslationDragOperation;
	static GetDefaultObject(): TranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationDragOperation;
	static C(Other: UObject | any): TranslationDragOperation;
}

declare class PlaneTranslationDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): PlaneTranslationDragOperation;
	static Find(Outer: UObject, ResourceName: string): PlaneTranslationDragOperation;
	static GetDefaultObject(): PlaneTranslationDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneTranslationDragOperation;
	static C(Other: UObject | any): PlaneTranslationDragOperation;
}

declare class RotateOnAngleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): RotateOnAngleDragOperation;
	static Find(Outer: UObject, ResourceName: string): RotateOnAngleDragOperation;
	static GetDefaultObject(): RotateOnAngleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotateOnAngleDragOperation;
	static C(Other: UObject | any): RotateOnAngleDragOperation;
}

declare class ScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): ScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): ScaleDragOperation;
	static GetDefaultObject(): ScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleDragOperation;
	static C(Other: UObject | any): ScaleDragOperation;
}

declare class UniformScaleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): UniformScaleDragOperation;
	static Find(Outer: UObject, ResourceName: string): UniformScaleDragOperation;
	static GetDefaultObject(): UniformScaleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleDragOperation;
	static C(Other: UObject | any): UniformScaleDragOperation;
}

declare class AxisGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): AxisGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): AxisGizmoHandleGroup;
	static GetDefaultObject(): AxisGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisGizmoHandleGroup;
	static C(Other: UObject | any): AxisGizmoHandleGroup;
}

declare class GizmoHandleMeshComponent extends StaticMeshComponent { 
	static Load(ResourceName: string): GizmoHandleMeshComponent;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleMeshComponent;
	static GetDefaultObject(): GizmoHandleMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleMeshComponent;
	static C(Other: UObject | any): GizmoHandleMeshComponent;
}

declare class UniformScaleGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): UniformScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): UniformScaleGizmoHandleGroup;
	static GetDefaultObject(): UniformScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleGizmoHandleGroup;
	static C(Other: UObject | any): UniformScaleGizmoHandleGroup;
}

declare class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotTranslationGizmoHandleGroup;
}

declare class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotScaleGizmoHandleGroup;
	static GetDefaultObject(): PivotScaleGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotScaleGizmoHandleGroup;
	static C(Other: UObject | any): PivotScaleGizmoHandleGroup;
}

declare class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	static Load(ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static GetDefaultObject(): PivotPlaneTranslationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject | any): PivotPlaneTranslationGizmoHandleGroup;
}

declare class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	RootFullRotationHandleComponent: SceneComponent;
	FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
	StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootStartRotationIdicatorComponent: SceneComponent;
	DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
	RootDeltaRotationIndicatorComponent: SceneComponent;
	static Load(ResourceName: string): PivotRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotRotationGizmoHandleGroup;
	static GetDefaultObject(): PivotRotationGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotRotationGizmoHandleGroup;
	static C(Other: UObject | any): PivotRotationGizmoHandleGroup;
}

declare class StretchGizmoHandleGroup extends GizmoHandleGroup { 
	static Load(ResourceName: string): StretchGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleGroup;
	static GetDefaultObject(): StretchGizmoHandleGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleGroup;
	static C(Other: UObject | any): StretchGizmoHandleGroup;
}

declare class PivotTransformGizmo extends BaseTransformGizmo { 
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
	ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
	PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
	RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	LastDraggingHandle: ActorComponent;
	static GetDefaultObject(): PivotTransformGizmo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTransformGizmo;
	static C(Other: UObject | any): PivotTransformGizmo;
}

declare class StretchGizmoHandleDragOperation extends ViewportDragOperation { 
	static Load(ResourceName: string): StretchGizmoHandleDragOperation;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleDragOperation;
	static GetDefaultObject(): StretchGizmoHandleDragOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleDragOperation;
	static C(Other: UObject | any): StretchGizmoHandleDragOperation;
}

declare type ELocalizationTargetConflictStatus = 'Unknown' | 'ConflictsPresent' | 'Clear' | 'ELocalizationTargetConflictStatus_MAX';
declare var ELocalizationTargetConflictStatus : { Unknown:'Unknown',ConflictsPresent:'ConflictsPresent',Clear:'Clear',ELocalizationTargetConflictStatus_MAX:'ELocalizationTargetConflictStatus_MAX', };
declare type ELocalizationGatherPathRoot = 'Auto' | 'Engine' | 'Project' | 'ELocalizationGatherPathRoot_MAX';
declare var ELocalizationGatherPathRoot : { Auto:'Auto',Engine:'Engine',Project:'Project',ELocalizationGatherPathRoot_MAX:'ELocalizationGatherPathRoot_MAX', };
declare class GatherTextSearchDirectory { 
	PathRoot: ELocalizationGatherPathRoot;
	Path: string;
	clone() : GatherTextSearchDirectory;
	static C(Other: UObject | any): GatherTextSearchDirectory;
}

declare class GatherTextExcludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextExcludePath;
	static C(Other: UObject | any): GatherTextExcludePath;
}

declare class GatherTextFileExtension { 
	Pattern: string;
	clone() : GatherTextFileExtension;
	static C(Other: UObject | any): GatherTextFileExtension;
}

declare class GatherTextFromTextFilesConfiguration { 
	IsEnabled: boolean;
	SearchDirectories: GatherTextSearchDirectory[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromTextFilesConfiguration;
	static C(Other: UObject | any): GatherTextFromTextFilesConfiguration;
}

declare class GatherTextIncludePath { 
	PathRoot: ELocalizationGatherPathRoot;
	Pattern: string;
	clone() : GatherTextIncludePath;
	static C(Other: UObject | any): GatherTextIncludePath;
}

declare class GatherTextFromPackagesConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	FileExtensions: GatherTextFileExtension[];
	Collections: string[];
	ExcludeClasses: SoftClassPath[];
	ShouldExcludeDerivedClasses: boolean;
	ShouldGatherFromEditorOnlyData: boolean;
	SkipGatherCache: boolean;
	clone() : GatherTextFromPackagesConfiguration;
	static C(Other: UObject | any): GatherTextFromPackagesConfiguration;
}

declare class MetaDataKeyName { 
	Name: string;
	clone() : MetaDataKeyName;
	static C(Other: UObject | any): MetaDataKeyName;
}

declare class MetaDataTextKeyPattern { 
	Pattern: string;
	clone() : MetaDataTextKeyPattern;
	static C(Other: UObject | any): MetaDataTextKeyPattern;
}

declare class MetaDataKeyGatherSpecification { 
	MetaDataKey: MetaDataKeyName;
	TextNamespace: string;
	TextKeyPattern: MetaDataTextKeyPattern;
	clone() : MetaDataKeyGatherSpecification;
	static C(Other: UObject | any): MetaDataKeyGatherSpecification;
}

declare class GatherTextFromMetaDataConfiguration { 
	IsEnabled: boolean;
	IncludePathWildcards: GatherTextIncludePath[];
	ExcludePathWildcards: GatherTextExcludePath[];
	KeySpecifications: MetaDataKeyGatherSpecification[];
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromMetaDataConfiguration;
	static C(Other: UObject | any): GatherTextFromMetaDataConfiguration;
}

declare type ELocalizedTextCollapseMode = 'IdenticalTextIdAndSource' | 'IdenticalPackageIdTextIdAndSource' | 'IdenticalNamespaceAndSource' | 'ELocalizedTextCollapseMode_MAX';
declare var ELocalizedTextCollapseMode : { IdenticalTextIdAndSource:'IdenticalTextIdAndSource',IdenticalPackageIdTextIdAndSource:'IdenticalPackageIdTextIdAndSource',IdenticalNamespaceAndSource:'IdenticalNamespaceAndSource',ELocalizedTextCollapseMode_MAX:'ELocalizedTextCollapseMode_MAX', };
declare type EPortableObjectFormat = 'Unreal' | 'Crowdin' | 'EPortableObjectFormat_MAX';
declare var EPortableObjectFormat : { Unreal:'Unreal',Crowdin:'Crowdin',EPortableObjectFormat_MAX:'EPortableObjectFormat_MAX', };
declare class LocalizationExportingSettings { 
	CollapseMode: ELocalizedTextCollapseMode;
	POFormat: EPortableObjectFormat;
	ShouldPersistCommentsOnExport: boolean;
	ShouldAddSourceLocationsAsComments: boolean;
	clone() : LocalizationExportingSettings;
	static C(Other: UObject | any): LocalizationExportingSettings;
}

declare class LocalizationCompilationSettings { 
	SkipSourceCheck: boolean;
	ValidateFormatPatterns: boolean;
	ValidateSafeWhitespace: boolean;
	clone() : LocalizationCompilationSettings;
	static C(Other: UObject | any): LocalizationCompilationSettings;
}

declare class LocalizationImportDialogueSettings { 
	RawAudioPath: DirectoryPath;
	ImportedDialogueFolder: string;
	bImportNativeAsSource: boolean;
	clone() : LocalizationImportDialogueSettings;
	static C(Other: UObject | any): LocalizationImportDialogueSettings;
}

declare class CultureStatistics { 
	CultureName: string;
	WordCount: any;
	clone() : CultureStatistics;
	static C(Other: UObject | any): CultureStatistics;
}

declare class LocalizationTargetSettings { 
	Name: string;
	Guid: Guid;
	ConflictStatus: ELocalizationTargetConflictStatus;
	TargetDependencies: Guid[];
	AdditionalManifestDependencies: FilePath[];
	RequiredModuleNames: string[];
	GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
	GatherFromPackages: GatherTextFromPackagesConfiguration;
	GatherFromMetaData: GatherTextFromMetaDataConfiguration;
	ExportSettings: LocalizationExportingSettings;
	CompileSettings: LocalizationCompilationSettings;
	ImportDialogueSettings: LocalizationImportDialogueSettings;
	NativeCultureIndex: number;
	SupportedCulturesStatistics: CultureStatistics[];
	clone() : LocalizationTargetSettings;
	static C(Other: UObject | any): LocalizationTargetSettings;
}

declare class LocalizationTarget extends UObject { 
	Settings: LocalizationTargetSettings;
	static Load(ResourceName: string): LocalizationTarget;
	static Find(Outer: UObject, ResourceName: string): LocalizationTarget;
	static GetDefaultObject(): LocalizationTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTarget;
	static C(Other: UObject | any): LocalizationTarget;
}

declare class LocalizationTargetSet extends UObject { 
	TargetObjects: LocalizationTarget[];
	static Load(ResourceName: string): LocalizationTargetSet;
	static Find(Outer: UObject, ResourceName: string): LocalizationTargetSet;
	static GetDefaultObject(): LocalizationTargetSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTargetSet;
	static C(Other: UObject | any): LocalizationTargetSet;
}

declare class LocalizationSettings extends UObject { 
	EngineTargetSet: LocalizationTargetSet;
	EngineTargetsSettings: LocalizationTargetSettings[];
	GameTargetSet: LocalizationTargetSet;
	GameTargetsSettings: LocalizationTargetSettings[];
	static Load(ResourceName: string): LocalizationSettings;
	static Find(Outer: UObject, ResourceName: string): LocalizationSettings;
	static GetDefaultObject(): LocalizationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationSettings;
	static C(Other: UObject | any): LocalizationSettings;
}

declare class InternationalizationExportSettings extends UObject { 
	CulturesToGenerate: string[];
	CommandletClass: string;
	SourcePath: string;
	DestinationPath: string;
	PortableObjectName: string;
	ManifestName: string;
	ArchiveName: string;
	bExportLoc: boolean;
	bImportLoc: boolean;
	bUseCultureDirectory: boolean;
	static Load(ResourceName: string): InternationalizationExportSettings;
	static Find(Outer: UObject, ResourceName: string): InternationalizationExportSettings;
	static GetDefaultObject(): InternationalizationExportSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationExportSettings;
	static C(Other: UObject | any): InternationalizationExportSettings;
}

declare class TranslationPickerSettings extends UObject { 
	bSubmitTranslationPickerChangesToLocalizationService: boolean;
	static Load(ResourceName: string): TranslationPickerSettings;
	static Find(Outer: UObject, ResourceName: string): TranslationPickerSettings;
	static GetDefaultObject(): TranslationPickerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationPickerSettings;
	static C(Other: UObject | any): TranslationPickerSettings;
}

declare class DateTime { 
	clone() : DateTime;
	static C(Other: UObject | any): DateTime;
	AsDate_DateTime(): string;
	AsDateTime_DateTime(): string;
	AsTime_DateTime(): string;
	AsTimeZoneDate_DateTime(InTimeZone: string): string;
	AsTimeZoneDateTime_DateTime(InTimeZone: string): string;
	AsTimeZoneTime_DateTime(InTimeZone: string): string;
	Add_DateTimeDateTime(B: DateTime): DateTime;
	Add_DateTimeTimespan(B: Timespan): DateTime;
	BreakDateTime(Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	EqualEqual_DateTimeDateTime(B: DateTime): boolean;
	GetDate(): DateTime;
	GetDay(): number;
	GetDayOfYear(): number;
	GetHour(): number;
	GetHour12(): number;
	GetMillisecond(): number;
	GetMinute(): number;
	GetMonth(): number;
	GetSecond(): number;
	GetTimeOfDay(): Timespan;
	GetYear(): number;
	Greater_DateTimeDateTime(B: DateTime): boolean;
	GreaterEqual_DateTimeDateTime(B: DateTime): boolean;
	IsAfternoon(): boolean;
	IsMorning(): boolean;
	Less_DateTimeDateTime(B: DateTime): boolean;
	LessEqual_DateTimeDateTime(B: DateTime): boolean;
	NotEqual_DateTimeDateTime(B: DateTime): boolean;
	Subtract_DateTimeDateTime(B: DateTime): Timespan;
	Subtract_DateTimeTimespan(B: Timespan): DateTime;
	ScheduleLocalNotificationAtTime(LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	ScheduleLocalNotificationBadgeAtTime(LocalTime: boolean,ActivationEvent: string): number;
	static AsDate_DateTime(InDateTime: DateTime): string;
	static AsDateTime_DateTime(In: DateTime): string;
	static AsTime_DateTime(In: DateTime): string;
	static AsTimeZoneDate_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneDateTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static Add_DateTimeDateTime(A: DateTime,B: DateTime): DateTime;
	static Add_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static BreakDateTime(InDateTime: DateTime,Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	static EqualEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GetDate(A: DateTime): DateTime;
	static GetDay(A: DateTime): number;
	static GetDayOfYear(A: DateTime): number;
	static GetHour(A: DateTime): number;
	static GetHour12(A: DateTime): number;
	static GetMillisecond(A: DateTime): number;
	static GetMinute(A: DateTime): number;
	static GetMonth(A: DateTime): number;
	static GetSecond(A: DateTime): number;
	static GetTimeOfDay(A: DateTime): Timespan;
	static GetYear(A: DateTime): number;
	static Greater_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GreaterEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static IsAfternoon(A: DateTime): boolean;
	static IsMorning(A: DateTime): boolean;
	static Less_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static LessEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static NotEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static Subtract_DateTimeDateTime(A: DateTime,B: DateTime): Timespan;
	static Subtract_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static ScheduleLocalNotificationAtTime(FireDateTime: DateTime,LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	static ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime,LocalTime: boolean,ActivationEvent: string): number;
	static DateTimeMaxValue(): DateTime;
	static DateTimeMinValue(): DateTime;
	static MakeDateTime(Year: number,Month: number,Day: number,Hour: number,Minute: number,Second: number,Millisecond: number): DateTime;
	static Now(): DateTime;
	static Today(): DateTime;
	static UtcNow(): DateTime;
}

declare class TranslationChange { 
	Version: string;
	DateAndTime: DateTime;
	Source: string;
	Translation: string;
	clone() : TranslationChange;
	static C(Other: UObject | any): TranslationChange;
}

declare class TranslationContextInfo { 
	Key: string;
	Context: string;
	Changes: TranslationChange[];
	clone() : TranslationContextInfo;
	static C(Other: UObject | any): TranslationContextInfo;
}

declare class TranslationUnit extends UObject { 
	Namespace: string;
	Key: string;
	Source: string;
	Translation: string;
	Contexts: TranslationContextInfo[];
	HasBeenReviewed: boolean;
	TranslationBeforeImport: string;
	LocresPath: string;
	static Load(ResourceName: string): TranslationUnit;
	static Find(Outer: UObject, ResourceName: string): TranslationUnit;
	static GetDefaultObject(): TranslationUnit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationUnit;
	static C(Other: UObject | any): TranslationUnit;
}

declare class StatusBarSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): StatusBarSubsystem;
	static Find(Outer: UObject, ResourceName: string): StatusBarSubsystem;
	static GetDefaultObject(): StatusBarSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StatusBarSubsystem;
	static C(Other: UObject | any): StatusBarSubsystem;
}

declare class LevelEditorMenuContext extends UObject { 
	static Load(ResourceName: string): LevelEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorMenuContext;
	static GetDefaultObject(): LevelEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorMenuContext;
	static C(Other: UObject | any): LevelEditorMenuContext;
}

declare type ELevelEditorMenuContext = 'Viewport' | 'SceneOutliner' | 'MainMenu' | 'ELevelEditorMenuContext_MAX';
declare var ELevelEditorMenuContext : { Viewport:'Viewport',SceneOutliner:'SceneOutliner',MainMenu:'MainMenu',ELevelEditorMenuContext_MAX:'ELevelEditorMenuContext_MAX', };
declare class LevelEditorContextMenuContext extends UObject { 
	ContextType: ELevelEditorMenuContext;
	CurrentSelection: TypedElementSelectionSet;
	CursorWorldLocation: Vector;
	SelectedComponents: ActorComponent[];
	HitProxyActor: Actor;
	static Load(ResourceName: string): LevelEditorContextMenuContext;
	static Find(Outer: UObject, ResourceName: string): LevelEditorContextMenuContext;
	static GetDefaultObject(): LevelEditorContextMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorContextMenuContext;
	GetScriptHitProxyElement(): ScriptTypedElementHandle;
	static C(Other: UObject | any): LevelEditorContextMenuContext;
}

declare class LevelViewportToolBarContext extends UObject { 
	static Load(ResourceName: string): LevelViewportToolBarContext;
	static Find(Outer: UObject, ResourceName: string): LevelViewportToolBarContext;
	static GetDefaultObject(): LevelViewportToolBarContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelViewportToolBarContext;
	static C(Other: UObject | any): LevelViewportToolBarContext;
}

declare class QuickActionMenuContext extends UObject { 
	CurrentSelection: TypedElementSelectionSet;
	static Load(ResourceName: string): QuickActionMenuContext;
	static Find(Outer: UObject, ResourceName: string): QuickActionMenuContext;
	static GetDefaultObject(): QuickActionMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuickActionMenuContext;
	static C(Other: UObject | any): QuickActionMenuContext;
}

declare class LevelEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LevelEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorSubsystem;
	static GetDefaultObject(): LevelEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorSubsystem;
	SetCurrentLevelByName(LevelName: string): boolean;
	SetAllowsCinematicControl(bAllow: boolean,ViewportConfigKey: string): void;
	SaveCurrentLevel(): boolean;
	SaveAllDirtyLevels(): boolean;
	PilotLevelActor(ActorToPilot: Actor,ViewportConfigKey: string): void;
	NewLevelFromTemplate(AssetPath: string,TemplateAssetPath: string): boolean;
	NewLevel(AssetPath: string): boolean;
	LoadLevel(AssetPath: string): boolean;
	IsInPlayInEditor(): boolean;
	GetViewportConfigKeys(): string[];
	GetSelectionSet(): TypedElementSelectionSet;
	GetCurrentLevel(): Level;
	GetAllowsCinematicControl(ViewportConfigKey: string): boolean;
	GetActiveViewportConfigKey(): string;
	EjectPilotLevelActor(ViewportConfigKey: string): void;
	EditorSetGameView(bGameView: boolean,ViewportConfigKey: string): void;
	EditorRequestEndPlay(): void;
	EditorPlaySimulate(): void;
	EditorInvalidateViewports(): void;
	EditorGetGameView(ViewportConfigKey: string): boolean;
	static C(Other: UObject | any): LevelEditorSubsystem;
}

declare class LightEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): LightEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): LightEditorSubsystem;
	static GetDefaultObject(): LightEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightEditorSubsystem;
	static C(Other: UObject | any): LightEditorSubsystem;
}

declare class AssetEditorUISubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): AssetEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): AssetEditorUISubsystem;
	static GetDefaultObject(): AssetEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorUISubsystem;
	static C(Other: UObject | any): AssetEditorUISubsystem;
}

declare class LevelEditorUISubsystem extends AssetEditorUISubsystem { 
	static Load(ResourceName: string): LevelEditorUISubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelEditorUISubsystem;
	static GetDefaultObject(): LevelEditorUISubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelEditorUISubsystem;
	static C(Other: UObject | any): LevelEditorUISubsystem;
}

declare class Manipulator extends Actor { 
	AssociatedComponent: SceneComponent;
	StaticMeshComponent: StaticMeshComponent;
	static GetDefaultObject(): Manipulator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Manipulator;
	static C(Other: UObject | any): Manipulator;
}

declare class PropertyNameAndIndex { 
	Name: string;
	index: number;
	clone() : PropertyNameAndIndex;
	static C(Other: UObject | any): PropertyNameAndIndex;
}

declare class ComponentPropertyPath { 
	ParentOwningActor: any;
	LastResortComponentPtr: any;
	PropertyChain: PropertyNameAndIndex[];
	clone() : ComponentPropertyPath;
	static C(Other: UObject | any): ComponentPropertyPath;
}

declare type ESelectedTangentHandle = 'None' | 'Leave' | 'Arrive' | 'ESelectedTangentHandle_MAX';
declare var ESelectedTangentHandle : { None:'None',Leave:'Leave',Arrive:'Arrive',ESelectedTangentHandle_MAX:'ESelectedTangentHandle_MAX', };
declare class SplineComponentVisualizerSelectionState extends UObject { 
	SplinePropertyPath: ComponentPropertyPath;
	SelectedKeys: any;
	LastKeyIndexSelected: number;
	SelectedSegmentIndex: number;
	SelectedTangentHandle: number;
	SelectedTangentHandleType: ESelectedTangentHandle;
	SelectedSplinePosition: Vector;
	CachedRotation: Quat;
	static Load(ResourceName: string): SplineComponentVisualizerSelectionState;
	static Find(Outer: UObject, ResourceName: string): SplineComponentVisualizerSelectionState;
	static GetDefaultObject(): SplineComponentVisualizerSelectionState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponentVisualizerSelectionState;
	static C(Other: UObject | any): SplineComponentVisualizerSelectionState;
}

declare type EShapeAddMode = 'AppendAfter' | 'AppendBefore' | 'InsertAfter' | 'InsertBefore' | 'EShapeAddMode_MAX';
declare var EShapeAddMode : { AppendAfter:'AppendAfter',AppendBefore:'AppendBefore',InsertAfter:'InsertAfter',InsertBefore:'InsertBefore',EShapeAddMode_MAX:'EShapeAddMode_MAX', };
declare class SplineGeneratorBase extends UObject { 
	ShapeAddMode: EShapeAddMode;
	static Load(ResourceName: string): SplineGeneratorBase;
	static Find(Outer: UObject, ResourceName: string): SplineGeneratorBase;
	static GetDefaultObject(): SplineGeneratorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineGeneratorBase;
	static C(Other: UObject | any): SplineGeneratorBase;
}

declare class CircleSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Radius: number;
	bReverseDir: boolean;
	bKeepFirstKeyTangent: boolean;
	bBranchRight: boolean;
	static Load(ResourceName: string): CircleSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): CircleSplineGenerator;
	static GetDefaultObject(): CircleSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircleSplineGenerator;
	static C(Other: UObject | any): CircleSplineGenerator;
}

declare class ArcSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Radius: number;
	Degrees: number;
	bReverseDir: boolean;
	bKeepFirstKeyTangent: boolean;
	bBranchRight: boolean;
	static Load(ResourceName: string): ArcSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): ArcSplineGenerator;
	static GetDefaultObject(): ArcSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArcSplineGenerator;
	static C(Other: UObject | any): ArcSplineGenerator;
}

declare class SquareSplineGenerator extends SplineGeneratorBase { 
	Length: number;
	bBranchRight: boolean;
	static Load(ResourceName: string): SquareSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): SquareSplineGenerator;
	static GetDefaultObject(): SquareSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SquareSplineGenerator;
	static C(Other: UObject | any): SquareSplineGenerator;
}

declare class EllipseSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Length: number;
	Width: number;
	bReverseDir: boolean;
	bKeepFirstKeyTangent: boolean;
	bBranchRight: boolean;
	static Load(ResourceName: string): EllipseSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): EllipseSplineGenerator;
	static GetDefaultObject(): EllipseSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EllipseSplineGenerator;
	static C(Other: UObject | any): EllipseSplineGenerator;
}

declare class RectangleSplineGenerator extends SplineGeneratorBase { 
	Length: number;
	Width: number;
	bBranchRight: boolean;
	static Load(ResourceName: string): RectangleSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): RectangleSplineGenerator;
	static GetDefaultObject(): RectangleSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RectangleSplineGenerator;
	static C(Other: UObject | any): RectangleSplineGenerator;
}

declare class LineSplineGenerator extends SplineGeneratorBase { 
	NumberOfPoints: number;
	Length: number;
	bEnableUpToNextPoint: boolean;
	bUpToNextPoint: boolean;
	static Load(ResourceName: string): LineSplineGenerator;
	static Find(Outer: UObject, ResourceName: string): LineSplineGenerator;
	static GetDefaultObject(): LineSplineGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LineSplineGenerator;
	static C(Other: UObject | any): LineSplineGenerator;
}

declare class GameplayTaskOwnerInterface extends Interface { 
	static Load(ResourceName: string): GameplayTaskOwnerInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTaskOwnerInterface;
	static GetDefaultObject(): GameplayTaskOwnerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskOwnerInterface;
	static C(Other: UObject | any): GameplayTaskOwnerInterface;
}

declare class GameplayTask_ClaimResource extends GameplayTask { 
	static Load(ResourceName: string): GameplayTask_ClaimResource;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_ClaimResource;
	static GetDefaultObject(): GameplayTask_ClaimResource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_ClaimResource;
	static C(Other: UObject | any): GameplayTask_ClaimResource;
}

declare class GameplayTask_SpawnActor extends GameplayTask { 
	Success: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	DidNotSpawn: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	ClassToSpawn: UnrealEngineClass;
	static Load(ResourceName: string): GameplayTask_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_SpawnActor;
	static GetDefaultObject(): GameplayTask_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_SpawnActor;
	FinishSpawningActor(WorldContextObject: UObject,SpawnedActor: Actor): void;
	BeginSpawningActor(WorldContextObject: UObject,SpawnedActor?: Actor): {SpawnedActor: Actor, $: boolean};
	static C(Other: UObject | any): GameplayTask_SpawnActor;
}

declare class GameplayTask_TimeLimitedExecution extends GameplayTask { 
	OnFinished: UnrealEngineMulticastDelegate<() => void>;
	OnTimeExpired: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): GameplayTask_TimeLimitedExecution;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_TimeLimitedExecution;
	static GetDefaultObject(): GameplayTask_TimeLimitedExecution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_TimeLimitedExecution;
	static C(Other: UObject | any): GameplayTask_TimeLimitedExecution;
}

declare class GameplayTask_WaitDelay extends GameplayTask { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): GameplayTask_WaitDelay;
	static Find(Outer: UObject, ResourceName: string): GameplayTask_WaitDelay;
	static GetDefaultObject(): GameplayTask_WaitDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask_WaitDelay;
	static C(Other: UObject | any): GameplayTask_WaitDelay;
}

declare class BlueprintGameplayTagLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintGameplayTagLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintGameplayTagLibrary;
	static GetDefaultObject(): BlueprintGameplayTagLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGameplayTagLibrary;
	static RemoveGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static NotEqual_TagTag(A: GameplayTag,B: string): boolean;
	static NotEqual_TagContainerTagContainer(A: GameplayTagContainer,B: string): boolean;
	static NotEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static NotEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static MatchesTag(TagOne: GameplayTag,TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	static MatchesAnyTags(TagOne: GameplayTag,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
	static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;
	static MakeGameplayTagContainerFromArray(GameplayTags: GameplayTag[]): GameplayTagContainer;
	static IsTagQueryEmpty(TagQuery: GameplayTagQuery): boolean;
	static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;
	static HasTag(TagContainer: GameplayTagContainer,Tag: GameplayTag,bExactMatch: boolean): boolean;
	static HasAnyTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasAllTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static GetTagName(GameplayTag: GameplayTag): string;
	static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
	static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;
	static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
	static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: UObject,ActorClass: UnrealEngineClass,GameplayTagQuery: GameplayTagQuery,OutActors?: Actor[]): {OutActors: Actor[]};
	static EqualEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static EqualEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer,TagQuery: GameplayTagQuery): boolean;
	static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer,GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	static AppendGameplayTagContainers(InOutTagContainer?: GameplayTagContainer,InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	static AddGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	static C(Other: UObject | any): BlueprintGameplayTagLibrary;
}

declare class GameplayTagAssetInterface extends Interface { 
	static Load(ResourceName: string): GameplayTagAssetInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTagAssetInterface;
	static GetDefaultObject(): GameplayTagAssetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagAssetInterface;
	HasMatchingGameplayTag(TagToCheck: GameplayTag): boolean;
	HasAnyMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
	HasAllMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
	GetOwnedGameplayTags(TagContainer?: GameplayTagContainer): {TagContainer: GameplayTagContainer};
	static C(Other: UObject | any): GameplayTagAssetInterface;
}

declare class EditableGameplayTagQueryExpression extends UObject { 
	static Load(ResourceName: string): EditableGameplayTagQueryExpression;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression;
	static GetDefaultObject(): EditableGameplayTagQueryExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression;
}

declare class EditableGameplayTagQuery extends UObject { 
	UserDescription: string;
	RootExpression: EditableGameplayTagQueryExpression;
	TagQueryExportText_Helper: GameplayTagQuery;
	static Load(ResourceName: string): EditableGameplayTagQuery;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQuery;
	static GetDefaultObject(): EditableGameplayTagQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQuery;
	static C(Other: UObject | any): EditableGameplayTagQuery;
}

declare class EditableGameplayTagQueryExpression_AnyTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AnyTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AllTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AllTagsMatch;
}

declare class EditableGameplayTagQueryExpression_NoTagsMatch extends EditableGameplayTagQueryExpression { 
	Tags: GameplayTagContainer;
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoTagsMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoTagsMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_NoTagsMatch;
}

declare class EditableGameplayTagQueryExpression_AnyExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AnyExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AnyExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AnyExprMatch;
}

declare class EditableGameplayTagQueryExpression_AllExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_AllExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_AllExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_AllExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_AllExprMatch;
}

declare class EditableGameplayTagQueryExpression_NoExprMatch extends EditableGameplayTagQueryExpression { 
	Expressions: EditableGameplayTagQueryExpression[];
	static Load(ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static Find(Outer: UObject, ResourceName: string): EditableGameplayTagQueryExpression_NoExprMatch;
	static GetDefaultObject(): EditableGameplayTagQueryExpression_NoExprMatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableGameplayTagQueryExpression_NoExprMatch;
	static C(Other: UObject | any): EditableGameplayTagQueryExpression_NoExprMatch;
}

declare class GameplayTagsManager extends UObject { 
	TagSources: any;
	GameplayTagTables: DataTable[];
	static Load(ResourceName: string): GameplayTagsManager;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsManager;
	static GetDefaultObject(): GameplayTagsManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsManager;
	static C(Other: UObject | any): GameplayTagsManager;
}

declare class GameplayTagTableRow extends TableRowBase { 
	Tag: string;
	DevComment: string;
	clone() : GameplayTagTableRow;
	static C(Other: UObject | any): GameplayTagTableRow;
}

declare class GameplayTagsList extends UObject { 
	ConfigFileName: string;
	GameplayTagList: GameplayTagTableRow[];
	static Load(ResourceName: string): GameplayTagsList;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsList;
	static GetDefaultObject(): GameplayTagsList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsList;
	static C(Other: UObject | any): GameplayTagsList;
}

declare class RestrictedGameplayTagTableRow extends GameplayTagTableRow { 
	bAllowNonRestrictedChildren: boolean;
	clone() : RestrictedGameplayTagTableRow;
	static C(Other: UObject | any): RestrictedGameplayTagTableRow;
}

declare class RestrictedGameplayTagsList extends UObject { 
	ConfigFileName: string;
	RestrictedGameplayTagList: RestrictedGameplayTagTableRow[];
	static Load(ResourceName: string): RestrictedGameplayTagsList;
	static Find(Outer: UObject, ResourceName: string): RestrictedGameplayTagsList;
	static GetDefaultObject(): RestrictedGameplayTagsList;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RestrictedGameplayTagsList;
	static C(Other: UObject | any): RestrictedGameplayTagsList;
}

declare class GameplayTagCategoryRemap { 
	BaseCategory: string;
	RemapCategories: string[];
	clone() : GameplayTagCategoryRemap;
	static C(Other: UObject | any): GameplayTagCategoryRemap;
}

declare class GameplayTagRedirect { 
	OldTagName: string;
	NewTagName: string;
	clone() : GameplayTagRedirect;
	static C(Other: UObject | any): GameplayTagRedirect;
}

declare class RestrictedConfigInfo { 
	RestrictedConfigName: string;
	Owners: string[];
	clone() : RestrictedConfigInfo;
	static C(Other: UObject | any): RestrictedConfigInfo;
}

declare class GameplayTagsSettings extends GameplayTagsList { 
	ImportTagsFromConfig: boolean;
	WarnOnInvalidTags: boolean;
	ClearInvalidTags: boolean;
	FastReplication: boolean;
	InvalidTagCharacters: string;
	CategoryRemapping: GameplayTagCategoryRemap[];
	GameplayTagTableList: SoftObjectPath[];
	GameplayTagRedirects: GameplayTagRedirect[];
	CommonlyReplicatedTags: string[];
	NumBitsForContainerSize: number;
	NetIndexFirstBitSegment: number;
	RestrictedConfigFiles: RestrictedConfigInfo[];
	RestrictedTagList: string;
	static Load(ResourceName: string): GameplayTagsSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsSettings;
	static GetDefaultObject(): GameplayTagsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsSettings;
	static C(Other: UObject | any): GameplayTagsSettings;
}

declare class GameplayTagsDeveloperSettings extends DeveloperSettings { 
	DeveloperConfigName: string;
	FavoriteTagSource: string;
	static Load(ResourceName: string): GameplayTagsDeveloperSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsDeveloperSettings;
	static GetDefaultObject(): GameplayTagsDeveloperSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsDeveloperSettings;
	static C(Other: UObject | any): GameplayTagsDeveloperSettings;
}

declare class GameplayDebuggerNetPack { 
	clone() : GameplayDebuggerNetPack;
	static C(Other: UObject | any): GameplayDebuggerNetPack;
}

declare class GameplayDebuggerDebugActor { 
	ActorName: string;
	SyncCounter: number;
	clone() : GameplayDebuggerDebugActor;
	static C(Other: UObject | any): GameplayDebuggerDebugActor;
}

declare class GameplayDebuggerVisLogSync { 
	DeviceIDs: string;
	clone() : GameplayDebuggerVisLogSync;
	static C(Other: UObject | any): GameplayDebuggerVisLogSync;
}

declare class DebugDrawComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): DebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): DebugDrawComponent;
	static GetDefaultObject(): DebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugDrawComponent;
	static C(Other: UObject | any): DebugDrawComponent;
}

declare class GameplayDebuggerRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): GameplayDebuggerRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerRenderingComponent;
	static GetDefaultObject(): GameplayDebuggerRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerRenderingComponent;
	static C(Other: UObject | any): GameplayDebuggerRenderingComponent;
}

declare class GameplayDebuggerCategoryReplicator extends Actor { 
	OwnerPC: PlayerController;
	bIsEnabled: boolean;
	ReplicatedData: GameplayDebuggerNetPack;
	DebugActor: GameplayDebuggerDebugActor;
	VisLogSync: GameplayDebuggerVisLogSync;
	RenderingComp: GameplayDebuggerRenderingComponent;
	static GetDefaultObject(): GameplayDebuggerCategoryReplicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerCategoryReplicator;
	ServerSetViewPoint(InViewLocation: Vector,InViewDirection: Vector): void;
	ServerSetEnabled(bEnable: boolean): void;
	ServerSetDebugActor(Actor: Actor,bSelectInEditor: boolean): void;
	ServerSetCategoryEnabled(CategoryId: number,bEnable: boolean): void;
	ServerSendExtensionInputEvent(ExtensionId: number,HandlerId: number): void;
	ServerSendCategoryInputEvent(CategoryId: number,HandlerId: number): void;
	static C(Other: UObject | any): GameplayDebuggerCategoryReplicator;
}

declare type EGameplayDebuggerOverrideMode = 'Enable' | 'Disable' | 'UseDefault' | 'EGameplayDebuggerOverrideMode_MAX';
declare var EGameplayDebuggerOverrideMode : { Enable:'Enable',Disable:'Disable',UseDefault:'UseDefault',EGameplayDebuggerOverrideMode_MAX:'EGameplayDebuggerOverrideMode_MAX', };
declare class GameplayDebuggerInputConfig { 
	ConfigName: string;
	Key: Key;
	bModShift: boolean;
	bModCtrl: boolean;
	bModAlt: boolean;
	bModCmd: boolean;
	clone() : GameplayDebuggerInputConfig;
	static C(Other: UObject | any): GameplayDebuggerInputConfig;
}

declare class GameplayDebuggerCategoryConfig { 
	CategoryName: string;
	SlotIdx: number;
	ActiveInGame: EGameplayDebuggerOverrideMode;
	ActiveInSimulate: EGameplayDebuggerOverrideMode;
	Hidden: EGameplayDebuggerOverrideMode;
	bOverrideSlotIdx: boolean;
	InputHandlers: GameplayDebuggerInputConfig[];
	clone() : GameplayDebuggerCategoryConfig;
	static C(Other: UObject | any): GameplayDebuggerCategoryConfig;
}

declare class GameplayDebuggerExtensionConfig { 
	ExtensionName: string;
	UseExtension: EGameplayDebuggerOverrideMode;
	InputHandlers: GameplayDebuggerInputConfig[];
	clone() : GameplayDebuggerExtensionConfig;
	static C(Other: UObject | any): GameplayDebuggerExtensionConfig;
}

declare class GameplayDebuggerConfig extends UObject { 
	ActivationKey: Key;
	CategoryRowNextKey: Key;
	CategoryRowPrevKey: Key;
	CategorySlot0: Key;
	CategorySlot1: Key;
	CategorySlot2: Key;
	CategorySlot3: Key;
	CategorySlot4: Key;
	CategorySlot5: Key;
	CategorySlot6: Key;
	CategorySlot7: Key;
	CategorySlot8: Key;
	CategorySlot9: Key;
	DebugCanvasPaddingLeft: number;
	DebugCanvasPaddingRight: number;
	DebugCanvasPaddingTop: number;
	DebugCanvasPaddingBottom: number;
	bDebugCanvasEnableTextShadow: boolean;
	Categories: GameplayDebuggerCategoryConfig[];
	Extensions: GameplayDebuggerExtensionConfig[];
	static Load(ResourceName: string): GameplayDebuggerConfig;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerConfig;
	static GetDefaultObject(): GameplayDebuggerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerConfig;
	static C(Other: UObject | any): GameplayDebuggerConfig;
}

declare class GameplayDebuggerUserSettings extends DeveloperSettings { 
	bEnableGameplayDebuggerInEditor: boolean;
	MaxViewDistance: number;
	MaxViewAngle: number;
	FontSize: number;
	static Load(ResourceName: string): GameplayDebuggerUserSettings;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerUserSettings;
	static GetDefaultObject(): GameplayDebuggerUserSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerUserSettings;
	static C(Other: UObject | any): GameplayDebuggerUserSettings;
}

declare class GameplayDebuggerPlayerData { 
	Controller: GameplayDebuggerLocalController;
	InputComponent: InputComponent;
	Replicator: GameplayDebuggerCategoryReplicator;
	clone() : GameplayDebuggerPlayerData;
	static C(Other: UObject | any): GameplayDebuggerPlayerData;
}

declare class GameplayDebuggerPlayerManager extends Actor { 
	PlayerData: GameplayDebuggerPlayerData[];
	PendingRegistrations: GameplayDebuggerCategoryReplicator[];
	EditorWorldData: GameplayDebuggerPlayerData;
	static GetDefaultObject(): GameplayDebuggerPlayerManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerPlayerManager;
	static C(Other: UObject | any): GameplayDebuggerPlayerManager;
}

declare class GameplayDebuggerLocalController extends UObject { 
	CachedReplicator: GameplayDebuggerCategoryReplicator;
	CachedPlayerManager: GameplayDebuggerPlayerManager;
	DebugActorCandidate: Actor;
	HUDFont: Font;
	static Load(ResourceName: string): GameplayDebuggerLocalController;
	static Find(Outer: UObject, ResourceName: string): GameplayDebuggerLocalController;
	static GetDefaultObject(): GameplayDebuggerLocalController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayDebuggerLocalController;
	static C(Other: UObject | any): GameplayDebuggerLocalController;
}

declare class AIBlueprintHelperLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AIBlueprintHelperLibrary;
	static Find(Outer: UObject, ResourceName: string): AIBlueprintHelperLibrary;
	static GetDefaultObject(): AIBlueprintHelperLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIBlueprintHelperLibrary;
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	static SpawnAIFromClass(WorldContextObject: UObject,PawnClass: UnrealEngineClass,BehaviorTree: BehaviorTree,Location: Vector,Rotation: Rotator,bNoCollisionFail: boolean,Owner: Actor): Pawn;
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	static SendAIMessage(Target: Pawn,Message: string,MessageSource: UObject,bSuccess: boolean): void;
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static IsValidAILocation(Location: Vector): boolean;
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	static GetNextNavLinkIndex(Controller: Controller): number;
	static GetCurrentPathPoints(Controller: Controller): Vector[];
	static GetCurrentPathIndex(Controller: Controller): number;
	static GetCurrentPath(Controller: Controller): NavigationPath;
	static GetBlackboard(Target: Actor): BlackboardComponent;
	static GetAIController(ControlledActor: Actor): AIController;
	static CreateMoveToProxyObject(WorldContextObject: UObject,Pawn: Pawn,Destination: Vector,TargetActor: Actor,AcceptanceRadius: number,bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
	static C(Other: UObject | any): AIBlueprintHelperLibrary;
}

declare class AIDataProvider_QueryParams extends AIDataProvider { 
	ParamName: string;
	FloatValue: number;
	IntValue: number;
	BoolValue: boolean;
	static Load(ResourceName: string): AIDataProvider_QueryParams;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider_QueryParams;
	static GetDefaultObject(): AIDataProvider_QueryParams;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_QueryParams;
	static C(Other: UObject | any): AIDataProvider_QueryParams;
}

declare class AIDataProvider_Random extends AIDataProvider_QueryParams { 
	Min: number;
	Max: number;
	bInteger: boolean;
	static Load(ResourceName: string): AIDataProvider_Random;
	static Find(Outer: UObject, ResourceName: string): AIDataProvider_Random;
	static GetDefaultObject(): AIDataProvider_Random;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIDataProvider_Random;
	static C(Other: UObject | any): AIDataProvider_Random;
}

declare class AIPerceptionListenerInterface extends Interface { 
	static Load(ResourceName: string): AIPerceptionListenerInterface;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionListenerInterface;
	static GetDefaultObject(): AIPerceptionListenerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionListenerInterface;
	static C(Other: UObject | any): AIPerceptionListenerInterface;
}

declare class AIPerceptionStimuliSourceComponent extends ActorComponent { 
	bAutoRegisterAsSource: boolean;
	RegisterAsSourceForSenses: UnrealEngineClass[];
	static Load(ResourceName: string): AIPerceptionStimuliSourceComponent;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionStimuliSourceComponent;
	static GetDefaultObject(): AIPerceptionStimuliSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionStimuliSourceComponent;
	UnregisterFromSense(SenseClass: UnrealEngineClass): void;
	UnregisterFromPerceptionSystem(): void;
	RegisterWithPerceptionSystem(): void;
	RegisterForSense(SenseClass: UnrealEngineClass): void;
	static C(Other: UObject | any): AIPerceptionStimuliSourceComponent;
}

declare class AIResourceInterface extends Interface { 
	static Load(ResourceName: string): AIResourceInterface;
	static Find(Outer: UObject, ResourceName: string): AIResourceInterface;
	static GetDefaultObject(): AIResourceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResourceInterface;
	static C(Other: UObject | any): AIResourceInterface;
}

declare class AIResource_Movement extends GameplayTaskResource { 
	static Load(ResourceName: string): AIResource_Movement;
	static Find(Outer: UObject, ResourceName: string): AIResource_Movement;
	static GetDefaultObject(): AIResource_Movement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Movement;
	static C(Other: UObject | any): AIResource_Movement;
}

declare class AIResource_Logic extends GameplayTaskResource { 
	static Load(ResourceName: string): AIResource_Logic;
	static Find(Outer: UObject, ResourceName: string): AIResource_Logic;
	static GetDefaultObject(): AIResource_Logic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIResource_Logic;
	static C(Other: UObject | any): AIResource_Logic;
}

declare type EUserDefinedStructureStatus = 'UDSS_UpToDate' | 'UDSS_Dirty' | 'UDSS_Error' | 'UDSS_Duplicate' | 'UDSS_MAX';
declare var EUserDefinedStructureStatus : { UDSS_UpToDate:'UDSS_UpToDate',UDSS_Dirty:'UDSS_Dirty',UDSS_Error:'UDSS_Error',UDSS_Duplicate:'UDSS_Duplicate',UDSS_MAX:'UDSS_MAX', };
declare class UserDefinedStruct extends ScriptStruct { 
	PrimaryStruct: any;
	ErrorMessage: string;
	EditorData: UObject;
	Status: EUserDefinedStructureStatus;
	Guid: Guid;
	static Load(ResourceName: string): UserDefinedStruct;
	static Find(Outer: UObject, ResourceName: string): UserDefinedStruct;
	static GetDefaultObject(): UserDefinedStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedStruct;
	static C(Other: UObject | any): UserDefinedStruct;
}

declare class AISenseBlueprintListener extends UserDefinedStruct { 
	static Load(ResourceName: string): AISenseBlueprintListener;
	static Find(Outer: UObject, ResourceName: string): AISenseBlueprintListener;
	static GetDefaultObject(): AISenseBlueprintListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseBlueprintListener;
	static C(Other: UObject | any): AISenseBlueprintListener;
}

declare class AISense_Blueprint extends AISense { 
	ListenerDataType: UnrealEngineClass;
	ListenerContainer: AIPerceptionComponent[];
	UnprocessedEvents: AISenseEvent[];
	static Load(ResourceName: string): AISense_Blueprint;
	static Find(Outer: UObject, ResourceName: string): AISense_Blueprint;
	static GetDefaultObject(): AISense_Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Blueprint;
	OnUpdate(EventsToProcess: AISenseEvent[]): number;
	OnListenerUpdated(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerUnregistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	OnListenerRegistered(ActorListener: Actor,PerceptionComponent: AIPerceptionComponent): void;
	K2_OnNewPawn(NewPawn: Pawn): void;
	GetAllListenerComponents(ListenerComponents?: AIPerceptionComponent[]): {ListenerComponents: AIPerceptionComponent[]};
	GetAllListenerActors(ListenerActors?: Actor[]): {ListenerActors: Actor[]};
	static C(Other: UObject | any): AISense_Blueprint;
}

declare class AISenseConfig_Blueprint extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	static Load(ResourceName: string): AISenseConfig_Blueprint;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Blueprint;
	static GetDefaultObject(): AISenseConfig_Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Blueprint;
	static C(Other: UObject | any): AISenseConfig_Blueprint;
}

declare class AIDamageEvent { 
	Amount: number;
	Location: Vector;
	HitLocation: Vector;
	DamagedActor: Actor;
	Instigator: Actor;
	Tag: string;
	clone() : AIDamageEvent;
	static C(Other: UObject | any): AIDamageEvent;
}

declare class AISense_Damage extends AISense { 
	RegisteredEvents: AIDamageEvent[];
	static Load(ResourceName: string): AISense_Damage;
	static Find(Outer: UObject, ResourceName: string): AISense_Damage;
	static GetDefaultObject(): AISense_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Damage;
	static ReportDamageEvent(WorldContextObject: UObject,DamagedActor: Actor,Instigator: Actor,DamageAmount: number,EventLocation: Vector,HitLocation: Vector,Tag: string): void;
	static C(Other: UObject | any): AISense_Damage;
}

declare class AISenseConfig_Damage extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	static Load(ResourceName: string): AISenseConfig_Damage;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Damage;
	static GetDefaultObject(): AISenseConfig_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Damage;
	static C(Other: UObject | any): AISenseConfig_Damage;
}

declare class AINoiseEvent { 
	NoiseLocation: Vector;
	Loudness: number;
	MaxRange: number;
	Instigator: Actor;
	Tag: string;
	clone() : AINoiseEvent;
	static C(Other: UObject | any): AINoiseEvent;
}

declare class AISense_Hearing extends AISense { 
	NoiseEvents: AINoiseEvent[];
	SpeedOfSoundSq: number;
	static Load(ResourceName: string): AISense_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISense_Hearing;
	static GetDefaultObject(): AISense_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Hearing;
	static ReportNoiseEvent(WorldContextObject: UObject,NoiseLocation: Vector,Loudness: number,Instigator: Actor,MaxRange: number,Tag: string): void;
	static C(Other: UObject | any): AISense_Hearing;
}

declare class AISenseAffiliationFilter { 
	bDetectEnemies: boolean;
	bDetectNeutrals: boolean;
	bDetectFriendlies: boolean;
	clone() : AISenseAffiliationFilter;
	static C(Other: UObject | any): AISenseAffiliationFilter;
}

declare class AISenseConfig_Hearing extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	HearingRange: number;
	LoSHearingRange: number;
	bUseLoSHearing: boolean;
	DetectionByAffiliation: AISenseAffiliationFilter;
	static Load(ResourceName: string): AISenseConfig_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Hearing;
	static GetDefaultObject(): AISenseConfig_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Hearing;
	static C(Other: UObject | any): AISenseConfig_Hearing;
}

declare class AISenseConfig_Prediction extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Prediction;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Prediction;
	static GetDefaultObject(): AISenseConfig_Prediction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Prediction;
	static C(Other: UObject | any): AISenseConfig_Prediction;
}

declare class AISense_Sight extends AISense { 
	MaxTracesPerTick: number;
	MinQueriesPerTimeSliceCheck: number;
	MaxTimeSlicePerTick: any;
	HighImportanceQueryDistanceThreshold: number;
	MaxQueryImportance: number;
	SightLimitQueryImportance: number;
	static Load(ResourceName: string): AISense_Sight;
	static Find(Outer: UObject, ResourceName: string): AISense_Sight;
	static GetDefaultObject(): AISense_Sight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Sight;
	static C(Other: UObject | any): AISense_Sight;
}

declare class AISenseConfig_Sight extends AISenseConfig { 
	Implementation: UnrealEngineClass;
	SightRadius: number;
	LoseSightRadius: number;
	PeripheralVisionAngleDegrees: number;
	DetectionByAffiliation: AISenseAffiliationFilter;
	AutoSuccessRangeFromLastSeenLocation: number;
	PointOfViewBackwardOffset: number;
	NearClippingRadius: number;
	static Load(ResourceName: string): AISenseConfig_Sight;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Sight;
	static GetDefaultObject(): AISenseConfig_Sight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Sight;
	static C(Other: UObject | any): AISenseConfig_Sight;
}

declare class AISenseConfig_Team extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Team;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Team;
	static GetDefaultObject(): AISenseConfig_Team;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Team;
	static C(Other: UObject | any): AISenseConfig_Team;
}

declare class AISenseConfig_Touch extends AISenseConfig { 
	static Load(ResourceName: string): AISenseConfig_Touch;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig_Touch;
	static GetDefaultObject(): AISenseConfig_Touch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig_Touch;
	static C(Other: UObject | any): AISenseConfig_Touch;
}

declare class AISenseEvent_Damage extends AISenseEvent { 
	Event: AIDamageEvent;
	static Load(ResourceName: string): AISenseEvent_Damage;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent_Damage;
	static GetDefaultObject(): AISenseEvent_Damage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Damage;
	static C(Other: UObject | any): AISenseEvent_Damage;
}

declare class AISenseEvent_Hearing extends AISenseEvent { 
	Event: AINoiseEvent;
	static Load(ResourceName: string): AISenseEvent_Hearing;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent_Hearing;
	static GetDefaultObject(): AISenseEvent_Hearing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent_Hearing;
	static C(Other: UObject | any): AISenseEvent_Hearing;
}

declare class AIPredictionEvent { 
	Requestor: Actor;
	PredictedActor: Actor;
	clone() : AIPredictionEvent;
	static C(Other: UObject | any): AIPredictionEvent;
}

declare class AISense_Prediction extends AISense { 
	RegisteredEvents: AIPredictionEvent[];
	static Load(ResourceName: string): AISense_Prediction;
	static Find(Outer: UObject, ResourceName: string): AISense_Prediction;
	static GetDefaultObject(): AISense_Prediction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Prediction;
	static RequestPawnPredictionEvent(Requestor: Pawn,PredictedActor: Actor,PredictionTime: number): void;
	static RequestControllerPredictionEvent(Requestor: AIController,PredictedActor: Actor,PredictionTime: number): void;
	static C(Other: UObject | any): AISense_Prediction;
}

declare class AITeamStimulusEvent { 
	Broadcaster: Actor;
	Enemy: Actor;
	clone() : AITeamStimulusEvent;
	static C(Other: UObject | any): AITeamStimulusEvent;
}

declare class AISense_Team extends AISense { 
	RegisteredEvents: AITeamStimulusEvent[];
	static Load(ResourceName: string): AISense_Team;
	static Find(Outer: UObject, ResourceName: string): AISense_Team;
	static GetDefaultObject(): AISense_Team;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Team;
	static C(Other: UObject | any): AISense_Team;
}

declare class AITouchEvent { 
	TouchReceiver: Actor;
	OtherActor: Actor;
	clone() : AITouchEvent;
	static C(Other: UObject | any): AITouchEvent;
}

declare class AISense_Touch extends AISense { 
	RegisteredEvents: AITouchEvent[];
	static Load(ResourceName: string): AISense_Touch;
	static Find(Outer: UObject, ResourceName: string): AISense_Touch;
	static GetDefaultObject(): AISense_Touch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense_Touch;
	static C(Other: UObject | any): AISense_Touch;
}

declare class AISightTargetInterface extends Interface { 
	static Load(ResourceName: string): AISightTargetInterface;
	static Find(Outer: UObject, ResourceName: string): AISightTargetInterface;
	static GetDefaultObject(): AISightTargetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISightTargetInterface;
	static C(Other: UObject | any): AISightTargetInterface;
}

declare class AITask extends GameplayTask { 
	OwnerController: AIController;
	static Load(ResourceName: string): AITask;
	static Find(Outer: UObject, ResourceName: string): AITask;
	static GetDefaultObject(): AITask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask;
	static C(Other: UObject | any): AITask;
}

declare class AITask_LockLogic extends AITask { 
	static Load(ResourceName: string): AITask_LockLogic;
	static Find(Outer: UObject, ResourceName: string): AITask_LockLogic;
	static GetDefaultObject(): AITask_LockLogic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_LockLogic;
	static C(Other: UObject | any): AITask_LockLogic;
}

declare class AIMoveRequest { 
	GoalActor: Actor;
	clone() : AIMoveRequest;
	static C(Other: UObject | any): AIMoveRequest;
}

declare type EAIOptionFlag = 'Default' | 'Enable' | 'Disable' | 'MAX';
declare var EAIOptionFlag : { Default:'Default',Enable:'Enable',Disable:'Disable',MAX:'MAX', };
declare class AITask_MoveTo extends AITask { 
	OnRequestFailed: UnrealEngineMulticastDelegate<() => void>;
	OnMoveFinished: UnrealEngineMulticastDelegate<(Result: EPathFollowingResult, AIController: AIController) => void>;
	MoveRequest: AIMoveRequest;
	static Load(ResourceName: string): AITask_MoveTo;
	static Find(Outer: UObject, ResourceName: string): AITask_MoveTo;
	static GetDefaultObject(): AITask_MoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_MoveTo;
	static AIMoveTo(Controller: AIController,GoalLocation: Vector,GoalActor: Actor,AcceptanceRadius: number,StopOnOverlap: EAIOptionFlag,AcceptPartialPath: EAIOptionFlag,bUsePathfinding: boolean,bLockAILogic: boolean,bUseContinuosGoalTracking: boolean,ProjectGoalOnNavigation: EAIOptionFlag): AITask_MoveTo;
	static C(Other: UObject | any): AITask_MoveTo;
}

declare class AITask_RunEQS extends AITask { 
	static Load(ResourceName: string): AITask_RunEQS;
	static Find(Outer: UObject, ResourceName: string): AITask_RunEQS;
	static GetDefaultObject(): AITask_RunEQS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AITask_RunEQS;
	static RunEQS(Controller: AIController,QueryTemplate: EnvQuery): AITask_RunEQS;
	static C(Other: UObject | any): AITask_RunEQS;
}

declare class BehaviorTreeTypes extends UObject { 
	static Load(ResourceName: string): BehaviorTreeTypes;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeTypes;
	static GetDefaultObject(): BehaviorTreeTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeTypes;
	static C(Other: UObject | any): BehaviorTreeTypes;
}

declare class BlackboardAssetProvider extends Interface { 
	static Load(ResourceName: string): BlackboardAssetProvider;
	static Find(Outer: UObject, ResourceName: string): BlackboardAssetProvider;
	static GetDefaultObject(): BlackboardAssetProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardAssetProvider;
	GetBlackboardAsset(): BlackboardData;
	static C(Other: UObject | any): BlackboardAssetProvider;
}

declare class BlackboardKeyType_Bool extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Bool;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Bool;
	static GetDefaultObject(): BlackboardKeyType_Bool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Bool;
	static C(Other: UObject | any): BlackboardKeyType_Bool;
}

declare class BlackboardKeyType_Class extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	static Load(ResourceName: string): BlackboardKeyType_Class;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Class;
	static GetDefaultObject(): BlackboardKeyType_Class;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Class;
	static C(Other: UObject | any): BlackboardKeyType_Class;
}

declare class BlackboardKeyType_Enum extends BlackboardKeyType { 
	EnumType: Enum;
	EnumName: string;
	bIsEnumNameValid: boolean;
	static Load(ResourceName: string): BlackboardKeyType_Enum;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Enum;
	static GetDefaultObject(): BlackboardKeyType_Enum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Enum;
	static C(Other: UObject | any): BlackboardKeyType_Enum;
}

declare class BlackboardKeyType_Float extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Float;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Float;
	static GetDefaultObject(): BlackboardKeyType_Float;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Float;
	static C(Other: UObject | any): BlackboardKeyType_Float;
}

declare class BlackboardKeyType_Int extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Int;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Int;
	static GetDefaultObject(): BlackboardKeyType_Int;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Int;
	static C(Other: UObject | any): BlackboardKeyType_Int;
}

declare class BlackboardKeyType_Name extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Name;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Name;
	static GetDefaultObject(): BlackboardKeyType_Name;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Name;
	static C(Other: UObject | any): BlackboardKeyType_Name;
}

declare class BlackboardKeyType_NativeEnum extends BlackboardKeyType { 
	EnumName: string;
	EnumType: Enum;
	static Load(ResourceName: string): BlackboardKeyType_NativeEnum;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_NativeEnum;
	static GetDefaultObject(): BlackboardKeyType_NativeEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_NativeEnum;
	static C(Other: UObject | any): BlackboardKeyType_NativeEnum;
}

declare class BlackboardKeyType_Object extends BlackboardKeyType { 
	BaseClass: UnrealEngineClass;
	static Load(ResourceName: string): BlackboardKeyType_Object;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Object;
	static GetDefaultObject(): BlackboardKeyType_Object;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Object;
	static C(Other: UObject | any): BlackboardKeyType_Object;
}

declare class BlackboardKeyType_Rotator extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Rotator;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Rotator;
	static GetDefaultObject(): BlackboardKeyType_Rotator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Rotator;
	static C(Other: UObject | any): BlackboardKeyType_Rotator;
}

declare class BlackboardKeyType_String extends BlackboardKeyType { 
	StringValue: string;
	static Load(ResourceName: string): BlackboardKeyType_String;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_String;
	static GetDefaultObject(): BlackboardKeyType_String;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_String;
	static C(Other: UObject | any): BlackboardKeyType_String;
}

declare class BlackboardKeyType_Vector extends BlackboardKeyType { 
	static Load(ResourceName: string): BlackboardKeyType_Vector;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType_Vector;
	static GetDefaultObject(): BlackboardKeyType_Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType_Vector;
	static C(Other: UObject | any): BlackboardKeyType_Vector;
}

declare class BTComposite_Selector extends BTCompositeNode { 
	static Load(ResourceName: string): BTComposite_Selector;
	static Find(Outer: UObject, ResourceName: string): BTComposite_Selector;
	static GetDefaultObject(): BTComposite_Selector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Selector;
	static C(Other: UObject | any): BTComposite_Selector;
}

declare class BTComposite_Sequence extends BTCompositeNode { 
	static Load(ResourceName: string): BTComposite_Sequence;
	static Find(Outer: UObject, ResourceName: string): BTComposite_Sequence;
	static GetDefaultObject(): BTComposite_Sequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_Sequence;
	static C(Other: UObject | any): BTComposite_Sequence;
}

declare type EBTParallelMode = 'AbortBackground' | 'WaitForBackground' | 'EBTParallelMode_MAX';
declare var EBTParallelMode : { AbortBackground:'AbortBackground',WaitForBackground:'WaitForBackground',EBTParallelMode_MAX:'EBTParallelMode_MAX', };
declare class BTComposite_SimpleParallel extends BTCompositeNode { 
	FinishMode: EBTParallelMode;
	static Load(ResourceName: string): BTComposite_SimpleParallel;
	static Find(Outer: UObject, ResourceName: string): BTComposite_SimpleParallel;
	static GetDefaultObject(): BTComposite_SimpleParallel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTComposite_SimpleParallel;
	static C(Other: UObject | any): BTComposite_SimpleParallel;
}

declare class BTDecorator_BlackboardBase extends BTDecorator { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_BlackboardBase;
	static GetDefaultObject(): BTDecorator_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlackboardBase;
	static C(Other: UObject | any): BTDecorator_BlackboardBase;
}

declare type EBTBlackboardRestart = 'ValueChange' | 'ResultChange' | 'EBTBlackboardRestart_MAX';
declare var EBTBlackboardRestart : { ValueChange:'ValueChange',ResultChange:'ResultChange',EBTBlackboardRestart_MAX:'EBTBlackboardRestart_MAX', };
declare type EBasicKeyOperation = 'Set' | 'NotSet' | 'EBasicKeyOperation_MAX';
declare var EBasicKeyOperation : { Set:'Set',NotSet:'NotSet',EBasicKeyOperation_MAX:'EBasicKeyOperation_MAX', };
declare type EArithmeticKeyOperation = 'Equal' | 'NotEqual' | 'Less' | 'LessOrEqual' | 'Greater' | 'GreaterOrEqual' | 'EArithmeticKeyOperation_MAX';
declare var EArithmeticKeyOperation : { Equal:'Equal',NotEqual:'NotEqual',Less:'Less',LessOrEqual:'LessOrEqual',Greater:'Greater',GreaterOrEqual:'GreaterOrEqual',EArithmeticKeyOperation_MAX:'EArithmeticKeyOperation_MAX', };
declare type ETextKeyOperation = 'Equal' | 'NotEqual' | 'Contain' | 'NotContain' | 'ETextKeyOperation_MAX';
declare var ETextKeyOperation : { Equal:'Equal',NotEqual:'NotEqual',Contain:'Contain',NotContain:'NotContain',ETextKeyOperation_MAX:'ETextKeyOperation_MAX', };
declare class BTDecorator_Blackboard extends BTDecorator_BlackboardBase { 
	IntValue: number;
	FloatValue: number;
	StringValue: string;
	CachedDescription: string;
	OperationType: number;
	NotifyObserver: EBTBlackboardRestart;
	BasicOperation: EBasicKeyOperation;
	ArithmeticOperation: EArithmeticKeyOperation;
	TextOperation: ETextKeyOperation;
	static Load(ResourceName: string): BTDecorator_Blackboard;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Blackboard;
	static GetDefaultObject(): BTDecorator_Blackboard;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Blackboard;
	static C(Other: UObject | any): BTDecorator_Blackboard;
}

declare type EBTNodeResult = 'Succeeded' | 'Failed' | 'Aborted' | 'InProgress' | 'EBTNodeResult_MAX';
declare var EBTNodeResult : { Succeeded:'Succeeded',Failed:'Failed',Aborted:'Aborted',InProgress:'InProgress',EBTNodeResult_MAX:'EBTNodeResult_MAX', };
declare class BTDecorator_BlueprintBase extends BTDecorator { 
	AIOwner: AIController;
	ActorOwner: Actor;
	ObservedKeyNames: string[];
	CustomDescription: string;
	bShowPropertyDetails: boolean;
	bCheckConditionOnlyBlackBoardChanges: boolean;
	bIsObservingBB: boolean;
	static Load(ResourceName: string): BTDecorator_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_BlueprintBase;
	static GetDefaultObject(): BTDecorator_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveObserverDeactivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverDeactivated(OwnerActor: Actor): void;
	ReceiveObserverActivatedAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveObserverActivated(OwnerActor: Actor): void;
	ReceiveExecutionStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecutionStart(OwnerActor: Actor): void;
	ReceiveExecutionFinishAI(OwnerController: AIController,ControlledPawn: Pawn,NodeResult: EBTNodeResult): void;
	ReceiveExecutionFinish(OwnerActor: Actor,NodeResult: EBTNodeResult): void;
	PerformConditionCheckAI(OwnerController: AIController,ControlledPawn: Pawn): boolean;
	PerformConditionCheck(OwnerActor: Actor): boolean;
	IsDecoratorObserverActive(): boolean;
	IsDecoratorExecutionActive(): boolean;
	static C(Other: UObject | any): BTDecorator_BlueprintBase;
}

declare type EGameplayContainerMatchType = 'Any' | 'All' | 'EGameplayContainerMatchType_MAX';
declare var EGameplayContainerMatchType : { Any:'Any',All:'All',EGameplayContainerMatchType_MAX:'EGameplayContainerMatchType_MAX', };
declare class BTDecorator_CheckGameplayTagsOnActor extends BTDecorator { 
	ActorToCheck: BlackboardKeySelector;
	TagsToMatch: EGameplayContainerMatchType;
	GameplayTags: GameplayTagContainer;
	CachedDescription: string;
	static Load(ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_CheckGameplayTagsOnActor;
	static GetDefaultObject(): BTDecorator_CheckGameplayTagsOnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CheckGameplayTagsOnActor;
	static C(Other: UObject | any): BTDecorator_CheckGameplayTagsOnActor;
}

declare type EBlackBoardEntryComparison = 'Equal' | 'NotEqual' | 'EBlackBoardEntryComparison_MAX';
declare var EBlackBoardEntryComparison : { Equal:'Equal',NotEqual:'NotEqual',EBlackBoardEntryComparison_MAX:'EBlackBoardEntryComparison_MAX', };
declare class BTDecorator_CompareBBEntries extends BTDecorator { 
	Operator: EBlackBoardEntryComparison;
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_CompareBBEntries;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_CompareBBEntries;
	static GetDefaultObject(): BTDecorator_CompareBBEntries;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_CompareBBEntries;
	static C(Other: UObject | any): BTDecorator_CompareBBEntries;
}

declare class BTDecorator_ConditionalLoop extends BTDecorator_Blackboard { 
	static Load(ResourceName: string): BTDecorator_ConditionalLoop;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ConditionalLoop;
	static GetDefaultObject(): BTDecorator_ConditionalLoop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConditionalLoop;
	static C(Other: UObject | any): BTDecorator_ConditionalLoop;
}

declare class BTDecorator_ConeCheck extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	ConeDirection: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	static Load(ResourceName: string): BTDecorator_ConeCheck;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ConeCheck;
	static GetDefaultObject(): BTDecorator_ConeCheck;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ConeCheck;
	static C(Other: UObject | any): BTDecorator_ConeCheck;
}

declare class BTDecorator_Cooldown extends BTDecorator { 
	CoolDownTime: number;
	static Load(ResourceName: string): BTDecorator_Cooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Cooldown;
	static GetDefaultObject(): BTDecorator_Cooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Cooldown;
	static C(Other: UObject | any): BTDecorator_Cooldown;
}

declare type EPathExistanceQueryType = 'NavmeshRaycast2D' | 'HierarchicalQuery' | 'RegularPathFinding' | 'EPathExistanceQueryType_MAX';
declare var EPathExistanceQueryType : { NavmeshRaycast2D:'NavmeshRaycast2D',HierarchicalQuery:'HierarchicalQuery',RegularPathFinding:'RegularPathFinding',EPathExistanceQueryType_MAX:'EPathExistanceQueryType_MAX', };
declare class BTDecorator_DoesPathExist extends BTDecorator { 
	BlackboardKeyA: BlackboardKeySelector;
	BlackboardKeyB: BlackboardKeySelector;
	bUseSelf: boolean;
	PathQueryType: EPathExistanceQueryType;
	FilterClass: UnrealEngineClass;
	static Load(ResourceName: string): BTDecorator_DoesPathExist;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_DoesPathExist;
	static GetDefaultObject(): BTDecorator_DoesPathExist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_DoesPathExist;
	static C(Other: UObject | any): BTDecorator_DoesPathExist;
}

declare class BTDecorator_ForceSuccess extends BTDecorator { 
	static Load(ResourceName: string): BTDecorator_ForceSuccess;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ForceSuccess;
	static GetDefaultObject(): BTDecorator_ForceSuccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ForceSuccess;
	static C(Other: UObject | any): BTDecorator_ForceSuccess;
}

declare type FAIDistanceType = 'Distance3D' | 'Distance2D' | 'DistanceZ' | 'MAX';
declare var FAIDistanceType : { Distance3D:'Distance3D',Distance2D:'Distance2D',DistanceZ:'DistanceZ',MAX:'MAX', };
declare class BTDecorator_IsAtLocation extends BTDecorator_BlackboardBase { 
	AcceptableRadius: number;
	ParametrizedAcceptableRadius: AIDataProviderFloatValue;
	GeometricDistanceType: FAIDistanceType;
	bUseParametrizedRadius: boolean;
	bUseNavAgentGoalLocation: boolean;
	bPathFindingBasedTest: boolean;
	static Load(ResourceName: string): BTDecorator_IsAtLocation;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_IsAtLocation;
	static GetDefaultObject(): BTDecorator_IsAtLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsAtLocation;
	static C(Other: UObject | any): BTDecorator_IsAtLocation;
}

declare class BTDecorator_IsBBEntryOfClass extends BTDecorator_BlackboardBase { 
	TestClass: UnrealEngineClass;
	static Load(ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_IsBBEntryOfClass;
	static GetDefaultObject(): BTDecorator_IsBBEntryOfClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_IsBBEntryOfClass;
	static C(Other: UObject | any): BTDecorator_IsBBEntryOfClass;
}

declare class BTDecorator_KeepInCone extends BTDecorator { 
	ConeHalfAngle: number;
	ConeOrigin: BlackboardKeySelector;
	Observed: BlackboardKeySelector;
	bUseSelfAsOrigin: boolean;
	bUseSelfAsObserved: boolean;
	static Load(ResourceName: string): BTDecorator_KeepInCone;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_KeepInCone;
	static GetDefaultObject(): BTDecorator_KeepInCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_KeepInCone;
	static C(Other: UObject | any): BTDecorator_KeepInCone;
}

declare class BTDecorator_Loop extends BTDecorator { 
	NumLoops: number;
	bInfiniteLoop: boolean;
	InfiniteLoopTimeoutTime: number;
	static Load(ResourceName: string): BTDecorator_Loop;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_Loop;
	static GetDefaultObject(): BTDecorator_Loop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_Loop;
	static C(Other: UObject | any): BTDecorator_Loop;
}

declare class BTDecorator_ReachedMoveGoal extends BTDecorator { 
	static Load(ResourceName: string): BTDecorator_ReachedMoveGoal;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_ReachedMoveGoal;
	static GetDefaultObject(): BTDecorator_ReachedMoveGoal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_ReachedMoveGoal;
	static C(Other: UObject | any): BTDecorator_ReachedMoveGoal;
}

declare class BTDecorator_SetTagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	static Load(ResourceName: string): BTDecorator_SetTagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_SetTagCooldown;
	static GetDefaultObject(): BTDecorator_SetTagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_SetTagCooldown;
	static C(Other: UObject | any): BTDecorator_SetTagCooldown;
}

declare class BTDecorator_TagCooldown extends BTDecorator { 
	CooldownTag: GameplayTag;
	CooldownDuration: number;
	bAddToExistingDuration: boolean;
	bActivatesCooldown: boolean;
	static Load(ResourceName: string): BTDecorator_TagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_TagCooldown;
	static GetDefaultObject(): BTDecorator_TagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TagCooldown;
	static C(Other: UObject | any): BTDecorator_TagCooldown;
}

declare class BTDecorator_TimeLimit extends BTDecorator { 
	TimeLimit: number;
	static Load(ResourceName: string): BTDecorator_TimeLimit;
	static Find(Outer: UObject, ResourceName: string): BTDecorator_TimeLimit;
	static GetDefaultObject(): BTDecorator_TimeLimit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator_TimeLimit;
	static C(Other: UObject | any): BTDecorator_TimeLimit;
}

declare class BTFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BTFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): BTFunctionLibrary;
	static GetDefaultObject(): BTFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTFunctionLibrary;
	static StopUsingExternalEvent(NodeOwner: BTNode): void;
	static StartUsingExternalEvent(NodeOwner: BTNode,OwningActor: Actor): void;
	static SetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Vector): void;
	static SetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Rotator): void;
	static SetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UObject): void;
	static SetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	static SetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	static SetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	static SetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: boolean): void;
	static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
	static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
	static GetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): Vector;
	static GetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector): Rotator;
	static GetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector): UObject;
	static GetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	static GetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	static GetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector): UnrealEngineClass;
	static GetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector): boolean;
	static GetBlackboardValueAsActor(NodeOwner: BTNode,Key: BlackboardKeySelector): Actor;
	static ClearBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static ClearBlackboardValue(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	static C(Other: UObject | any): BTFunctionLibrary;
}

declare class BTService_BlackboardBase extends BTService { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTService_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTService_BlackboardBase;
	static GetDefaultObject(): BTService_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlackboardBase;
	static C(Other: UObject | any): BTService_BlackboardBase;
}

declare class BTService_BlueprintBase extends BTService { 
	AIOwner: AIController;
	ActorOwner: Actor;
	CustomDescription: string;
	bShowPropertyDetails: boolean;
	bShowEventDetails: boolean;
	static Load(ResourceName: string): BTService_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTService_BlueprintBase;
	static GetDefaultObject(): BTService_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_BlueprintBase;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveSearchStartAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveSearchStart(OwnerActor: Actor): void;
	ReceiveDeactivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveDeactivation(OwnerActor: Actor): void;
	ReceiveActivationAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveActivation(OwnerActor: Actor): void;
	IsServiceActive(): boolean;
	static C(Other: UObject | any): BTService_BlueprintBase;
}

declare class BTService_DefaultFocus extends BTService_BlackboardBase { 
	FocusPriority: number;
	static Load(ResourceName: string): BTService_DefaultFocus;
	static Find(Outer: UObject, ResourceName: string): BTService_DefaultFocus;
	static GetDefaultObject(): BTService_DefaultFocus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_DefaultFocus;
	static C(Other: UObject | any): BTService_DefaultFocus;
}

declare type EAIParamType = 'Float' | 'Int' | 'Bool' | 'MAX';
declare var EAIParamType : { Float:'Float',Int:'Int',Bool:'Bool',MAX:'MAX', };
declare class AIDynamicParam { 
	ParamName: string;
	ParamType: EAIParamType;
	Value: number;
	BBKey: BlackboardKeySelector;
	clone() : AIDynamicParam;
	static C(Other: UObject | any): AIDynamicParam;
}

declare class EQSParametrizedQueryExecutionRequest { 
	QueryTemplate: EnvQuery;
	QueryConfig: AIDynamicParam[];
	EQSQueryBlackboardKey: BlackboardKeySelector;
	RunMode: EEnvQueryRunMode;
	bUseBBKeyForQueryTemplate: boolean;
	clone() : EQSParametrizedQueryExecutionRequest;
	static C(Other: UObject | any): EQSParametrizedQueryExecutionRequest;
}

declare class BTService_RunEQS extends BTService_BlackboardBase { 
	EQSRequest: EQSParametrizedQueryExecutionRequest;
	bUpdateBBOnFail: boolean;
	static Load(ResourceName: string): BTService_RunEQS;
	static Find(Outer: UObject, ResourceName: string): BTService_RunEQS;
	static GetDefaultObject(): BTService_RunEQS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService_RunEQS;
	static C(Other: UObject | any): BTService_RunEQS;
}

declare class BTTask_BlackboardBase extends BTTaskNode { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTTask_BlackboardBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_BlackboardBase;
	static GetDefaultObject(): BTTask_BlackboardBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlackboardBase;
	static C(Other: UObject | any): BTTask_BlackboardBase;
}

declare class IntervalCountdown { 
	Interval: number;
	clone() : IntervalCountdown;
	static C(Other: UObject | any): IntervalCountdown;
}

declare class BTTask_BlueprintBase extends BTTaskNode { 
	AIOwner: AIController;
	ActorOwner: Actor;
	TickInterval: IntervalCountdown;
	CustomDescription: string;
	bShowPropertyDetails: boolean;
	static Load(ResourceName: string): BTTask_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_BlueprintBase;
	static GetDefaultObject(): BTTask_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_BlueprintBase;
	SetFinishOnMessageWithId(MessageName: string,RequestID: number): void;
	SetFinishOnMessage(MessageName: string): void;
	ReceiveTickAI(OwnerController: AIController,ControlledPawn: Pawn,DeltaSeconds: number): void;
	ReceiveTick(OwnerActor: Actor,DeltaSeconds: number): void;
	ReceiveExecuteAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveExecute(OwnerActor: Actor): void;
	ReceiveAbortAI(OwnerController: AIController,ControlledPawn: Pawn): void;
	ReceiveAbort(OwnerActor: Actor): void;
	IsTaskExecuting(): boolean;
	IsTaskAborting(): boolean;
	FinishExecute(bSuccess: boolean): void;
	FinishAbort(): void;
	static C(Other: UObject | any): BTTask_BlueprintBase;
}

declare class BTTask_FinishWithResult extends BTTaskNode { 
	Result: EBTNodeResult;
	static Load(ResourceName: string): BTTask_FinishWithResult;
	static Find(Outer: UObject, ResourceName: string): BTTask_FinishWithResult;
	static GetDefaultObject(): BTTask_FinishWithResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_FinishWithResult;
	static C(Other: UObject | any): BTTask_FinishWithResult;
}

declare class BTTask_GameplayTaskBase extends BTTaskNode { 
	bWaitForGameplayTask: boolean;
	static Load(ResourceName: string): BTTask_GameplayTaskBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_GameplayTaskBase;
	static GetDefaultObject(): BTTask_GameplayTaskBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_GameplayTaskBase;
	static C(Other: UObject | any): BTTask_GameplayTaskBase;
}

declare class BTTask_MakeNoise extends BTTaskNode { 
	Loudnes: number;
	static Load(ResourceName: string): BTTask_MakeNoise;
	static Find(Outer: UObject, ResourceName: string): BTTask_MakeNoise;
	static GetDefaultObject(): BTTask_MakeNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MakeNoise;
	static C(Other: UObject | any): BTTask_MakeNoise;
}

declare class BTTask_MoveTo extends BTTask_BlackboardBase { 
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	ObservedBlackboardValueTolerance: number;
	bObserveBlackboardValue: boolean;
	bAllowStrafe: boolean;
	bAllowPartialPath: boolean;
	bTrackMovingGoal: boolean;
	bProjectGoalLocation: boolean;
	bReachTestIncludesAgentRadius: boolean;
	bReachTestIncludesGoalRadius: boolean;
	bStopOnOverlap: boolean;
	bStopOnOverlapNeedsUpdate: boolean;
	static Load(ResourceName: string): BTTask_MoveTo;
	static Find(Outer: UObject, ResourceName: string): BTTask_MoveTo;
	static GetDefaultObject(): BTTask_MoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveTo;
	static C(Other: UObject | any): BTTask_MoveTo;
}

declare class BTTask_MoveDirectlyToward extends BTTask_MoveTo { 
	bDisablePathUpdateOnGoalLocationChange: boolean;
	bProjectVectorGoalToNavigation: boolean;
	bUpdatedDeprecatedProperties: boolean;
	static Load(ResourceName: string): BTTask_MoveDirectlyToward;
	static Find(Outer: UObject, ResourceName: string): BTTask_MoveDirectlyToward;
	static GetDefaultObject(): BTTask_MoveDirectlyToward;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_MoveDirectlyToward;
	static C(Other: UObject | any): BTTask_MoveDirectlyToward;
}

declare class BTTask_PawnActionBase extends BTTaskNode { 
	static Load(ResourceName: string): BTTask_PawnActionBase;
	static Find(Outer: UObject, ResourceName: string): BTTask_PawnActionBase;
	static GetDefaultObject(): BTTask_PawnActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PawnActionBase;
	static C(Other: UObject | any): BTTask_PawnActionBase;
}

declare class BTTask_PlayAnimation extends BTTaskNode { 
	AnimationToPlay: AnimationAsset;
	bLooping: boolean;
	bNonBlocking: boolean;
	MyOwnerComp: BehaviorTreeComponent;
	CachedSkelMesh: SkeletalMeshComponent;
	static Load(ResourceName: string): BTTask_PlayAnimation;
	static Find(Outer: UObject, ResourceName: string): BTTask_PlayAnimation;
	static GetDefaultObject(): BTTask_PlayAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlayAnimation;
	static C(Other: UObject | any): BTTask_PlayAnimation;
}

declare class BTTask_PlaySound extends BTTaskNode { 
	SoundToPlay: SoundCue;
	static Load(ResourceName: string): BTTask_PlaySound;
	static Find(Outer: UObject, ResourceName: string): BTTask_PlaySound;
	static GetDefaultObject(): BTTask_PlaySound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PlaySound;
	static C(Other: UObject | any): BTTask_PlaySound;
}

declare class BTTask_PushPawnAction extends BTTask_PawnActionBase { 
	Action: PawnAction;
	static Load(ResourceName: string): BTTask_PushPawnAction;
	static Find(Outer: UObject, ResourceName: string): BTTask_PushPawnAction;
	static GetDefaultObject(): BTTask_PushPawnAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_PushPawnAction;
	static C(Other: UObject | any): BTTask_PushPawnAction;
}

declare class BTTask_RotateToFaceBBEntry extends BTTask_BlackboardBase { 
	Precision: number;
	static Load(ResourceName: string): BTTask_RotateToFaceBBEntry;
	static Find(Outer: UObject, ResourceName: string): BTTask_RotateToFaceBBEntry;
	static GetDefaultObject(): BTTask_RotateToFaceBBEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RotateToFaceBBEntry;
	static C(Other: UObject | any): BTTask_RotateToFaceBBEntry;
}

declare class BTTask_RunBehavior extends BTTaskNode { 
	BehaviorAsset: BehaviorTree;
	static Load(ResourceName: string): BTTask_RunBehavior;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunBehavior;
	static GetDefaultObject(): BTTask_RunBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehavior;
	static C(Other: UObject | any): BTTask_RunBehavior;
}

declare class BTTask_RunBehaviorDynamic extends BTTaskNode { 
	InjectionTag: GameplayTag;
	DefaultBehaviorAsset: BehaviorTree;
	BehaviorAsset: BehaviorTree;
	static Load(ResourceName: string): BTTask_RunBehaviorDynamic;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunBehaviorDynamic;
	static GetDefaultObject(): BTTask_RunBehaviorDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunBehaviorDynamic;
	static C(Other: UObject | any): BTTask_RunBehaviorDynamic;
}

declare class EnvNamedValue { 
	ParamName: string;
	ParamType: EAIParamType;
	Value: number;
	clone() : EnvNamedValue;
	static C(Other: UObject | any): EnvNamedValue;
}

declare class BTTask_RunEQSQuery extends BTTask_BlackboardBase { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	QueryConfig: AIDynamicParam[];
	RunMode: EEnvQueryRunMode;
	EQSQueryBlackboardKey: BlackboardKeySelector;
	bUseBBKey: boolean;
	EQSRequest: EQSParametrizedQueryExecutionRequest;
	bUpdateBBOnFail: boolean;
	static Load(ResourceName: string): BTTask_RunEQSQuery;
	static Find(Outer: UObject, ResourceName: string): BTTask_RunEQSQuery;
	static GetDefaultObject(): BTTask_RunEQSQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_RunEQSQuery;
	static C(Other: UObject | any): BTTask_RunEQSQuery;
}

declare class BTTask_SetTagCooldown extends BTTaskNode { 
	CooldownTag: GameplayTag;
	bAddToExistingDuration: boolean;
	CooldownDuration: number;
	static Load(ResourceName: string): BTTask_SetTagCooldown;
	static Find(Outer: UObject, ResourceName: string): BTTask_SetTagCooldown;
	static GetDefaultObject(): BTTask_SetTagCooldown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_SetTagCooldown;
	static C(Other: UObject | any): BTTask_SetTagCooldown;
}

declare class BTTask_Wait extends BTTaskNode { 
	WaitTime: number;
	RandomDeviation: number;
	static Load(ResourceName: string): BTTask_Wait;
	static Find(Outer: UObject, ResourceName: string): BTTask_Wait;
	static GetDefaultObject(): BTTask_Wait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_Wait;
	static C(Other: UObject | any): BTTask_Wait;
}

declare class BTTask_WaitBlackboardTime extends BTTask_Wait { 
	BlackboardKey: BlackboardKeySelector;
	static Load(ResourceName: string): BTTask_WaitBlackboardTime;
	static Find(Outer: UObject, ResourceName: string): BTTask_WaitBlackboardTime;
	static GetDefaultObject(): BTTask_WaitBlackboardTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_WaitBlackboardTime;
	static C(Other: UObject | any): BTTask_WaitBlackboardTime;
}

declare class CrowdAgentInterface extends Interface { 
	static Load(ResourceName: string): CrowdAgentInterface;
	static Find(Outer: UObject, ResourceName: string): CrowdAgentInterface;
	static GetDefaultObject(): CrowdAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdAgentInterface;
	static C(Other: UObject | any): CrowdAgentInterface;
}

declare class CrowdFollowingComponent extends PathFollowingComponent { 
	CrowdAgentMoveDirection: Vector;
	CharacterMovement: CharacterMovementComponent;
	AvoidanceGroup: NavAvoidanceMask;
	GroupsToAvoid: NavAvoidanceMask;
	GroupsToIgnore: NavAvoidanceMask;
	static Load(ResourceName: string): CrowdFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): CrowdFollowingComponent;
	static GetDefaultObject(): CrowdFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdFollowingComponent;
	SuspendCrowdSteering(bSuspend: boolean): void;
	static C(Other: UObject | any): CrowdFollowingComponent;
}

declare class CrowdManagerBase extends UObject { 
	static Load(ResourceName: string): CrowdManagerBase;
	static Find(Outer: UObject, ResourceName: string): CrowdManagerBase;
	static GetDefaultObject(): CrowdManagerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManagerBase;
	static C(Other: UObject | any): CrowdManagerBase;
}

declare class CrowdAvoidanceConfig { 
	VelocityBias: number;
	DesiredVelocityWeight: number;
	CurrentVelocityWeight: number;
	SideBiasWeight: number;
	ImpactTimeWeight: number;
	ImpactTimeRange: number;
	CustomPatternIdx: number;
	AdaptiveDivisions: number;
	AdaptiveRings: number;
	AdaptiveDepth: number;
	clone() : CrowdAvoidanceConfig;
	static C(Other: UObject | any): CrowdAvoidanceConfig;
}

declare class CrowdAvoidanceSamplingPattern { 
	Angles: number[];
	Radii: number[];
	clone() : CrowdAvoidanceSamplingPattern;
	static C(Other: UObject | any): CrowdAvoidanceSamplingPattern;
}

declare class CrowdManager extends CrowdManagerBase { 
	MyNavData: NavigationData;
	AvoidanceConfig: CrowdAvoidanceConfig[];
	SamplingPatterns: CrowdAvoidanceSamplingPattern[];
	MaxAgents: number;
	MaxAgentRadius: number;
	MaxAvoidedAgents: number;
	MaxAvoidedWalls: number;
	NavmeshCheckInterval: number;
	PathOptimizationInterval: number;
	SeparationDirClamp: number;
	PathOffsetRadiusMultiplier: number;
	bResolveCollisions: boolean;
	static Load(ResourceName: string): CrowdManager;
	static Find(Outer: UObject, ResourceName: string): CrowdManager;
	static GetDefaultObject(): CrowdManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CrowdManager;
	static C(Other: UObject | any): CrowdManager;
}

declare class DetourCrowdAIController extends AIController { 
	static GetDefaultObject(): DetourCrowdAIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetourCrowdAIController;
	static C(Other: UObject | any): DetourCrowdAIController;
}

declare class EnvQueryContext_BlueprintBase extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_BlueprintBase;
	static GetDefaultObject(): EnvQueryContext_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_BlueprintBase;
	ProvideSingleLocation(QuerierObject: UObject,QuerierActor: Actor,ResultingLocation?: Vector): {ResultingLocation: Vector};
	ProvideSingleActor(QuerierObject: UObject,QuerierActor: Actor,ResultingActor?: Actor): {ResultingActor: Actor};
	ProvideLocationsSet(QuerierObject: UObject,QuerierActor: Actor,ResultingLocationSet?: Vector[]): {ResultingLocationSet: Vector[]};
	ProvideActorsSet(QuerierObject: UObject,QuerierActor: Actor,ResultingActorsSet?: Actor[]): {ResultingActorsSet: Actor[]};
	static C(Other: UObject | any): EnvQueryContext_BlueprintBase;
}

declare class EnvQueryContext_Item extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_Item;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_Item;
	static GetDefaultObject(): EnvQueryContext_Item;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Item;
	static C(Other: UObject | any): EnvQueryContext_Item;
}

declare class EnvQueryContext_Querier extends EnvQueryContext { 
	static Load(ResourceName: string): EnvQueryContext_Querier;
	static Find(Outer: UObject, ResourceName: string): EnvQueryContext_Querier;
	static GetDefaultObject(): EnvQueryContext_Querier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryContext_Querier;
	static C(Other: UObject | any): EnvQueryContext_Querier;
}

declare class EnvQueryDebugHelpers extends UObject { 
	static Load(ResourceName: string): EnvQueryDebugHelpers;
	static Find(Outer: UObject, ResourceName: string): EnvQueryDebugHelpers;
	static GetDefaultObject(): EnvQueryDebugHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryDebugHelpers;
	static C(Other: UObject | any): EnvQueryDebugHelpers;
}

declare class EnvQueryGenerator_ActorsOfClass extends EnvQueryGenerator { 
	SearchedActorClass: UnrealEngineClass;
	GenerateOnlyActorsInRadius: AIDataProviderBoolValue;
	SearchRadius: AIDataProviderFloatValue;
	SearchCenter: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_ActorsOfClass;
	static GetDefaultObject(): EnvQueryGenerator_ActorsOfClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ActorsOfClass;
	static C(Other: UObject | any): EnvQueryGenerator_ActorsOfClass;
}

declare class EnvQueryGenerator_BlueprintBase extends EnvQueryGenerator { 
	GeneratorsActionDescription: string;
	Context: UnrealEngineClass;
	GeneratedItemType: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_BlueprintBase;
	static GetDefaultObject(): EnvQueryGenerator_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_BlueprintBase;
	GetQuerier(): UObject;
	DoItemGeneration(ContextLocations: Vector[]): void;
	AddGeneratedVector(GeneratedVector: Vector): void;
	AddGeneratedActor(GeneratedActor: Actor): void;
	static C(Other: UObject | any): EnvQueryGenerator_BlueprintBase;
}

declare class EnvQueryGenerator_Composite extends EnvQueryGenerator { 
	Generators: EnvQueryGenerator[];
	bAllowDifferentItemTypes: boolean;
	bHasMatchingItemType: boolean;
	ForcedItemType: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_Composite;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Composite;
	static GetDefaultObject(): EnvQueryGenerator_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Composite;
	static C(Other: UObject | any): EnvQueryGenerator_Composite;
}

declare type EEnvTraceShape = 'Line' | 'Box' | 'Sphere' | 'Capsule' | 'EEnvTraceShape_MAX';
declare var EEnvTraceShape : { Line:'Line',Box:'Box',Sphere:'Sphere',Capsule:'Capsule',EEnvTraceShape_MAX:'EEnvTraceShape_MAX', };
declare type EEnvQueryTrace = 'None' | 'Navigation' | 'GeometryByChannel' | 'GeometryByProfile' | 'NavigationOverLedges' | 'EEnvQueryTrace_MAX';
declare var EEnvQueryTrace : { None:'None',Navigation:'Navigation',GeometryByChannel:'GeometryByChannel',GeometryByProfile:'GeometryByProfile',NavigationOverLedges:'NavigationOverLedges',EEnvQueryTrace_MAX:'EEnvQueryTrace_MAX', };
declare class EnvTraceData { 
	VersionNum: number;
	NavigationFilter: UnrealEngineClass;
	ProjectDown: number;
	ProjectUp: number;
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	PostProjectionVerticalOffset: number;
	TraceChannel: ETraceTypeQuery;
	SerializedChannel: ECollisionChannel;
	TraceProfileName: string;
	TraceShape: EEnvTraceShape;
	TraceMode: EEnvQueryTrace;
	bTraceComplex: boolean;
	bOnlyBlockingHits: boolean;
	bCanTraceOnNavMesh: boolean;
	bCanTraceOnGeometry: boolean;
	bCanDisableTrace: boolean;
	bCanProjectDown: boolean;
	clone() : EnvTraceData;
	static C(Other: UObject | any): EnvTraceData;
}

declare class EnvQueryGenerator_ProjectedPoints extends EnvQueryGenerator { 
	ProjectionData: EnvTraceData;
	static Load(ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_ProjectedPoints;
	static GetDefaultObject(): EnvQueryGenerator_ProjectedPoints;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_ProjectedPoints;
	static C(Other: UObject | any): EnvQueryGenerator_ProjectedPoints;
}

declare class EnvQueryGenerator_Cone extends EnvQueryGenerator_ProjectedPoints { 
	AlignedPointsDistance: AIDataProviderFloatValue;
	ConeDegrees: AIDataProviderFloatValue;
	AngleStep: AIDataProviderFloatValue;
	Range: AIDataProviderFloatValue;
	CenterActor: UnrealEngineClass;
	bIncludeContextLocation: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_Cone;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Cone;
	static GetDefaultObject(): EnvQueryGenerator_Cone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Cone;
	static C(Other: UObject | any): EnvQueryGenerator_Cone;
}

declare class EnvQueryGenerator_CurrentLocation extends EnvQueryGenerator { 
	QueryContext: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_CurrentLocation;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_CurrentLocation;
	static GetDefaultObject(): EnvQueryGenerator_CurrentLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_CurrentLocation;
	static C(Other: UObject | any): EnvQueryGenerator_CurrentLocation;
}

declare class AIDataProviderIntValue extends AIDataProviderTypedValue { 
	DefaultValue: number;
	clone() : AIDataProviderIntValue;
	static C(Other: UObject | any): AIDataProviderIntValue;
}

declare type EEnvDirection = 'TwoPoints' | 'Rotation' | 'EEnvDirection_MAX';
declare var EEnvDirection : { TwoPoints:'TwoPoints',Rotation:'Rotation',EEnvDirection_MAX:'EEnvDirection_MAX', };
declare class EnvDirection { 
	LineFrom: UnrealEngineClass;
	LineTo: UnrealEngineClass;
	Rotation: UnrealEngineClass;
	DirMode: EEnvDirection;
	clone() : EnvDirection;
	static C(Other: UObject | any): EnvDirection;
}

declare class EnvQueryGenerator_Donut extends EnvQueryGenerator_ProjectedPoints { 
	InnerRadius: AIDataProviderFloatValue;
	OuterRadius: AIDataProviderFloatValue;
	NumberOfRings: AIDataProviderIntValue;
	PointsPerRing: AIDataProviderIntValue;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	bUseSpiralPattern: boolean;
	Center: UnrealEngineClass;
	bDefineArc: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_Donut;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_Donut;
	static GetDefaultObject(): EnvQueryGenerator_Donut;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_Donut;
	static C(Other: UObject | any): EnvQueryGenerator_Donut;
}

declare type EPointOnCircleSpacingMethod = 'BySpaceBetween' | 'ByNumberOfPoints' | 'EPointOnCircleSpacingMethod_MAX';
declare var EPointOnCircleSpacingMethod : { BySpaceBetween:'BySpaceBetween',ByNumberOfPoints:'ByNumberOfPoints',EPointOnCircleSpacingMethod_MAX:'EPointOnCircleSpacingMethod_MAX', };
declare class EnvQueryGenerator_OnCircle extends EnvQueryGenerator_ProjectedPoints { 
	CircleRadius: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	NumberOfPoints: AIDataProviderIntValue;
	PointOnCircleSpacingMethod: EPointOnCircleSpacingMethod;
	ArcDirection: EnvDirection;
	ArcAngle: AIDataProviderFloatValue;
	AngleRadians: number;
	CircleCenter: UnrealEngineClass;
	bIgnoreAnyContextActorsWhenGeneratingCircle: boolean;
	CircleCenterZOffset: AIDataProviderFloatValue;
	TraceData: EnvTraceData;
	bDefineArc: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_OnCircle;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_OnCircle;
	static GetDefaultObject(): EnvQueryGenerator_OnCircle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_OnCircle;
	static C(Other: UObject | any): EnvQueryGenerator_OnCircle;
}

declare class EnvQueryGenerator_SimpleGrid extends EnvQueryGenerator_ProjectedPoints { 
	GridSize: AIDataProviderFloatValue;
	SpaceBetween: AIDataProviderFloatValue;
	GenerateAround: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_SimpleGrid;
	static GetDefaultObject(): EnvQueryGenerator_SimpleGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_SimpleGrid;
	static C(Other: UObject | any): EnvQueryGenerator_SimpleGrid;
}

declare class EnvQueryGenerator_PathingGrid extends EnvQueryGenerator_SimpleGrid { 
	PathToItem: AIDataProviderBoolValue;
	NavigationFilter: UnrealEngineClass;
	ScanRangeMultiplier: AIDataProviderFloatValue;
	static Load(ResourceName: string): EnvQueryGenerator_PathingGrid;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_PathingGrid;
	static GetDefaultObject(): EnvQueryGenerator_PathingGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_PathingGrid;
	static C(Other: UObject | any): EnvQueryGenerator_PathingGrid;
}

declare class EnvQueryGenerator_PerceivedActors extends EnvQueryGenerator { 
	AllowedActorClass: UnrealEngineClass;
	SearchRadius: AIDataProviderFloatValue;
	ListenerContext: UnrealEngineClass;
	SenseToUse: UnrealEngineClass;
	bIncludeKnownActors: boolean;
	static Load(ResourceName: string): EnvQueryGenerator_PerceivedActors;
	static Find(Outer: UObject, ResourceName: string): EnvQueryGenerator_PerceivedActors;
	static GetDefaultObject(): EnvQueryGenerator_PerceivedActors;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryGenerator_PerceivedActors;
	static C(Other: UObject | any): EnvQueryGenerator_PerceivedActors;
}

declare class EnvQueryItemType_VectorBase extends EnvQueryItemType { 
	static Load(ResourceName: string): EnvQueryItemType_VectorBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_VectorBase;
	static GetDefaultObject(): EnvQueryItemType_VectorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_VectorBase;
	static C(Other: UObject | any): EnvQueryItemType_VectorBase;
}

declare class EnvQueryItemType_ActorBase extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_ActorBase;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_ActorBase;
	static GetDefaultObject(): EnvQueryItemType_ActorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_ActorBase;
	static C(Other: UObject | any): EnvQueryItemType_ActorBase;
}

declare class EnvQueryItemType_Actor extends EnvQueryItemType_ActorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Actor;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Actor;
	static GetDefaultObject(): EnvQueryItemType_Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Actor;
	static C(Other: UObject | any): EnvQueryItemType_Actor;
}

declare class EnvQueryItemType_Direction extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Direction;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Direction;
	static GetDefaultObject(): EnvQueryItemType_Direction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Direction;
	static C(Other: UObject | any): EnvQueryItemType_Direction;
}

declare class EnvQueryItemType_Point extends EnvQueryItemType_VectorBase { 
	static Load(ResourceName: string): EnvQueryItemType_Point;
	static Find(Outer: UObject, ResourceName: string): EnvQueryItemType_Point;
	static GetDefaultObject(): EnvQueryItemType_Point;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryItemType_Point;
	static C(Other: UObject | any): EnvQueryItemType_Point;
}

declare type EEnvTestDistance = 'Distance3D' | 'Distance2D' | 'DistanceZ' | 'DistanceAbsoluteZ' | 'EEnvTestDistance_MAX';
declare var EEnvTestDistance : { Distance3D:'Distance3D',Distance2D:'Distance2D',DistanceZ:'DistanceZ',DistanceAbsoluteZ:'DistanceAbsoluteZ',EEnvTestDistance_MAX:'EEnvTestDistance_MAX', };
declare class EnvQueryTest_Distance extends EnvQueryTest { 
	TestMode: EEnvTestDistance;
	DistanceTo: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Distance;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Distance;
	static GetDefaultObject(): EnvQueryTest_Distance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Distance;
	static C(Other: UObject | any): EnvQueryTest_Distance;
}

declare type EEnvTestDot = 'Dot3D' | 'Dot2D' | 'EEnvTestDot_MAX';
declare var EEnvTestDot : { Dot3D:'Dot3D',Dot2D:'Dot2D',EEnvTestDot_MAX:'EEnvTestDot_MAX', };
declare class EnvQueryTest_Dot extends EnvQueryTest { 
	LineA: EnvDirection;
	LineB: EnvDirection;
	TestMode: EEnvTestDot;
	bAbsoluteValue: boolean;
	static Load(ResourceName: string): EnvQueryTest_Dot;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Dot;
	static GetDefaultObject(): EnvQueryTest_Dot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Dot;
	static C(Other: UObject | any): EnvQueryTest_Dot;
}

declare class EnvQueryTest_GameplayTags extends EnvQueryTest { 
	TagQueryToMatch: GameplayTagQuery;
	bRejectIncompatibleItems: boolean;
	bUpdatedToUseQuery: boolean;
	TagsToMatch: EGameplayContainerMatchType;
	GameplayTags: GameplayTagContainer;
	static Load(ResourceName: string): EnvQueryTest_GameplayTags;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_GameplayTags;
	static GetDefaultObject(): EnvQueryTest_GameplayTags;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_GameplayTags;
	static C(Other: UObject | any): EnvQueryTest_GameplayTags;
}

declare type EEnvOverlapShape = 'Box' | 'Sphere' | 'Capsule' | 'EEnvOverlapShape_MAX';
declare var EEnvOverlapShape : { Box:'Box',Sphere:'Sphere',Capsule:'Capsule',EEnvOverlapShape_MAX:'EEnvOverlapShape_MAX', };
declare class EnvOverlapData { 
	ExtentX: number;
	ExtentY: number;
	ExtentZ: number;
	ShapeOffset: Vector;
	OverlapChannel: ECollisionChannel;
	OverlapShape: EEnvOverlapShape;
	bOnlyBlockingHits: boolean;
	bOverlapComplex: boolean;
	bSkipOverlapQuerier: boolean;
	clone() : EnvOverlapData;
	static C(Other: UObject | any): EnvOverlapData;
}

declare class EnvQueryTest_Overlap extends EnvQueryTest { 
	OverlapData: EnvOverlapData;
	static Load(ResourceName: string): EnvQueryTest_Overlap;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Overlap;
	static GetDefaultObject(): EnvQueryTest_Overlap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Overlap;
	static C(Other: UObject | any): EnvQueryTest_Overlap;
}

declare type EEnvTestPathfinding = 'PathExist' | 'PathCost' | 'PathLength' | 'EEnvTestPathfinding_MAX';
declare var EEnvTestPathfinding : { PathExist:'PathExist',PathCost:'PathCost',PathLength:'PathLength',EEnvTestPathfinding_MAX:'EEnvTestPathfinding_MAX', };
declare class EnvQueryTest_Pathfinding extends EnvQueryTest { 
	TestMode: EEnvTestPathfinding;
	Context: UnrealEngineClass;
	PathFromContext: AIDataProviderBoolValue;
	SkipUnreachable: AIDataProviderBoolValue;
	FilterClass: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Pathfinding;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Pathfinding;
	static GetDefaultObject(): EnvQueryTest_Pathfinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Pathfinding;
	static C(Other: UObject | any): EnvQueryTest_Pathfinding;
}

declare class EnvQueryTest_PathfindingBatch extends EnvQueryTest_Pathfinding { 
	ScanRangeMultiplier: AIDataProviderFloatValue;
	static Load(ResourceName: string): EnvQueryTest_PathfindingBatch;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_PathfindingBatch;
	static GetDefaultObject(): EnvQueryTest_PathfindingBatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_PathfindingBatch;
	static C(Other: UObject | any): EnvQueryTest_PathfindingBatch;
}

declare class EnvQueryTest_Project extends EnvQueryTest { 
	ProjectionData: EnvTraceData;
	static Load(ResourceName: string): EnvQueryTest_Project;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Project;
	static GetDefaultObject(): EnvQueryTest_Project;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Project;
	static C(Other: UObject | any): EnvQueryTest_Project;
}

declare class EnvQueryTest_Random extends EnvQueryTest { 
	static Load(ResourceName: string): EnvQueryTest_Random;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Random;
	static GetDefaultObject(): EnvQueryTest_Random;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Random;
	static C(Other: UObject | any): EnvQueryTest_Random;
}

declare class EnvQueryTest_Trace extends EnvQueryTest { 
	TraceData: EnvTraceData;
	TraceFromContext: AIDataProviderBoolValue;
	ItemHeightOffset: AIDataProviderFloatValue;
	ContextHeightOffset: AIDataProviderFloatValue;
	Context: UnrealEngineClass;
	static Load(ResourceName: string): EnvQueryTest_Trace;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Trace;
	static GetDefaultObject(): EnvQueryTest_Trace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Trace;
	static C(Other: UObject | any): EnvQueryTest_Trace;
}

declare class EnvQueryTest_Volume extends EnvQueryTest { 
	VolumeContext: UnrealEngineClass;
	VolumeClass: UnrealEngineClass;
	bDoComplexVolumeTest: boolean;
	static Load(ResourceName: string): EnvQueryTest_Volume;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_Volume;
	static GetDefaultObject(): EnvQueryTest_Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_Volume;
	static C(Other: UObject | any): EnvQueryTest_Volume;
}

declare class EnvQueryTypes extends UObject { 
	static Load(ResourceName: string): EnvQueryTypes;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTypes;
	static GetDefaultObject(): EnvQueryTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTypes;
	static C(Other: UObject | any): EnvQueryTypes;
}

declare class EQSQueryResultSourceInterface extends Interface { 
	static Load(ResourceName: string): EQSQueryResultSourceInterface;
	static Find(Outer: UObject, ResourceName: string): EQSQueryResultSourceInterface;
	static GetDefaultObject(): EQSQueryResultSourceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSQueryResultSourceInterface;
	static C(Other: UObject | any): EQSQueryResultSourceInterface;
}

declare class EQSRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): EQSRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): EQSRenderingComponent;
	static GetDefaultObject(): EQSRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSRenderingComponent;
	static C(Other: UObject | any): EQSRenderingComponent;
}

declare type EEnvQueryHightlightMode = 'All' | 'Best5Pct' | 'Best25Pct' | 'EEnvQueryHightlightMode_MAX';
declare var EEnvQueryHightlightMode : { All:'All',Best5Pct:'Best5Pct',Best25Pct:'Best25Pct',EEnvQueryHightlightMode_MAX:'EEnvQueryHightlightMode_MAX', };
declare class EQSTestingPawn extends Character { 
	QueryTemplate: EnvQuery;
	QueryParams: EnvNamedValue[];
	QueryConfig: AIDynamicParam[];
	TimeLimitPerStep: number;
	StepToDebugDraw: number;
	HighlightMode: EEnvQueryHightlightMode;
	bDrawLabels: boolean;
	bDrawFailedItems: boolean;
	bReRunQueryOnlyOnFinishedMove: boolean;
	bShouldBeVisibleInGame: boolean;
	bTickDuringGame: boolean;
	QueryingMode: EEnvQueryRunMode;
	NavAgentProperties: NavAgentProperties;
	EdRenderComp: EQSRenderingComponent;
	static GetDefaultObject(): EQSTestingPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EQSTestingPawn;
	static C(Other: UObject | any): EQSTestingPawn;
}

declare class GenericTeamAgentInterface extends Interface { 
	static Load(ResourceName: string): GenericTeamAgentInterface;
	static Find(Outer: UObject, ResourceName: string): GenericTeamAgentInterface;
	static GetDefaultObject(): GenericTeamAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GenericTeamAgentInterface;
	static C(Other: UObject | any): GenericTeamAgentInterface;
}

declare class GridPathAIController extends AIController { 
	static GetDefaultObject(): GridPathAIController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPathAIController;
	static C(Other: UObject | any): GridPathAIController;
}

declare class GridPathFollowingComponent extends PathFollowingComponent { 
	GridManager: NavLocalGridManager;
	static Load(ResourceName: string): GridPathFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): GridPathFollowingComponent;
	static GetDefaultObject(): GridPathFollowingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPathFollowingComponent;
	static C(Other: UObject | any): GridPathFollowingComponent;
}

declare class NavFilter_AIControllerDefault extends NavigationQueryFilter { 
	static Load(ResourceName: string): NavFilter_AIControllerDefault;
	static Find(Outer: UObject, ResourceName: string): NavFilter_AIControllerDefault;
	static GetDefaultObject(): NavFilter_AIControllerDefault;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavFilter_AIControllerDefault;
	static C(Other: UObject | any): NavFilter_AIControllerDefault;
}

declare type ENavLinkDirection = 'BothWays' | 'LeftToRight' | 'RightToLeft' | 'ENavLinkDirection_MAX';
declare var ENavLinkDirection : { BothWays:'BothWays',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',ENavLinkDirection_MAX:'ENavLinkDirection_MAX', };
declare class NavigationLinkBase { 
	LeftProjectHeight: number;
	MaxFallDownLength: number;
	SnapRadius: number;
	SnapHeight: number;
	SupportedAgents: NavAgentSelector;
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	Description: string;
	Direction: ENavLinkDirection;
	bUseSnapHeight: boolean;
	bSnapToCheapestArea: boolean;
	bCustomFlag0: boolean;
	bCustomFlag1: boolean;
	bCustomFlag2: boolean;
	bCustomFlag3: boolean;
	bCustomFlag4: boolean;
	bCustomFlag5: boolean;
	bCustomFlag6: boolean;
	bCustomFlag7: boolean;
	AreaClass: UnrealEngineClass;
	clone() : NavigationLinkBase;
	static C(Other: UObject | any): NavigationLinkBase;
}

declare class NavigationLink extends NavigationLinkBase { 
	Left: Vector;
	Right: Vector;
	clone() : NavigationLink;
	static C(Other: UObject | any): NavigationLink;
}

declare class NavigationSegmentLink extends NavigationLinkBase { 
	LeftStart: Vector;
	LeftEnd: Vector;
	RightStart: Vector;
	RightEnd: Vector;
	clone() : NavigationSegmentLink;
	static C(Other: UObject | any): NavigationSegmentLink;
}

declare class NavRelevantComponent extends ActorComponent { 
	bAttachToOwnersRoot: boolean;
	CachedNavParent: UObject;
	static Load(ResourceName: string): NavRelevantComponent;
	static Find(Outer: UObject, ResourceName: string): NavRelevantComponent;
	static GetDefaultObject(): NavRelevantComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavRelevantComponent;
	SetNavigationRelevancy(bRelevant: boolean): void;
	static C(Other: UObject | any): NavRelevantComponent;
}

declare class NavLinkCustomComponent extends NavRelevantComponent { 
	NavLinkUserId: any;
	EnabledAreaClass: UnrealEngineClass;
	DisabledAreaClass: UnrealEngineClass;
	SupportedAgents: NavAgentSelector;
	LinkRelativeStart: Vector;
	LinkRelativeEnd: Vector;
	LinkDirection: ENavLinkDirection;
	bLinkEnabled: boolean;
	bNotifyWhenEnabled: boolean;
	bNotifyWhenDisabled: boolean;
	bCreateBoxObstacle: boolean;
	ObstacleOffset: Vector;
	ObstacleExtent: Vector;
	ObstacleAreaClass: UnrealEngineClass;
	BroadcastRadius: number;
	BroadcastInterval: number;
	BroadcastChannel: ECollisionChannel;
	static Load(ResourceName: string): NavLinkCustomComponent;
	static Find(Outer: UObject, ResourceName: string): NavLinkCustomComponent;
	static GetDefaultObject(): NavLinkCustomComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkCustomComponent;
	static C(Other: UObject | any): NavLinkCustomComponent;
}

declare class NavLinkRenderingComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): NavLinkRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): NavLinkRenderingComponent;
	static GetDefaultObject(): NavLinkRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkRenderingComponent;
	static C(Other: UObject | any): NavLinkRenderingComponent;
}

declare class NavLinkProxy extends Actor { 
	PointLinks: NavigationLink[];
	SegmentLinks: NavigationSegmentLink[];
	SmartLinkComp: NavLinkCustomComponent;
	bSmartLinkIsRelevant: boolean;
	EdRenderComp: NavLinkRenderingComponent;
	SpriteComponent: BillboardComponent;
	OnSmartLinkReached: UnrealEngineMulticastDelegate<(MovingActor: Actor, DestinationPoint: Vector) => void>;
	static GetDefaultObject(): NavLinkProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkProxy;
	SetSmartLinkEnabled(bEnabled: boolean): void;
	ResumePathFollowing(Agent: Actor): void;
	ReceiveSmartLinkReached(Agent: Actor,Destination: Vector): void;
	IsSmartLinkEnabled(): boolean;
	HasMovingAgents(): boolean;
	CopyEndPointsFromSimpleLinkToSmartLink(): void;
	static C(Other: UObject | any): NavLinkProxy;
}

declare class PathFollowingManager extends UObject { 
	static Load(ResourceName: string): PathFollowingManager;
	static Find(Outer: UObject, ResourceName: string): PathFollowingManager;
	static GetDefaultObject(): PathFollowingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingManager;
	static C(Other: UObject | any): PathFollowingManager;
}

declare class PawnAction_BlueprintBase extends PawnAction { 
	static Load(ResourceName: string): PawnAction_BlueprintBase;
	static Find(Outer: UObject, ResourceName: string): PawnAction_BlueprintBase;
	static GetDefaultObject(): PawnAction_BlueprintBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_BlueprintBase;
	ActionTick(ControlledPawn: Pawn,DeltaSeconds: number): void;
	ActionStart(ControlledPawn: Pawn): void;
	ActionResume(ControlledPawn: Pawn): void;
	ActionPause(ControlledPawn: Pawn): void;
	ActionFinished(ControlledPawn: Pawn,WithResult: EPawnActionResult): void;
	static C(Other: UObject | any): PawnAction_BlueprintBase;
}

declare class PawnAction_Move extends PawnAction { 
	GoalActor: Actor;
	GoalLocation: Vector;
	AcceptableRadius: number;
	FilterClass: UnrealEngineClass;
	bAllowStrafe: boolean;
	bFinishOnOverlap: boolean;
	bUsePathfinding: boolean;
	bAllowPartialPath: boolean;
	bProjectGoalToNavigation: boolean;
	bUpdatePathToGoal: boolean;
	bAbortChildActionOnPathChange: boolean;
	static Load(ResourceName: string): PawnAction_Move;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Move;
	static GetDefaultObject(): PawnAction_Move;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Move;
	static C(Other: UObject | any): PawnAction_Move;
}

declare type EPawnActionFailHandling = 'RequireSuccess' | 'IgnoreFailure' | 'EPawnActionFailHandling_MAX';
declare var EPawnActionFailHandling : { RequireSuccess:'RequireSuccess',IgnoreFailure:'IgnoreFailure',EPawnActionFailHandling_MAX:'EPawnActionFailHandling_MAX', };
declare class PawnAction_Repeat extends PawnAction { 
	ActionToRepeat: PawnAction;
	RecentActionCopy: PawnAction;
	ChildFailureHandlingMode: EPawnActionFailHandling;
	static Load(ResourceName: string): PawnAction_Repeat;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Repeat;
	static GetDefaultObject(): PawnAction_Repeat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Repeat;
	static C(Other: UObject | any): PawnAction_Repeat;
}

declare class PawnAction_Sequence extends PawnAction { 
	ActionSequence: PawnAction[];
	ChildFailureHandlingMode: EPawnActionFailHandling;
	RecentActionCopy: PawnAction;
	static Load(ResourceName: string): PawnAction_Sequence;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Sequence;
	static GetDefaultObject(): PawnAction_Sequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Sequence;
	static C(Other: UObject | any): PawnAction_Sequence;
}

declare class PawnAction_Wait extends PawnAction { 
	TimeToWait: number;
	static Load(ResourceName: string): PawnAction_Wait;
	static Find(Outer: UObject, ResourceName: string): PawnAction_Wait;
	static GetDefaultObject(): PawnAction_Wait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction_Wait;
	static C(Other: UObject | any): PawnAction_Wait;
}

declare class PawnSensingComponent extends ActorComponent { 
	HearingThreshold: number;
	LOSHearingThreshold: number;
	SightRadius: number;
	SensingInterval: number;
	HearingMaxSoundAge: number;
	bEnableSensingUpdates: boolean;
	bOnlySensePlayers: boolean;
	bSeePawns: boolean;
	bHearNoises: boolean;
	OnSeePawn: UnrealEngineMulticastDelegate<(Pawn: Pawn) => void>;
	OnHearNoise: UnrealEngineMulticastDelegate<(Instigator: Pawn, Location: Vector, Volume: number) => void>;
	PeripheralVisionAngle: number;
	PeripheralVisionCosine: number;
	static Load(ResourceName: string): PawnSensingComponent;
	static Find(Outer: UObject, ResourceName: string): PawnSensingComponent;
	static GetDefaultObject(): PawnSensingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnSensingComponent;
	SetSensingUpdatesEnabled(bEnabled: boolean): void;
	SetSensingInterval(NewSensingInterval: number): void;
	SetPeripheralVisionAngle(NewPeripheralVisionAngle: number): void;
	GetPeripheralVisionCosine(): number;
	GetPeripheralVisionAngle(): number;
	static C(Other: UObject | any): PawnSensingComponent;
}

declare class VisualLoggerExtension extends UObject { 
	static Load(ResourceName: string): VisualLoggerExtension;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerExtension;
	static GetDefaultObject(): VisualLoggerExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerExtension;
	static C(Other: UObject | any): VisualLoggerExtension;
}

declare class AbstractNavData extends NavigationData { 
	static GetDefaultObject(): AbstractNavData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbstractNavData;
	static C(Other: UObject | any): AbstractNavData;
}

declare class NavAreaMeta extends NavArea { 
	static Load(ResourceName: string): NavAreaMeta;
	static Find(Outer: UObject, ResourceName: string): NavAreaMeta;
	static GetDefaultObject(): NavAreaMeta;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaMeta;
	static C(Other: UObject | any): NavAreaMeta;
}

declare class NavAreaMeta_SwitchByAgent extends NavAreaMeta { 
	Agent0Area: UnrealEngineClass;
	Agent1Area: UnrealEngineClass;
	Agent2Area: UnrealEngineClass;
	Agent3Area: UnrealEngineClass;
	Agent4Area: UnrealEngineClass;
	Agent5Area: UnrealEngineClass;
	Agent6Area: UnrealEngineClass;
	Agent7Area: UnrealEngineClass;
	Agent8Area: UnrealEngineClass;
	Agent9Area: UnrealEngineClass;
	Agent10Area: UnrealEngineClass;
	Agent11Area: UnrealEngineClass;
	Agent12Area: UnrealEngineClass;
	Agent13Area: UnrealEngineClass;
	Agent14Area: UnrealEngineClass;
	Agent15Area: UnrealEngineClass;
	static Load(ResourceName: string): NavAreaMeta_SwitchByAgent;
	static Find(Outer: UObject, ResourceName: string): NavAreaMeta_SwitchByAgent;
	static GetDefaultObject(): NavAreaMeta_SwitchByAgent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaMeta_SwitchByAgent;
	static C(Other: UObject | any): NavAreaMeta_SwitchByAgent;
}

declare class NavArea_Default extends NavArea { 
	static Load(ResourceName: string): NavArea_Default;
	static Find(Outer: UObject, ResourceName: string): NavArea_Default;
	static GetDefaultObject(): NavArea_Default;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Default;
	static C(Other: UObject | any): NavArea_Default;
}

declare class NavArea_LowHeight extends NavArea { 
	static Load(ResourceName: string): NavArea_LowHeight;
	static Find(Outer: UObject, ResourceName: string): NavArea_LowHeight;
	static GetDefaultObject(): NavArea_LowHeight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_LowHeight;
	static C(Other: UObject | any): NavArea_LowHeight;
}

declare class NavArea_Null extends NavArea { 
	static Load(ResourceName: string): NavArea_Null;
	static Find(Outer: UObject, ResourceName: string): NavArea_Null;
	static GetDefaultObject(): NavArea_Null;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Null;
	static C(Other: UObject | any): NavArea_Null;
}

declare class NavArea_Obstacle extends NavArea { 
	static Load(ResourceName: string): NavArea_Obstacle;
	static Find(Outer: UObject, ResourceName: string): NavArea_Obstacle;
	static GetDefaultObject(): NavArea_Obstacle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Obstacle;
	static C(Other: UObject | any): NavArea_Obstacle;
}

declare class NavCollisionCylinder { 
	Offset: Vector;
	Radius: number;
	Height: number;
	clone() : NavCollisionCylinder;
	static C(Other: UObject | any): NavCollisionCylinder;
}

declare class NavCollisionBox { 
	Offset: Vector;
	Extent: Vector;
	clone() : NavCollisionBox;
	static C(Other: UObject | any): NavCollisionBox;
}

declare class NavCollision extends NavCollisionBase { 
	CylinderCollision: NavCollisionCylinder[];
	BoxCollision: NavCollisionBox[];
	AreaClass: UnrealEngineClass;
	bGatherConvexGeometry: boolean;
	bCreateOnClient: boolean;
	static Load(ResourceName: string): NavCollision;
	static Find(Outer: UObject, ResourceName: string): NavCollision;
	static GetDefaultObject(): NavCollision;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavCollision;
	static C(Other: UObject | any): NavCollision;
}

declare class NavigationGraph extends NavigationData { 
	static GetDefaultObject(): NavigationGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraph;
	static C(Other: UObject | any): NavigationGraph;
}

declare class NavigationGraphNode extends Actor { 
	static GetDefaultObject(): NavigationGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraphNode;
	static C(Other: UObject | any): NavigationGraphNode;
}

declare class NavGraphNode { 
	Owner: UObject;
	clone() : NavGraphNode;
	static C(Other: UObject | any): NavGraphNode;
}

declare class NavigationGraphNodeComponent extends SceneComponent { 
	UNode: NavGraphNode;
	NextNodeComponent: NavigationGraphNodeComponent;
	PrevNodeComponent: NavigationGraphNodeComponent;
	static Load(ResourceName: string): NavigationGraphNodeComponent;
	static Find(Outer: UObject, ResourceName: string): NavigationGraphNodeComponent;
	static GetDefaultObject(): NavigationGraphNodeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationGraphNodeComponent;
	static C(Other: UObject | any): NavigationGraphNodeComponent;
}

declare class NavigationInvokerComponent extends ActorComponent { 
	TileGenerationRadius: number;
	TileRemovalRadius: number;
	static Load(ResourceName: string): NavigationInvokerComponent;
	static Find(Outer: UObject, ResourceName: string): NavigationInvokerComponent;
	static GetDefaultObject(): NavigationInvokerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationInvokerComponent;
	static C(Other: UObject | any): NavigationInvokerComponent;
}

declare class NavigationPathGenerator extends Interface { 
	static Load(ResourceName: string): NavigationPathGenerator;
	static Find(Outer: UObject, ResourceName: string): NavigationPathGenerator;
	static GetDefaultObject(): NavigationPathGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationPathGenerator;
	static C(Other: UObject | any): NavigationPathGenerator;
}

declare type ENavDataGatheringModeConfig = 'Invalid' | 'Instant' | 'Lazy' | 'ENavDataGatheringModeConfig_MAX';
declare var ENavDataGatheringModeConfig : { Invalid:'Invalid',Instant:'Instant',Lazy:'Lazy',ENavDataGatheringModeConfig_MAX:'ENavDataGatheringModeConfig_MAX', };
declare type FNavigationSystemRunMode = 'InvalidMode' | 'GameMode' | 'EditorMode' | 'SimulationMode' | 'PIEMode' | 'InferFromWorldMode' | 'FNavigationSystemRunMode_MAX';
declare var FNavigationSystemRunMode : { InvalidMode:'InvalidMode',GameMode:'GameMode',EditorMode:'EditorMode',SimulationMode:'SimulationMode',PIEMode:'PIEMode',InferFromWorldMode:'InferFromWorldMode',FNavigationSystemRunMode_MAX:'FNavigationSystemRunMode_MAX', };
declare class NavMeshBoundsVolume extends Volume { 
	SupportedAgents: NavAgentSelector;
	static GetDefaultObject(): NavMeshBoundsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMeshBoundsVolume;
	static C(Other: UObject | any): NavMeshBoundsVolume;
}

declare type ENavigationQueryResult = 'Invalid' | 'Error' | 'Fail' | 'Success' | 'ENavigationQueryResult_MAX';
declare var ENavigationQueryResult : { Invalid:'Invalid',Error:'Error',Fail:'Fail',Success:'Success',ENavigationQueryResult_MAX:'ENavigationQueryResult_MAX', };
declare class NavigationSystemV1 extends NavigationSystemBase { 
	MainNavData: NavigationData;
	AbstractNavData: NavigationData;
	DefaultAgentName: string;
	CrowdManagerClass: Class;
	bAutoCreateNavigationData: boolean;
	bSpawnNavDataInNavBoundsLevel: boolean;
	bAllowClientSideNavigation: boolean;
	bShouldDiscardSubLevelNavData: boolean;
	bTickWhilePaused: boolean;
	bSupportRebuilding: boolean;
	bInitialBuildingLocked: boolean;
	bSkipAgentHeightCheckWhenPickingNavData: boolean;
	bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
	ActiveTilesUpdateInterval: number;
	DataGatheringMode: ENavDataGatheringModeConfig;
	DirtyAreaWarningSizeThreshold: number;
	GatheringNavModifiersWarningLimitTime: number;
	SupportedAgents: NavDataConfig[];
	SupportedAgentsMask: NavAgentSelector;
	BuildBounds: Box;
	NavDataSet: NavigationData[];
	NavDataRegistrationQueue: NavigationData[];
	OnNavDataRegisteredEvent: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OnNavigationGenerationFinishedDelegate: UnrealEngineMulticastDelegate<(NavData: NavigationData) => void>;
	OperationMode: FNavigationSystemRunMode;
	DirtyAreasUpdateFreq: number;
	static Load(ResourceName: string): NavigationSystemV1;
	static Find(Outer: UObject, ResourceName: string): NavigationSystemV1;
	static GetDefaultObject(): NavigationSystemV1;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystemV1;
	UnregisterNavigationInvoker(Invoker: Actor): void;
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number): void;
	SetGeometryGatheringMode(NewMode: ENavDataGatheringModeConfig): void;
	ResetMaxSimultaneousTileGenerationJobsCount(): void;
	RegisterNavigationInvoker(Invoker: Actor,TileGenerationRadius: number,TileRemovalRadius: number): void;
	static ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,NavData: NavigationData,FilterClass: UnrealEngineClass,QueryExtent: Vector): Vector;
	OnNavigationBoundsUpdated(NavVolume: NavMeshBoundsVolume): void;
	static NavigationRaycast(WorldContextObject: UObject,RayStart: Vector,RayEnd: Vector,HitLocation?: Vector,FilterClass?: UnrealEngineClass,Querier?: Controller): {HitLocation: Vector, $: boolean};
	K2_ReplaceAreaInOctreeData(UObject: UObject,OldArea: UnrealEngineClass,NewArea: UnrealEngineClass): boolean;
	static K2_ProjectPointToNavigation(WorldContextObject: UObject,Point: Vector,ProjectedLocation?: Vector,NavData?: NavigationData,FilterClass?: UnrealEngineClass,QueryExtent?: Vector): {ProjectedLocation: Vector, $: boolean};
	static K2_GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static K2_GetRandomLocationInNavigableRadius(WorldContextObject: UObject,Origin: Vector,RandomLocation?: Vector,Radius?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {RandomLocation: Vector, $: boolean};
	static IsNavigationBeingBuiltOrLocked(WorldContextObject: UObject): boolean;
	static IsNavigationBeingBuilt(WorldContextObject: UObject): boolean;
	static GetRandomReachablePointInRadius(WorldContextObject: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetRandomPointInNavigableRadius(WorldContextObject: UObject,Origin: Vector,Radius: number,NavData: NavigationData,FilterClass: UnrealEngineClass): Vector;
	static GetPathLength(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathLength?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathLength: number, $: ENavigationQueryResult};
	static GetPathCost(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathCost?: number,NavData?: NavigationData,FilterClass?: UnrealEngineClass): {PathCost: number, $: ENavigationQueryResult};
	static GetNavigationSystem(WorldContextObject: UObject): NavigationSystemV1;
	static FindPathToLocationSynchronously(WorldContextObject: UObject,PathStart: Vector,PathEnd: Vector,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static FindPathToActorSynchronously(WorldContextObject: UObject,PathStart: Vector,GoalActor: Actor,TetherDistance: number,PathfindingContext: Actor,FilterClass: UnrealEngineClass): NavigationPath;
	static C(Other: UObject | any): NavigationSystemV1;
}

declare class NavigationSystemModuleConfig extends NavigationSystemConfig { 
	bStrictlyStatic: boolean;
	bCreateOnClient: boolean;
	bAutoSpawnMissingNavData: boolean;
	bSpawnNavDataInNavBoundsLevel: boolean;
	static Load(ResourceName: string): NavigationSystemModuleConfig;
	static Find(Outer: UObject, ResourceName: string): NavigationSystemModuleConfig;
	static GetDefaultObject(): NavigationSystemModuleConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystemModuleConfig;
	static C(Other: UObject | any): NavigationSystemModuleConfig;
}

declare class NavTestRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): NavTestRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): NavTestRenderingComponent;
	static GetDefaultObject(): NavTestRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavTestRenderingComponent;
	static C(Other: UObject | any): NavTestRenderingComponent;
}

declare type ENavCostDisplay = 'TotalCost' | 'HeuristicOnly' | 'RealCostOnly' | 'ENavCostDisplay_MAX';
declare var ENavCostDisplay : { TotalCost:'TotalCost',HeuristicOnly:'HeuristicOnly',RealCostOnly:'RealCostOnly',ENavCostDisplay_MAX:'ENavCostDisplay_MAX', };
declare class NavigationTestingActor extends Actor { 
	CapsuleComponent: CapsuleComponent;
	EdRenderComp: NavTestRenderingComponent;
	InvokerComponent: NavigationInvokerComponent;
	bActAsNavigationInvoker: boolean;
	NavAgentProps: NavAgentProperties;
	QueryingExtent: Vector;
	MyNavData: NavigationData;
	ProjectedLocation: Vector;
	bProjectedLocationValid: boolean;
	bSearchStart: boolean;
	CostLimitFactor: number;
	MinimumCostLimit: number;
	bBacktracking: boolean;
	bUseHierarchicalPathfinding: boolean;
	bGatherDetailedInfo: boolean;
	bDrawDistanceToWall: boolean;
	bShowNodePool: boolean;
	bShowBestPath: boolean;
	bShowDiffWithPreviousStep: boolean;
	bShouldBeVisibleInGame: boolean;
	CostDisplayMode: ENavCostDisplay;
	TextCanvasOffset: Vector2D;
	bPathExist: boolean;
	bPathIsPartial: boolean;
	bPathSearchOutOfNodes: boolean;
	PathfindingTime: number;
	PathCost: number;
	PathfindingSteps: number;
	OtherActor: NavigationTestingActor;
	FilterClass: UnrealEngineClass;
	ShowStepIndex: number;
	OffsetFromCornersDistance: number;
	static GetDefaultObject(): NavigationTestingActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationTestingActor;
	static C(Other: UObject | any): NavigationTestingActor;
}

declare class NavLinkComponent extends PrimitiveComponent { 
	Links: NavigationLink[];
	static Load(ResourceName: string): NavLinkComponent;
	static Find(Outer: UObject, ResourceName: string): NavLinkComponent;
	static GetDefaultObject(): NavLinkComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkComponent;
	static C(Other: UObject | any): NavLinkComponent;
}

declare class NavLinkCustomInterface extends Interface { 
	static Load(ResourceName: string): NavLinkCustomInterface;
	static Find(Outer: UObject, ResourceName: string): NavLinkCustomInterface;
	static GetDefaultObject(): NavLinkCustomInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkCustomInterface;
	static C(Other: UObject | any): NavLinkCustomInterface;
}

declare class NavLinkHostInterface extends Interface { 
	static Load(ResourceName: string): NavLinkHostInterface;
	static Find(Outer: UObject, ResourceName: string): NavLinkHostInterface;
	static GetDefaultObject(): NavLinkHostInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkHostInterface;
	static C(Other: UObject | any): NavLinkHostInterface;
}

declare class NavLinkDefinition extends UObject { 
	Links: NavigationLink[];
	SegmentLinks: NavigationSegmentLink[];
	static Load(ResourceName: string): NavLinkDefinition;
	static Find(Outer: UObject, ResourceName: string): NavLinkDefinition;
	static GetDefaultObject(): NavLinkDefinition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkDefinition;
	static C(Other: UObject | any): NavLinkDefinition;
}

declare class NavLinkTrivial extends NavLinkDefinition { 
	static Load(ResourceName: string): NavLinkTrivial;
	static Find(Outer: UObject, ResourceName: string): NavLinkTrivial;
	static GetDefaultObject(): NavLinkTrivial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkTrivial;
	static C(Other: UObject | any): NavLinkTrivial;
}

declare class NavMeshRenderingComponent extends DebugDrawComponent { 
	static Load(ResourceName: string): NavMeshRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): NavMeshRenderingComponent;
	static GetDefaultObject(): NavMeshRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMeshRenderingComponent;
	static C(Other: UObject | any): NavMeshRenderingComponent;
}

declare class NavModifierComponent extends NavRelevantComponent { 
	AreaClass: UnrealEngineClass;
	FailsafeExtent: Vector;
	bIncludeAgentHeight: boolean;
	static Load(ResourceName: string): NavModifierComponent;
	static Find(Outer: UObject, ResourceName: string): NavModifierComponent;
	static GetDefaultObject(): NavModifierComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavModifierComponent;
	SetAreaClass(NewAreaClass: UnrealEngineClass): void;
	static C(Other: UObject | any): NavModifierComponent;
}

declare class NavModifierVolume extends Volume { 
	AreaClass: UnrealEngineClass;
	bMaskFillCollisionUnderneathForNavmesh: boolean;
	static GetDefaultObject(): NavModifierVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavModifierVolume;
	SetAreaClass(NewAreaClass: UnrealEngineClass): void;
	static C(Other: UObject | any): NavModifierVolume;
}

declare class NavNodeInterface extends Interface { 
	static Load(ResourceName: string): NavNodeInterface;
	static Find(Outer: UObject, ResourceName: string): NavNodeInterface;
	static GetDefaultObject(): NavNodeInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavNodeInterface;
	static C(Other: UObject | any): NavNodeInterface;
}

declare type ENavSystemOverridePolicy = 'Override' | 'Append' | 'Skip' | 'ENavSystemOverridePolicy_MAX';
declare var ENavSystemOverridePolicy : { Override:'Override',Append:'Append',Skip:'Skip',ENavSystemOverridePolicy_MAX:'ENavSystemOverridePolicy_MAX', };
declare class NavSystemConfigOverride extends Actor { 
	SpriteComponent: BillboardComponent;
	NavigationSystemConfig: NavigationSystemConfig;
	OverridePolicy: ENavSystemOverridePolicy;
	bLoadOnClient: boolean;
	static GetDefaultObject(): NavSystemConfigOverride;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavSystemConfigOverride;
	ApplyChanges(): void;
	static C(Other: UObject | any): NavSystemConfigOverride;
}

declare class RecastFilter_UseDefaultArea extends NavigationQueryFilter { 
	static Load(ResourceName: string): RecastFilter_UseDefaultArea;
	static Find(Outer: UObject, ResourceName: string): RecastFilter_UseDefaultArea;
	static GetDefaultObject(): RecastFilter_UseDefaultArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastFilter_UseDefaultArea;
	static C(Other: UObject | any): RecastFilter_UseDefaultArea;
}

declare class RecastNavMeshDataChunk extends NavigationDataChunk { 
	static Load(ResourceName: string): RecastNavMeshDataChunk;
	static Find(Outer: UObject, ResourceName: string): RecastNavMeshDataChunk;
	static GetDefaultObject(): RecastNavMeshDataChunk;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastNavMeshDataChunk;
	static C(Other: UObject | any): RecastNavMeshDataChunk;
}

declare type ETimezoneSetting = 'InternationalDateLineWest' | 'CoordinatedUniversalTimeNeg11' | 'Samoa' | 'Hawaii' | 'Alaska' | 'PacificTime_USCAN' | 'BajaCalifornia' | 'MountainTime_USCAN' | 'Chihuahua_LaPaz_Mazatlan' | 'Arizona' | 'Saskatchewan' | 'CentralAmerica' | 'CentralTime_USCAN' | 'Guadalajara_MexicoCity_Monterrey' | 'EasternTime_USCAN' | 'Bogota_Lima_Quito' | 'Indiana_US' | 'Caracas' | 'AtlanticTime_Canada' | 'Cuiaba' | 'Santiago' | 'Georgetown_LaPaz_Manaus_SanJuan' | 'Asuncion' | 'Newfoundland' | 'Brasilia' | 'Greenland' | 'Montevideo' | 'Cayenne_Fortaleza' | 'BuenosAires' | 'MidAtlantic' | 'CoordinatedUniversalTimeNeg02' | 'Azores' | 'CaboVerdeIs' | 'Dublin_Edinburgh_Lisbon_London' | 'Monrovia_Reykjavik' | 'Casablanca' | 'UTC' | 'Belgrade_Bratislava_Budapest_Ljubljana_Prague' | 'Sarajevo_Skopje_Warsaw_Zagreb' | 'Brussels_Copenhagen_Madrid_Paris' | 'WestCentralAfrica' | 'Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna' | 'Windhoek' | 'Minsk' | 'Cairo' | 'Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius' | 'Athens_Bucharest' | 'Jerusalem' | 'Amman' | 'Beirut' | 'Harare_Pretoria' | 'Damascus' | 'Istanbul' | 'Kuwait_Riyadh' | 'Baghdad' | 'Nairobi' | 'Kaliningrad' | 'Tehran' | 'Moscow_StPetersburg_Volgograd' | 'AbuDhabi_Muscat' | 'Baku' | 'Yerevan' | 'Tbilisi' | 'PortLouis' | 'Kabul' | 'Tashkent' | 'Islamabad_Karachi' | 'Chennai_Kolkata_Mumbai_NewDelhi' | 'SriJayawardenepura' | 'Kathmandu' | 'Ekaterinburg' | 'Astana' | 'Dhaka' | 'Yangon_Rangoon' | 'Novosibirsk' | 'Bangkok_Hanoi_Jakarta' | 'Krasnoyarsk' | 'Beijing_Chongqing_HongKong_Urumqi' | 'KualaLumpur_Singapore' | 'Taipei' | 'Perth' | 'Ulaanbaatar' | 'Irkutsk' | 'Seoul' | 'Osaka_Sapporo_Tokyo' | 'Darwin' | 'Adelaide' | 'Yakutsk' | 'Canberra_Melbourne_Sydney' | 'Brisbane' | 'Hobart' | 'Guam_PortMoresby' | 'Vladivostok' | 'SolomonIs_NewCaledonia' | 'Magadan' | 'Fiji' | 'Auckland_Wellington' | 'CoordinatedUniversalTime12' | 'Nukualofa' | 'LocalTime' | 'ETimezoneSetting_MAX';
declare var ETimezoneSetting : { InternationalDateLineWest:'InternationalDateLineWest',CoordinatedUniversalTimeNeg11:'CoordinatedUniversalTimeNeg11',Samoa:'Samoa',Hawaii:'Hawaii',Alaska:'Alaska',PacificTime_USCAN:'PacificTime_USCAN',BajaCalifornia:'BajaCalifornia',MountainTime_USCAN:'MountainTime_USCAN',Chihuahua_LaPaz_Mazatlan:'Chihuahua_LaPaz_Mazatlan',Arizona:'Arizona',Saskatchewan:'Saskatchewan',CentralAmerica:'CentralAmerica',CentralTime_USCAN:'CentralTime_USCAN',Guadalajara_MexicoCity_Monterrey:'Guadalajara_MexicoCity_Monterrey',EasternTime_USCAN:'EasternTime_USCAN',Bogota_Lima_Quito:'Bogota_Lima_Quito',Indiana_US:'Indiana_US',Caracas:'Caracas',AtlanticTime_Canada:'AtlanticTime_Canada',Cuiaba:'Cuiaba',Santiago:'Santiago',Georgetown_LaPaz_Manaus_SanJuan:'Georgetown_LaPaz_Manaus_SanJuan',Asuncion:'Asuncion',Newfoundland:'Newfoundland',Brasilia:'Brasilia',Greenland:'Greenland',Montevideo:'Montevideo',Cayenne_Fortaleza:'Cayenne_Fortaleza',BuenosAires:'BuenosAires',MidAtlantic:'MidAtlantic',CoordinatedUniversalTimeNeg02:'CoordinatedUniversalTimeNeg02',Azores:'Azores',CaboVerdeIs:'CaboVerdeIs',Dublin_Edinburgh_Lisbon_London:'Dublin_Edinburgh_Lisbon_London',Monrovia_Reykjavik:'Monrovia_Reykjavik',Casablanca:'Casablanca',UTC:'UTC',Belgrade_Bratislava_Budapest_Ljubljana_Prague:'Belgrade_Bratislava_Budapest_Ljubljana_Prague',Sarajevo_Skopje_Warsaw_Zagreb:'Sarajevo_Skopje_Warsaw_Zagreb',Brussels_Copenhagen_Madrid_Paris:'Brussels_Copenhagen_Madrid_Paris',WestCentralAfrica:'WestCentralAfrica',Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna:'Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna',Windhoek:'Windhoek',Minsk:'Minsk',Cairo:'Cairo',Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius:'Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius',Athens_Bucharest:'Athens_Bucharest',Jerusalem:'Jerusalem',Amman:'Amman',Beirut:'Beirut',Harare_Pretoria:'Harare_Pretoria',Damascus:'Damascus',Istanbul:'Istanbul',Kuwait_Riyadh:'Kuwait_Riyadh',Baghdad:'Baghdad',Nairobi:'Nairobi',Kaliningrad:'Kaliningrad',Tehran:'Tehran',Moscow_StPetersburg_Volgograd:'Moscow_StPetersburg_Volgograd',AbuDhabi_Muscat:'AbuDhabi_Muscat',Baku:'Baku',Yerevan:'Yerevan',Tbilisi:'Tbilisi',PortLouis:'PortLouis',Kabul:'Kabul',Tashkent:'Tashkent',Islamabad_Karachi:'Islamabad_Karachi',Chennai_Kolkata_Mumbai_NewDelhi:'Chennai_Kolkata_Mumbai_NewDelhi',SriJayawardenepura:'SriJayawardenepura',Kathmandu:'Kathmandu',Ekaterinburg:'Ekaterinburg',Astana:'Astana',Dhaka:'Dhaka',Yangon_Rangoon:'Yangon_Rangoon',Novosibirsk:'Novosibirsk',Bangkok_Hanoi_Jakarta:'Bangkok_Hanoi_Jakarta',Krasnoyarsk:'Krasnoyarsk',Beijing_Chongqing_HongKong_Urumqi:'Beijing_Chongqing_HongKong_Urumqi',KualaLumpur_Singapore:'KualaLumpur_Singapore',Taipei:'Taipei',Perth:'Perth',Ulaanbaatar:'Ulaanbaatar',Irkutsk:'Irkutsk',Seoul:'Seoul',Osaka_Sapporo_Tokyo:'Osaka_Sapporo_Tokyo',Darwin:'Darwin',Adelaide:'Adelaide',Yakutsk:'Yakutsk',Canberra_Melbourne_Sydney:'Canberra_Melbourne_Sydney',Brisbane:'Brisbane',Hobart:'Hobart',Guam_PortMoresby:'Guam_PortMoresby',Vladivostok:'Vladivostok',SolomonIs_NewCaledonia:'SolomonIs_NewCaledonia',Magadan:'Magadan',Fiji:'Fiji',Auckland_Wellington:'Auckland_Wellington',CoordinatedUniversalTime12:'CoordinatedUniversalTime12',Nukualofa:'Nukualofa',LocalTime:'LocalTime',ETimezoneSetting_MAX:'ETimezoneSetting_MAX', };
declare class InternationalizationSettingsModel extends UObject { 
	DisplayTimezone: ETimezoneSetting;
	static Load(ResourceName: string): InternationalizationSettingsModel;
	static Find(Outer: UObject, ResourceName: string): InternationalizationSettingsModel;
	static GetDefaultObject(): InternationalizationSettingsModel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationSettingsModel;
	static C(Other: UObject | any): InternationalizationSettingsModel;
}

declare class SplineMetadataDetailsFactoryBase extends UObject { 
	static Load(ResourceName: string): SplineMetadataDetailsFactoryBase;
	static Find(Outer: UObject, ResourceName: string): SplineMetadataDetailsFactoryBase;
	static GetDefaultObject(): SplineMetadataDetailsFactoryBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadataDetailsFactoryBase;
	static C(Other: UObject | any): SplineMetadataDetailsFactoryBase;
}

declare class ActorFactory extends UObject { 
	DisplayName: string;
	MenuPriority: number;
	NewActorClassName: string;
	NewActorClass: UnrealEngineClass;
	bShowInEditorQuickMenu: boolean;
	bUseSurfaceOrientation: boolean;
	bUsePlacementExtent: boolean;
	SpawnPositionOffset: Vector;
	static Load(ResourceName: string): ActorFactory;
	static Find(Outer: UObject, ResourceName: string): ActorFactory;
	static GetDefaultObject(): ActorFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactory;
	static C(Other: UObject | any): ActorFactory;
}

declare class ActorFactoryVolume extends ActorFactory { 
	static Load(ResourceName: string): ActorFactoryVolume;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryVolume;
	static GetDefaultObject(): ActorFactoryVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryVolume;
	static C(Other: UObject | any): ActorFactoryVolume;
}

declare class ActorFactoryBoxVolume extends ActorFactoryVolume { 
	static Load(ResourceName: string): ActorFactoryBoxVolume;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryBoxVolume;
	static GetDefaultObject(): ActorFactoryBoxVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryBoxVolume;
	static C(Other: UObject | any): ActorFactoryBoxVolume;
}

declare class ActorFactoryProceduralFoliage extends ActorFactoryBoxVolume { 
	static Load(ResourceName: string): ActorFactoryProceduralFoliage;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryProceduralFoliage;
	static GetDefaultObject(): ActorFactoryProceduralFoliage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryProceduralFoliage;
	static C(Other: UObject | any): ActorFactoryProceduralFoliage;
}

declare class FoliageType_InstancedStaticMeshFactory extends Factory { 
	static Load(ResourceName: string): FoliageType_InstancedStaticMeshFactory;
	static Find(Outer: UObject, ResourceName: string): FoliageType_InstancedStaticMeshFactory;
	static GetDefaultObject(): FoliageType_InstancedStaticMeshFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMeshFactory;
	static C(Other: UObject | any): FoliageType_InstancedStaticMeshFactory;
}

declare class FoliageType_ActorFactory extends Factory { 
	static Load(ResourceName: string): FoliageType_ActorFactory;
	static Find(Outer: UObject, ResourceName: string): FoliageType_ActorFactory;
	static GetDefaultObject(): FoliageType_ActorFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_ActorFactory;
	static C(Other: UObject | any): FoliageType_ActorFactory;
}

declare class BlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): BlueprintThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): BlueprintThumbnailRenderer;
	static GetDefaultObject(): BlueprintThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintThumbnailRenderer;
	static C(Other: UObject | any): BlueprintThumbnailRenderer;
}

declare class FoliageType_ActorThumbnailRenderer extends BlueprintThumbnailRenderer { 
	static Load(ResourceName: string): FoliageType_ActorThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): FoliageType_ActorThumbnailRenderer;
	static GetDefaultObject(): FoliageType_ActorThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_ActorThumbnailRenderer;
	static C(Other: UObject | any): FoliageType_ActorThumbnailRenderer;
}

declare class FoliageType_ISMThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): FoliageType_ISMThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): FoliageType_ISMThumbnailRenderer;
	static GetDefaultObject(): FoliageType_ISMThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_ISMThumbnailRenderer;
	static C(Other: UObject | any): FoliageType_ISMThumbnailRenderer;
}

declare class LandscapeGrassTypeFactory extends Factory { 
	static Load(ResourceName: string): LandscapeGrassTypeFactory;
	static Find(Outer: UObject, ResourceName: string): LandscapeGrassTypeFactory;
	static GetDefaultObject(): LandscapeGrassTypeFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeGrassTypeFactory;
	static C(Other: UObject | any): LandscapeGrassTypeFactory;
}

declare type EFoliageScaling = 'Uniform' | 'Free' | 'LockXY' | 'LockXZ' | 'LockYZ' | 'EFoliageScaling_MAX';
declare var EFoliageScaling : { Uniform:'Uniform',Free:'Free',LockXY:'LockXY',LockXZ:'LockXZ',LockYZ:'LockYZ',EFoliageScaling_MAX:'EFoliageScaling_MAX', };
declare class FloatInterval { 
	Min: number;
	Max: number;
	clone() : FloatInterval;
	static C(Other: UObject | any): FloatInterval;
}

declare class FoliageVertexColorChannelMask { 
	UseMask: boolean;
	MaskThreshold: number;
	InvertMask: boolean;
	clone() : FoliageVertexColorChannelMask;
	static C(Other: UObject | any): FoliageVertexColorChannelMask;
}

declare type FoliageVertexColorMask = 'FOLIAGEVERTEXCOLORMASK_Disabled' | 'FOLIAGEVERTEXCOLORMASK_Red' | 'FOLIAGEVERTEXCOLORMASK_Green' | 'FOLIAGEVERTEXCOLORMASK_Blue' | 'FOLIAGEVERTEXCOLORMASK_Alpha' | 'FOLIAGEVERTEXCOLORMASK_MAX';
declare var FoliageVertexColorMask : { FOLIAGEVERTEXCOLORMASK_Disabled:'FOLIAGEVERTEXCOLORMASK_Disabled',FOLIAGEVERTEXCOLORMASK_Red:'FOLIAGEVERTEXCOLORMASK_Red',FOLIAGEVERTEXCOLORMASK_Green:'FOLIAGEVERTEXCOLORMASK_Green',FOLIAGEVERTEXCOLORMASK_Blue:'FOLIAGEVERTEXCOLORMASK_Blue',FOLIAGEVERTEXCOLORMASK_Alpha:'FOLIAGEVERTEXCOLORMASK_Alpha',FOLIAGEVERTEXCOLORMASK_MAX:'FOLIAGEVERTEXCOLORMASK_MAX', };
declare class Int32Interval { 
	Min: number;
	Max: number;
	clone() : Int32Interval;
	static C(Other: UObject | any): Int32Interval;
}

declare class FoliageDensityFalloff { 
	bUseFalloffCurve: boolean;
	FalloffCurve: RuntimeFloatCurve;
	clone() : FoliageDensityFalloff;
	static C(Other: UObject | any): FoliageDensityFalloff;
}

declare class FoliageType extends UObject { 
	UpdateGuid: Guid;
	Density: number;
	DensityAdjustmentFactor: number;
	Radius: number;
	bSingleInstanceModeOverrideRadius: boolean;
	SingleInstanceModeRadius: number;
	Scaling: EFoliageScaling;
	ScaleX: FloatInterval;
	ScaleY: FloatInterval;
	ScaleZ: FloatInterval;
	VertexColorMaskByChannel: FoliageVertexColorChannelMask;
	VertexColorMask: FoliageVertexColorMask;
	VertexColorMaskThreshold: number;
	VertexColorMaskInvert: boolean;
	ZOffset: FloatInterval;
	AlignToNormal: boolean;
	AverageNormal: boolean;
	AverageNormalSingleComponent: boolean;
	AlignMaxAngle: number;
	RandomYaw: boolean;
	RandomPitchAngle: number;
	GroundSlopeAngle: FloatInterval;
	Height: FloatInterval;
	LandscapeLayers: string[];
	MinimumLayerWeight: number;
	ExclusionLandscapeLayers: string[];
	MinimumExclusionLayerWeight: number;
	LandscapeLayer: string;
	CollisionWithWorld: boolean;
	CollisionScale: Vector;
	AverageNormalSampleCount: number;
	MeshBounds: BoxSphereBounds;
	LowBoundOriginRadius: Vector;
	Mobility: EComponentMobility;
	CullDistance: Int32Interval;
	bEnableStaticLighting: boolean;
	CastShadow: boolean;
	bAffectDynamicIndirectLighting: boolean;
	bAffectDistanceFieldLighting: boolean;
	bCastDynamicShadow: boolean;
	bCastStaticShadow: boolean;
	bCastContactShadow: boolean;
	bCastShadowAsTwoSided: boolean;
	bReceivesDecals: boolean;
	bOverrideLightMapRes: boolean;
	OverriddenLightMapRes: number;
	LightmapType: ELightmapType;
	bUseAsOccluder: boolean;
	bVisibleInRayTracing: boolean;
	bEvaluateWorldPositionOffset: boolean;
	BodyInstance: BodyInstance;
	CustomNavigableGeometry: EHasCustomNavigableGeometry;
	LightingChannels: LightingChannels;
	bRenderCustomDepth: boolean;
	CustomDepthStencilWriteMask: ERendererStencilMask;
	CustomDepthStencilValue: number;
	TranslucencySortPriority: number;
	HiddenEditorViews: any;
	IsSelected: boolean;
	CollisionRadius: number;
	ShadeRadius: number;
	NumSteps: number;
	InitialSeedDensity: number;
	AverageSpreadDistance: number;
	SpreadVariance: number;
	SeedsPerStep: number;
	DistributionSeed: number;
	MaxInitialSeedOffset: number;
	bCanGrowInShade: boolean;
	bSpawnsInShade: boolean;
	MaxInitialAge: number;
	MaxAge: number;
	OverlapPriority: number;
	ProceduralScale: FloatInterval;
	ScaleCurve: RuntimeFloatCurve;
	DensityFalloff: FoliageDensityFalloff;
	ChangeCount: number;
	ReapplyDensity: boolean;
	ReapplyRadius: boolean;
	ReapplyAlignToNormal: boolean;
	ReapplyRandomYaw: boolean;
	ReapplyScaling: boolean;
	ReapplyScaleX: boolean;
	ReapplyScaleY: boolean;
	ReapplyScaleZ: boolean;
	ReapplyRandomPitchAngle: boolean;
	ReapplyGroundSlope: boolean;
	ReapplyHeight: boolean;
	ReapplyLandscapeLayers: boolean;
	ReapplyZOffset: boolean;
	ReapplyCollisionWithWorld: boolean;
	ReapplyVertexColorMask: boolean;
	bEnableDensityScaling: boolean;
	bEnableDiscardOnLoad: boolean;
	RuntimeVirtualTextures: RuntimeVirtualTexture[];
	VirtualTextureCullMips: number;
	VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
	bIncludeInHLOD: boolean;
	ScaleMinX: number;
	ScaleMinY: number;
	ScaleMinZ: number;
	ScaleMaxX: number;
	ScaleMaxY: number;
	ScaleMaxZ: number;
	HeightMin: number;
	HeightMax: number;
	ZOffsetMin: number;
	ZOffsetMax: number;
	StartCullDistance: number;
	EndCullDistance: number;
	UniformScale: boolean;
	LockScaleX: boolean;
	LockScaleY: boolean;
	LockScaleZ: boolean;
	GroundSlope: number;
	MinGroundSlope: number;
	MinScale: number;
	MaxScale: number;
	static Load(ResourceName: string): FoliageType;
	static Find(Outer: UObject, ResourceName: string): FoliageType;
	static GetDefaultObject(): FoliageType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType;
	static C(Other: UObject | any): FoliageType;
}

declare class InstancedStaticMeshInstanceData { 
	Transform: Matrix;
	clone() : InstancedStaticMeshInstanceData;
	static C(Other: UObject | any): InstancedStaticMeshInstanceData;
}

declare class InstancedStaticMeshRandomSeed { 
	StartInstanceIndex: number;
	RandomSeed: number;
	clone() : InstancedStaticMeshRandomSeed;
	static C(Other: UObject | any): InstancedStaticMeshRandomSeed;
}

declare class InstancedStaticMeshMappingInfo { 
	clone() : InstancedStaticMeshMappingInfo;
	static C(Other: UObject | any): InstancedStaticMeshMappingInfo;
}

declare class InstancedStaticMeshComponent extends StaticMeshComponent { 
	PerInstanceSMData: InstancedStaticMeshInstanceData[];
	PerInstancePrevTransform: Matrix[];
	NumCustomDataFloats: number;
	PerInstanceSMCustomData: number[];
	InstancingRandomSeed: number;
	AdditionalRandomSeeds: InstancedStaticMeshRandomSeed[];
	InstanceStartCullDistance: number;
	InstanceEndCullDistance: number;
	InstanceReorderTable: number[];
	NumPendingLightmaps: number;
	CachedMappings: InstancedStaticMeshMappingInfo[];
	static Load(ResourceName: string): InstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): InstancedStaticMeshComponent;
	static GetDefaultObject(): InstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InstancedStaticMeshComponent;
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	SetCustomDataValue(InstanceIndex: number,CustomDataIndex: number,CustomDataValue: number,bMarkRenderStateDirty: boolean): boolean;
	SetCullDistances(StartCullDistance: number,EndCullDistance: number): void;
	RemoveInstances(InstancesToRemove: number[]): boolean;
	RemoveInstance(InstanceIndex: number): boolean;
	IsValidInstance(InstanceIndex: number): boolean;
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	GetInstancesOverlappingSphere(Center: Vector,Radius: number,bSphereInWorldSpace: boolean): number[];
	GetInstancesOverlappingBox(Box: Box,bBoxInWorldSpace: boolean): number[];
	GetInstanceCount(): number;
	ClearInstances(): void;
	BatchUpdateInstancesTransforms(StartInstanceIndex: number,NewInstancesTransforms: Transform[],bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	BatchUpdateInstancesTransform(StartInstanceIndex: number,NumInstances: number,NewInstancesTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	AddInstanceWorldSpace(WorldTransform: Transform): number;
	AddInstances(InstanceTransforms: Transform[],bShouldReturnIndices: boolean,bWorldSpace: boolean): number[];
	AddInstance(InstanceTransform: Transform,bWorldSpace: boolean): number;
	static C(Other: UObject | any): InstancedStaticMeshComponent;
	K2_AcquireEditorSMInstanceElementHandle(InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
	static K2_AcquireEditorSMInstanceElementHandle(ISMComponent: InstancedStaticMeshComponent,InstanceIndex: number,bAllowCreate: boolean): ScriptTypedElementHandle;
}

declare class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent { 
	bUseTranslatedInstanceSpace: boolean;
	TranslatedInstanceSpaceOrigin: Vector;
	SortedInstances: number[];
	NumBuiltInstances: number;
	BuiltInstanceBounds: Box;
	UnbuiltInstanceBounds: Box;
	UnbuiltInstanceBoundsList: Box[];
	bEnableDensityScaling: boolean;
	OcclusionLayerNumNodes: number;
	CacheMeshExtendedBounds: BoxSphereBounds;
	bDisableCollision: boolean;
	InstanceCountToRender: number;
	static Load(ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): HierarchicalInstancedStaticMeshComponent;
	static GetDefaultObject(): HierarchicalInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalInstancedStaticMeshComponent;
	static C(Other: UObject | any): HierarchicalInstancedStaticMeshComponent;
}

declare class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent { 
	OnInstanceTakePointDamage: UnrealEngineMulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: Controller, HitLocation: Vector, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
	OnInstanceTakeRadialDamage: UnrealEngineMulticastDelegate<(Instances: number[], Damages: number[], InstigatedBy: Controller, Origin: Vector, MaxRadius: number, DamageType: DamageType, DamageCauser: Actor) => void>;
	bEnableDiscardOnLoad: boolean;
	FoliageHiddenEditorViews: any;
	GenerationGuid: Guid;
	static Load(ResourceName: string): FoliageInstancedStaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): FoliageInstancedStaticMeshComponent;
	static GetDefaultObject(): FoliageInstancedStaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageInstancedStaticMeshComponent;
	static C(Other: UObject | any): FoliageInstancedStaticMeshComponent;
}

declare class FoliageType_InstancedStaticMesh extends FoliageType { 
	Mesh: StaticMesh;
	OverrideMaterials: MaterialInterface[];
	ComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): FoliageType_InstancedStaticMesh;
	static Find(Outer: UObject, ResourceName: string): FoliageType_InstancedStaticMesh;
	static GetDefaultObject(): FoliageType_InstancedStaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FoliageType_InstancedStaticMesh;
	static C(Other: UObject | any): FoliageType_InstancedStaticMesh;
}

declare class FoliageTypeObject { 
	FoliageTypeObject: UObject;
	TypeInstance: FoliageType;
	bIsAsset: boolean;
	Type: UnrealEngineClass;
	clone() : FoliageTypeObject;
	static C(Other: UObject | any): FoliageTypeObject;
}

declare class ProceduralFoliageSpawner extends UObject { 
	RandomSeed: number;
	TileSize: number;
	NumUniqueTiles: number;
	MinimumQuadTreeSize: number;
	FoliageTypes: FoliageTypeObject[];
	static Load(ResourceName: string): ProceduralFoliageSpawner;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageSpawner;
	static GetDefaultObject(): ProceduralFoliageSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawner;
	Simulate(NumSteps: number): void;
	static C(Other: UObject | any): ProceduralFoliageSpawner;
}

declare class ProceduralFoliageComponent extends ActorComponent { 
	FoliageSpawner: ProceduralFoliageSpawner;
	TileOverlap: number;
	bAllowLandscape: boolean;
	bAllowBSP: boolean;
	bAllowStaticMesh: boolean;
	bAllowTranslucent: boolean;
	bAllowFoliage: boolean;
	bShowDebugTiles: boolean;
	DataLayer: ActorDataLayer;
	SpawningVolume: Volume;
	ProceduralGuid: Guid;
	LastSimulationDataLayer: ActorDataLayer;
	static Load(ResourceName: string): ProceduralFoliageComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageComponent;
	static C(Other: UObject | any): ProceduralFoliageComponent;
}

declare class ProceduralFoliageVolume extends Volume { 
	ProceduralComponent: ProceduralFoliageComponent;
	static GetDefaultObject(): ProceduralFoliageVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageVolume;
	static C(Other: UObject | any): ProceduralFoliageVolume;
}

declare class ProceduralFoliageEditorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ProceduralFoliageEditorLibrary;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageEditorLibrary;
	static GetDefaultObject(): ProceduralFoliageEditorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageEditorLibrary;
	static ResimulateProceduralFoliageVolumes(ProceduralFoliageVolumes: ProceduralFoliageVolume[]): void;
	static ResimulateProceduralFoliageComponents(ProceduralFoliageComponents: ProceduralFoliageComponent[]): void;
	static ClearProceduralFoliageVolumes(ProceduralFoliageVolumes: ProceduralFoliageVolume[]): void;
	static ClearProceduralFoliageComponents(ProceduralFoliageComponents: ProceduralFoliageComponent[]): void;
	static C(Other: UObject | any): ProceduralFoliageEditorLibrary;
}

declare class ProceduralFoliageSpawnerFactory extends Factory { 
	static Load(ResourceName: string): ProceduralFoliageSpawnerFactory;
	static Find(Outer: UObject, ResourceName: string): ProceduralFoliageSpawnerFactory;
	static GetDefaultObject(): ProceduralFoliageSpawnerFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralFoliageSpawnerFactory;
	static C(Other: UObject | any): ProceduralFoliageSpawnerFactory;
}

declare class CookerStats extends UObject { 
	Assets: any[];
	SizeBefore: number;
	SizeAfter: number;
	Path: string;
	static Load(ResourceName: string): CookerStats;
	static Find(Outer: UObject, ResourceName: string): CookerStats;
	static GetDefaultObject(): CookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CookerStats;
	static C(Other: UObject | any): CookerStats;
}

declare class LightingBuildInfo extends UObject { 
	UObject: any;
	LightingTime: number;
	UnmappedTexelsPercentage: number;
	UnmappedTexelsMemory: number;
	TotalTexelMemory: number;
	LevelName: string;
	static Load(ResourceName: string): LightingBuildInfo;
	static Find(Outer: UObject, ResourceName: string): LightingBuildInfo;
	static GetDefaultObject(): LightingBuildInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightingBuildInfo;
	static C(Other: UObject | any): LightingBuildInfo;
}

declare class PrimitiveStats extends UObject { 
	UObject: any;
	Actors: any[];
	Type: string;
	Count: number;
	Sections: number;
	HWInstances: number;
	InstSections: number;
	Triangles: number;
	InstTriangles: number;
	ResourceSize: number;
	VertexColorMem: number;
	InstVertexColorMem: number;
	LightsLM: number;
	LightsOther: number;
	LightsTotal: number;
	ObjLightCost: number;
	LightMapData: number;
	LMSMResolution: number;
	RadiusMin: number;
	RadiusMax: number;
	RadiusAvg: number;
	static Load(ResourceName: string): PrimitiveStats;
	static Find(Outer: UObject, ResourceName: string): PrimitiveStats;
	static GetDefaultObject(): PrimitiveStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveStats;
	static C(Other: UObject | any): PrimitiveStats;
}

declare class ShaderCookerStats extends UObject { 
	Name: string;
	Platform: string;
	Category: string;
	Compiled: number;
	Cooked: number;
	Permutations: number;
	CompileTime: number;
	Path: string;
	static Load(ResourceName: string): ShaderCookerStats;
	static Find(Outer: UObject, ResourceName: string): ShaderCookerStats;
	static GetDefaultObject(): ShaderCookerStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShaderCookerStats;
	static C(Other: UObject | any): ShaderCookerStats;
}

declare class StaticMeshLightingInfo extends UObject { 
	StaticMeshActor: any;
	StaticMesh: any;
	LevelName: string;
	TextureMapping: string;
	bTextureMapping: boolean;
	bHasLightmapTexCoords: boolean;
	StaticLightingResolution: number;
	TextureLightMapMemoryUsage: number;
	VertexLightMapMemoryUsage: number;
	LightMapLightCount: number;
	TextureShadowMapMemoryUsage: number;
	VertexShadowMapMemoryUsage: number;
	ShadowMapLightCount: number;
	LightmapTextureNames: string[];
	static Load(ResourceName: string): StaticMeshLightingInfo;
	static Find(Outer: UObject, ResourceName: string): StaticMeshLightingInfo;
	static GetDefaultObject(): StaticMeshLightingInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshLightingInfo;
	static C(Other: UObject | any): StaticMeshLightingInfo;
}

declare class TextureStats extends UObject { 
	Texture: any;
	Actors: any[];
	Type: string;
	Virtual: string;
	MaxDim: Vector2D;
	CurrentDim: Vector2D;
	Format: EPixelFormat;
	Group: TextureGroup;
	LODBias: number;
	CurrentKB: number;
	FullyLoadedKB: number;
	NumUses: number;
	LastTimeRendered: number;
	Path: string;
	static Load(ResourceName: string): TextureStats;
	static Find(Outer: UObject, ResourceName: string): TextureStats;
	static GetDefaultObject(): TextureStats;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureStats;
	static C(Other: UObject | any): TextureStats;
}

declare class TextureImportSettings extends DeveloperSettings { 
	AutoVTSize: number;
	static Load(ResourceName: string): TextureImportSettings;
	static Find(Outer: UObject, ResourceName: string): TextureImportSettings;
	static GetDefaultObject(): TextureImportSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureImportSettings;
	static C(Other: UObject | any): TextureImportSettings;
}

declare class ClothConfigCommon extends ClothConfigBase { 
	static Load(ResourceName: string): ClothConfigCommon;
	static Find(Outer: UObject, ResourceName: string): ClothConfigCommon;
	static GetDefaultObject(): ClothConfigCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigCommon;
	static C(Other: UObject | any): ClothConfigCommon;
}

declare class ClothSharedConfigCommon extends ClothConfigCommon { 
	static Load(ResourceName: string): ClothSharedConfigCommon;
	static Find(Outer: UObject, ResourceName: string): ClothSharedConfigCommon;
	static GetDefaultObject(): ClothSharedConfigCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothSharedConfigCommon;
	static C(Other: UObject | any): ClothSharedConfigCommon;
}

declare class ClothingAssetCustomData extends UObject { 
	static Load(ResourceName: string): ClothingAssetCustomData;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCustomData;
	static GetDefaultObject(): ClothingAssetCustomData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCustomData;
	static C(Other: UObject | any): ClothingAssetCustomData;
}

declare class ClothTetherData { 
	clone() : ClothTetherData;
	static C(Other: UObject | any): ClothTetherData;
}

declare class ClothPhysicalMeshData { 
	Vertices: Vector3f[];
	Normals: Vector3f[];
	VertexColors: Color[];
	Indices: any[];
	WeightMaps: any;
	InverseMasses: number[];
	BoneData: ClothVertBoneData[];
	SelfCollisionIndices: any[];
	EuclideanTethers: ClothTetherData;
	GeodesicTethers: ClothTetherData;
	MaxBoneWeights: number;
	NumFixedVerts: number;
	MaxDistances: number[];
	BackstopDistances: number[];
	BackstopRadiuses: number[];
	AnimDriveMultipliers: number[];
	clone() : ClothPhysicalMeshData;
	static C(Other: UObject | any): ClothPhysicalMeshData;
}

declare class ClothCollisionPrim_Sphere { 
	BoneIndex: number;
	Radius: number;
	LocalPosition: Vector;
	clone() : ClothCollisionPrim_Sphere;
	static C(Other: UObject | any): ClothCollisionPrim_Sphere;
}

declare class ClothCollisionPrim_SphereConnection { 
	SphereIndices: number;
	clone() : ClothCollisionPrim_SphereConnection;
	static C(Other: UObject | any): ClothCollisionPrim_SphereConnection;
}

declare class ClothCollisionPrim_ConvexFace { 
	Plane: Plane;
	Indices: number[];
	clone() : ClothCollisionPrim_ConvexFace;
	static C(Other: UObject | any): ClothCollisionPrim_ConvexFace;
}

declare class ClothCollisionPrim_Convex { 
	planes: Plane[];
	Faces: ClothCollisionPrim_ConvexFace[];
	SurfacePoints: Vector[];
	BoneIndex: number;
	clone() : ClothCollisionPrim_Convex;
	static C(Other: UObject | any): ClothCollisionPrim_Convex;
}

declare class ClothCollisionPrim_Box { 
	LocalPosition: Vector;
	LocalRotation: Quat;
	HalfExtents: Vector;
	BoneIndex: number;
	clone() : ClothCollisionPrim_Box;
	static C(Other: UObject | any): ClothCollisionPrim_Box;
}

declare class ClothCollisionData { 
	Spheres: ClothCollisionPrim_Sphere[];
	SphereConnections: ClothCollisionPrim_SphereConnection[];
	Convexes: ClothCollisionPrim_Convex[];
	Boxes: ClothCollisionPrim_Box[];
	clone() : ClothCollisionData;
	static C(Other: UObject | any): ClothCollisionData;
}

declare class PointWeightMap { 
	Values: number[];
	Name: string;
	CurrentTarget: number;
	bEnabled: boolean;
	clone() : PointWeightMap;
	static C(Other: UObject | any): PointWeightMap;
}

declare class ClothLODDataCommon_Legacy extends UObject { 
	PhysicalMeshData: ClothPhysicalMeshDataBase_Legacy;
	ClothPhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	ParameterMasks: PointWeightMap[];
	static Load(ResourceName: string): ClothLODDataCommon_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothLODDataCommon_Legacy;
	static GetDefaultObject(): ClothLODDataCommon_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothLODDataCommon_Legacy;
	static C(Other: UObject | any): ClothLODDataCommon_Legacy;
}

declare type EWeightMapTargetCommon = 'None' | 'MaxDistance' | 'BackstopDistance' | 'BackstopRadius' | 'AnimDriveStiffness' | 'AnimDriveDamping_DEPRECATED' | 'EWeightMapTargetCommon_MAX';
declare var EWeightMapTargetCommon : { None:'None',MaxDistance:'MaxDistance',BackstopDistance:'BackstopDistance',BackstopRadius:'BackstopRadius',AnimDriveStiffness:'AnimDriveStiffness',AnimDriveDamping_DEPRECATED:'AnimDriveDamping_DEPRECATED',EWeightMapTargetCommon_MAX:'EWeightMapTargetCommon_MAX', };
declare class ClothParameterMask_Legacy { 
	MaskName: string;
	CurrentTarget: EWeightMapTargetCommon;
	MaxValue: number;
	MinValue: number;
	Values: number[];
	bEnabled: boolean;
	clone() : ClothParameterMask_Legacy;
	static C(Other: UObject | any): ClothParameterMask_Legacy;
}

declare class ClothLODDataCommon { 
	PhysicalMeshData: ClothPhysicalMeshData;
	CollisionData: ClothCollisionData;
	bUseMultipleInfluences: boolean;
	SkinningKernelRadius: number;
	bSmoothTransition: boolean;
	ParameterMasks: ClothParameterMask_Legacy[];
	PointWeightMaps: PointWeightMap[];
	clone() : ClothLODDataCommon;
	static C(Other: UObject | any): ClothLODDataCommon;
}

declare type EClothingWindMethod_Legacy = 'Legacy' | 'Accurate' | 'EClothingWindMethod_MAX';
declare var EClothingWindMethod_Legacy : { Legacy:'Legacy',Accurate:'Accurate',EClothingWindMethod_MAX:'EClothingWindMethod_MAX', };
declare class ClothConstraintSetup_Legacy { 
	Stiffness: number;
	StiffnessMultiplier: number;
	StretchLimit: number;
	CompressionLimit: number;
	clone() : ClothConstraintSetup_Legacy;
	static C(Other: UObject | any): ClothConstraintSetup_Legacy;
}

declare class ClothConfig_Legacy { 
	WindMethod: EClothingWindMethod_Legacy;
	VerticalConstraintConfig: ClothConstraintSetup_Legacy;
	HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
	BendConstraintConfig: ClothConstraintSetup_Legacy;
	ShearConstraintConfig: ClothConstraintSetup_Legacy;
	SelfCollisionRadius: number;
	SelfCollisionStiffness: number;
	SelfCollisionCullScale: number;
	Damping: Vector;
	Friction: number;
	WindDragCoefficient: number;
	WindLiftCoefficient: number;
	LinearDrag: Vector;
	AngularDrag: Vector;
	LinearInertiaScale: Vector;
	AngularInertiaScale: Vector;
	CentrifugalInertiaScale: Vector;
	SolverFrequency: number;
	StiffnessFrequency: number;
	GravityScale: number;
	GravityOverride: Vector;
	bUseGravityOverride: boolean;
	TetherStiffness: number;
	TetherLimit: number;
	CollisionThickness: number;
	AnimDriveSpringStiffness: number;
	AnimDriveDamperStiffness: number;
	clone() : ClothConfig_Legacy;
	static C(Other: UObject | any): ClothConfig_Legacy;
}

declare class ClothingAssetCommon extends ClothingAssetBase { 
	PhysicsAsset: PhysicsAsset;
	ClothConfigs: any;
	ClothSharedSimConfig: ClothConfigBase;
	ClothSimConfig: ClothConfigBase;
	ChaosClothSimConfig: ClothConfigBase;
	ClothLODData: ClothLODDataCommon_Legacy[];
	LODData: ClothLODDataCommon[];
	LodMap: number[];
	UsedBoneNames: string[];
	UsedBoneIndices: number[];
	ReferenceBoneIndex: number;
	CustomData: ClothingAssetCustomData;
	ClothConfig: ClothConfig_Legacy;
	static Load(ResourceName: string): ClothingAssetCommon;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetCommon;
	static GetDefaultObject(): ClothingAssetCommon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetCommon;
	static C(Other: UObject | any): ClothingAssetCommon;
}

declare class PreviewSceneProfile { 
	ProfileName: string;
	bSharedProfile: boolean;
	bUseSkyLighting: boolean;
	DirectionalLightIntensity: number;
	DirectionalLightColor: LinearColor;
	SkyLightIntensity: number;
	bRotateLightingRig: boolean;
	bShowEnvironment: boolean;
	bShowFloor: boolean;
	EnvironmentColor: LinearColor;
	EnvironmentIntensity: number;
	EnvironmentCubeMap: TextureCube;
	EnvironmentCubeMapPath: string;
	bPostProcessingEnabled: boolean;
	PostProcessingSettings: PostProcessSettings;
	LightingRigRotation: number;
	RotationSpeed: number;
	DirectionalLightRotation: Rotator;
	clone() : PreviewSceneProfile;
	static C(Other: UObject | any): PreviewSceneProfile;
}

declare class LocalProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): LocalProfiles;
	static Find(Outer: UObject, ResourceName: string): LocalProfiles;
	static GetDefaultObject(): LocalProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalProfiles;
	static C(Other: UObject | any): LocalProfiles;
}

declare class SharedProfiles extends UObject { 
	Profiles: PreviewSceneProfile[];
	static Load(ResourceName: string): SharedProfiles;
	static Find(Outer: UObject, ResourceName: string): SharedProfiles;
	static GetDefaultObject(): SharedProfiles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SharedProfiles;
	static C(Other: UObject | any): SharedProfiles;
}

declare class AssetViewerSettings extends UObject { 
	Profiles: PreviewSceneProfile[];
	bFakeConfigValue_HACK: boolean;
	static Load(ResourceName: string): AssetViewerSettings;
	static Find(Outer: UObject, ResourceName: string): AssetViewerSettings;
	static GetDefaultObject(): AssetViewerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetViewerSettings;
	static C(Other: UObject | any): AssetViewerSettings;
}

declare class PropertyEntry { 
	Property: EMaterialProperty;
	bUseCustomSize: boolean;
	CustomSize: IntPoint;
	bUseConstantValue: boolean;
	ConstantValue: number;
	clone() : PropertyEntry;
	static C(Other: UObject | any): PropertyEntry;
}

declare class MaterialOptions extends UObject { 
	Properties: PropertyEntry[];
	TextureSize: IntPoint;
	LODIndices: number[];
	bUseMeshData: boolean;
	bUseSpecificUVIndex: boolean;
	TextureCoordinateIndex: number;
	static Load(ResourceName: string): MaterialOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialOptions;
	static GetDefaultObject(): MaterialOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialOptions;
	static C(Other: UObject | any): MaterialOptions;
}

declare class AssetBakeOptions extends UObject { 
	static Load(ResourceName: string): AssetBakeOptions;
	static Find(Outer: UObject, ResourceName: string): AssetBakeOptions;
	static GetDefaultObject(): AssetBakeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetBakeOptions;
	static C(Other: UObject | any): AssetBakeOptions;
}

declare type EMaterialBakeMethod = 'IndividualMaterial' | 'AtlasMaterial' | 'BinnedMaterial' | 'EMaterialBakeMethod_MAX';
declare var EMaterialBakeMethod : { IndividualMaterial:'IndividualMaterial',AtlasMaterial:'AtlasMaterial',BinnedMaterial:'BinnedMaterial',EMaterialBakeMethod_MAX:'EMaterialBakeMethod_MAX', };
declare class MaterialMergeOptions extends UObject { 
	Method: EMaterialBakeMethod;
	BlendMode: EBlendMode;
	static Load(ResourceName: string): MaterialMergeOptions;
	static Find(Outer: UObject, ResourceName: string): MaterialMergeOptions;
	static GetDefaultObject(): MaterialMergeOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialMergeOptions;
	static C(Other: UObject | any): MaterialMergeOptions;
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	ParameterStateId: Guid;
	PhysMaterialMask: PhysicalMaterialMask;
	static Load(ResourceName: string): MaterialInstanceConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceConstant;
	static GetDefaultObject(): MaterialInstanceConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValue(ParameterName: string): number;
	static C(Other: UObject | any): MaterialInstanceConstant;
	ClearAllMaterialInstanceParameters(): void;
	GetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	GetMaterialInstanceScalarParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): number;
	GetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	GetMaterialInstanceTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	GetMaterialInstanceVectorParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	SetMaterialInstanceParent(NewParent: MaterialInterface): void;
	SetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceScalarParameterValue(ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceTextureParameterValue(ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceVectorParameterValue(ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	UpdateMaterialInstance(): void;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
}

declare class MaterialEditingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MaterialEditingLibrary;
	static Find(Outer: UObject, ResourceName: string): MaterialEditingLibrary;
	static GetDefaultObject(): MaterialEditingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditingLibrary;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunctionInterface,PreviewMaterial: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static RecompileMaterial(Material: Material): void;
	static LayoutMaterialFunctionExpressions(MaterialFunction: MaterialFunction): void;
	static LayoutMaterialExpressions(Material: Material): void;
	static HasMaterialUsage(Material: Material,Usage: EMaterialUsage): boolean;
	static GetVectorParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetVectorParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetUsedTextures(Material: Material): Texture[];
	static GetTextureParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetTextureParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetStatistics(Material: MaterialInterface): MaterialStatistics;
	static GetStaticSwitchParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetStaticSwitchParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetScalarParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetScalarParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static GetNumMaterialExpressions(Material: Material): number;
	static GetMaterialSelectedNodes(Material: Material): any;
	static GetMaterialPropertyInputNode(Material: Material,Property: EMaterialProperty): MaterialExpression;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialDefaultVectorParameterValue(Material: Material,ParameterName: string): LinearColor;
	static GetMaterialDefaultTextureParameterValue(Material: Material,ParameterName: string): Texture;
	static GetMaterialDefaultStaticSwitchParameterValue(Material: Material,ParameterName: string): boolean;
	static GetMaterialDefaultScalarParameterValue(Material: Material,ParameterName: string): number;
	static GetInputsForMaterialExpression(Material: Material,MaterialExpression: MaterialExpression): MaterialExpression[];
	static GetChildInstances(Parent: MaterialInterface,ChildInstances?: AssetData[]): {ChildInstances: AssetData[]};
	static DuplicateMaterialExpression(Material: Material,MaterialFunction: MaterialFunction,Expression: MaterialExpression): MaterialExpression;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static C(Other: UObject | any): MaterialEditingLibrary;
}

declare class MaterialEditorMenuContext extends UObject { 
	static Load(ResourceName: string): MaterialEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorMenuContext;
	static GetDefaultObject(): MaterialEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorMenuContext;
	static C(Other: UObject | any): MaterialEditorMenuContext;
}

declare type EBackgroundType = 'SolidColor' | 'Checkered' | 'EBackgroundType_MAX';
declare var EBackgroundType : { SolidColor:'SolidColor',Checkered:'Checkered',EBackgroundType_MAX:'EBackgroundType_MAX', };
declare class CheckerboardSettings { 
	ColorOne: Color;
	ColorTwo: Color;
	Size: number;
	clone() : CheckerboardSettings;
	static C(Other: UObject | any): CheckerboardSettings;
}

declare class PreviewBackgroundSettings { 
	bShowBorder: boolean;
	BorderColor: Color;
	BackgroundType: EBackgroundType;
	BackgroundColor: Color;
	Checkerboard: CheckerboardSettings;
	clone() : PreviewBackgroundSettings;
	static C(Other: UObject | any): PreviewBackgroundSettings;
}

declare class MaterialEditorSettings extends UObject { 
	MaliOfflineCompilerPath: FilePath;
	DefaultPreviewWidth: number;
	DefaultPreviewHeight: number;
	PreviewBackground: PreviewBackgroundSettings;
	static Load(ResourceName: string): MaterialEditorSettings;
	static Find(Outer: UObject, ResourceName: string): MaterialEditorSettings;
	static GetDefaultObject(): MaterialEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialEditorSettings;
	static C(Other: UObject | any): MaterialEditorSettings;
}

declare class CurveEditorFilterBase extends UObject { 
	static Load(ResourceName: string): CurveEditorFilterBase;
	static Find(Outer: UObject, ResourceName: string): CurveEditorFilterBase;
	static GetDefaultObject(): CurveEditorFilterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorFilterBase;
	static C(Other: UObject | any): CurveEditorFilterBase;
}

declare class CurveEditorBakeFilter extends CurveEditorFilterBase { 
	bUseFrameBake: boolean;
	BakeIntervalInFrames: FrameNumber;
	BakeIntervalInSeconds: number;
	static Load(ResourceName: string): CurveEditorBakeFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorBakeFilter;
	static GetDefaultObject(): CurveEditorBakeFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorBakeFilter;
	static C(Other: UObject | any): CurveEditorBakeFilter;
}

declare class KeyPosition { 
	InputValue: any;
	OutputValue: any;
	clone() : KeyPosition;
	static C(Other: UObject | any): KeyPosition;
}

declare class KeyAttributes { 
	bHasArriveTangent: boolean;
	bHasLeaveTangent: boolean;
	bHasInterpMode: boolean;
	bHasTangentMode: boolean;
	bHasTangentWeightMode: boolean;
	bHasArriveTangentWeight: boolean;
	bHasLeaveTangentWeight: boolean;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	ArriveTangentWeight: number;
	LeaveTangentWeight: number;
	clone() : KeyAttributes;
	static C(Other: UObject | any): KeyAttributes;
}

declare class CurveEditorCopyableCurveKeys extends UObject { 
	KeyPositions: KeyPosition[];
	KeyAttributes: KeyAttributes[];
	ShortDisplayName: string;
	LongDisplayName: string;
	IntentionName: string;
	static Load(ResourceName: string): CurveEditorCopyableCurveKeys;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyableCurveKeys;
	static GetDefaultObject(): CurveEditorCopyableCurveKeys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyableCurveKeys;
	static C(Other: UObject | any): CurveEditorCopyableCurveKeys;
}

declare class CurveEditorCopyBuffer extends UObject { 
	Curves: CurveEditorCopyableCurveKeys[];
	TimeOffset: any;
	bAbsolutePosition: boolean;
	static Load(ResourceName: string): CurveEditorCopyBuffer;
	static Find(Outer: UObject, ResourceName: string): CurveEditorCopyBuffer;
	static GetDefaultObject(): CurveEditorCopyBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorCopyBuffer;
	static C(Other: UObject | any): CurveEditorCopyBuffer;
}

declare class CurveEditorEulerFilter extends CurveEditorFilterBase { 
	static Load(ResourceName: string): CurveEditorEulerFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorEulerFilter;
	static GetDefaultObject(): CurveEditorEulerFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorEulerFilter;
	static C(Other: UObject | any): CurveEditorEulerFilter;
}

declare class CurveEditorKeyProxy extends Interface { 
	static Load(ResourceName: string): CurveEditorKeyProxy;
	static Find(Outer: UObject, ResourceName: string): CurveEditorKeyProxy;
	static GetDefaultObject(): CurveEditorKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorKeyProxy;
	static C(Other: UObject | any): CurveEditorKeyProxy;
}

declare class CurveEditorReduceFilter extends CurveEditorFilterBase { 
	Tolerance: number;
	static Load(ResourceName: string): CurveEditorReduceFilter;
	static Find(Outer: UObject, ResourceName: string): CurveEditorReduceFilter;
	static GetDefaultObject(): CurveEditorReduceFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorReduceFilter;
	static C(Other: UObject | any): CurveEditorReduceFilter;
}

declare type ECurveEditorTangentVisibility = 'AllTangents' | 'SelectedKeys' | 'NoTangents' | 'ECurveEditorTangentVisibility_MAX';
declare var ECurveEditorTangentVisibility : { AllTangents:'AllTangents',SelectedKeys:'SelectedKeys',NoTangents:'NoTangents',ECurveEditorTangentVisibility_MAX:'ECurveEditorTangentVisibility_MAX', };
declare type ECurveEditorZoomPosition = 'CurrentTime' | 'MousePosition' | 'ECurveEditorZoomPosition_MAX';
declare var ECurveEditorZoomPosition : { CurrentTime:'CurrentTime',MousePosition:'MousePosition',ECurveEditorZoomPosition_MAX:'ECurveEditorZoomPosition_MAX', };
declare class CustomColorForChannel { 
	UObject: Class;
	PropertyName: string;
	Color: LinearColor;
	clone() : CustomColorForChannel;
	static C(Other: UObject | any): CustomColorForChannel;
}

declare class CustomColorForSpaceSwitch { 
	ControlName: string;
	Color: LinearColor;
	clone() : CustomColorForSpaceSwitch;
	static C(Other: UObject | any): CustomColorForSpaceSwitch;
}

declare class CurveEditorSettings extends UObject { 
	bAutoFrameCurveEditor: boolean;
	FrameInputPadding: number;
	FrameOutputPadding: number;
	bShowCurveEditorCurveToolTips: boolean;
	TangentVisibility: ECurveEditorTangentVisibility;
	ZoomPosition: ECurveEditorZoomPosition;
	CustomColors: CustomColorForChannel[];
	ParentSpaceCustomColor: LinearColor;
	WorldSpaceCustomColor: LinearColor;
	ControlSpaceCustomColors: CustomColorForSpaceSwitch[];
	static Load(ResourceName: string): CurveEditorSettings;
	static Find(Outer: UObject, ResourceName: string): CurveEditorSettings;
	static GetDefaultObject(): CurveEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEditorSettings;
	static C(Other: UObject | any): CurveEditorSettings;
}

declare class RichCurveKeyProxy extends UObject { 
	Value: RichCurveKey;
	static Load(ResourceName: string): RichCurveKeyProxy;
	static Find(Outer: UObject, ResourceName: string): RichCurveKeyProxy;
	static GetDefaultObject(): RichCurveKeyProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichCurveKeyProxy;
	static C(Other: UObject | any): RichCurveKeyProxy;
}

declare class CameraRig_Crane extends Actor { 
	CranePitch: number;
	CraneYaw: number;
	CraneArmLength: number;
	bLockMountPitch: boolean;
	bLockMountYaw: boolean;
	TransformComponent: SceneComponent;
	CraneYawControl: SceneComponent;
	CranePitchControl: SceneComponent;
	CraneCameraMount: SceneComponent;
	PreviewMesh_CraneArm: StaticMeshComponent;
	PreviewMesh_CraneBase: StaticMeshComponent;
	PreviewMesh_CraneMount: StaticMeshComponent;
	PreviewMesh_CraneCounterWeight: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Crane;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Crane;
	static C(Other: UObject | any): CameraRig_Crane;
}

declare class CameraRig_Rail extends Actor { 
	CurrentPositionOnRail: number;
	bLockOrientationToRail: boolean;
	bShowRailVisualization: boolean;
	PreviewMeshScale: number;
	TransformComponent: SceneComponent;
	RailSplineComponent: SplineComponent;
	RailCameraMount: SceneComponent;
	PreviewMesh_Rail: SplineMeshComponent;
	PreviewRailMeshSegments: SplineMeshComponent[];
	PreviewRailStaticMesh: StaticMesh;
	PreviewMesh_Mount: StaticMeshComponent;
	static GetDefaultObject(): CameraRig_Rail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraRig_Rail;
	GetRailSplineComponent(): SplineComponent;
	static C(Other: UObject | any): CameraRig_Rail;
}

declare class CameraLookatTrackingSettings { 
	bEnableLookAtTracking: boolean;
	bDrawDebugLookAtTrackingPosition: boolean;
	LookAtTrackingInterpSpeed: number;
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bAllowRoll: boolean;
	clone() : CameraLookatTrackingSettings;
	static C(Other: UObject | any): CameraLookatTrackingSettings;
}

declare class NamedFilmbackPreset { 
	Name: string;
	FilmbackSettings: CameraFilmbackSettings;
	clone() : NamedFilmbackPreset;
	static C(Other: UObject | any): NamedFilmbackPreset;
}

declare class NamedLensPreset { 
	Name: string;
	LensSettings: CameraLensSettings;
	clone() : NamedLensPreset;
	static C(Other: UObject | any): NamedLensPreset;
}

declare class CineCameraComponent extends CameraComponent { 
	FilmbackSettings: CameraFilmbackSettings;
	Filmback: CameraFilmbackSettings;
	LensSettings: CameraLensSettings;
	FocusSettings: CameraFocusSettings;
	CurrentFocalLength: number;
	CurrentAperture: number;
	CurrentFocusDistance: number;
	CurrentHorizontalFOV: number;
	FocusPlaneVisualizationMesh: StaticMesh;
	FocusPlaneVisualizationMaterial: Material;
	DebugFocusPlaneComponent: StaticMeshComponent;
	DebugFocusPlaneMID: MaterialInstanceDynamic;
	FilmbackPresets: NamedFilmbackPreset[];
	LensPresets: NamedLensPreset[];
	DefaultFilmbackPresetName: string;
	DefaultFilmbackPreset: string;
	DefaultLensPresetName: string;
	DefaultLensFocalLength: number;
	DefaultLensFStop: number;
	static Load(ResourceName: string): CineCameraComponent;
	static Find(Outer: UObject, ResourceName: string): CineCameraComponent;
	static GetDefaultObject(): CineCameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraComponent;
	SetLensPresetByName(InPresetName: string): void;
	SetFilmbackPresetByName(InPresetName: string): void;
	SetCurrentFocalLength(InFocalLength: number): void;
	GetVerticalFieldOfView(): number;
	static GetLensPresetsCopy(): NamedLensPreset[];
	GetLensPresetName(): string;
	GetHorizontalFieldOfView(): number;
	static GetFilmbackPresetsCopy(): NamedFilmbackPreset[];
	GetFilmbackPresetName(): string;
	GetDefaultFilmbackPresetName(): string;
	static C(Other: UObject | any): CineCameraComponent;
}

declare class CineCameraActor extends CameraActor { 
	LookatTrackingSettings: CameraLookatTrackingSettings;
	static GetDefaultObject(): CineCameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CineCameraActor;
	GetCineCameraComponent(): CineCameraComponent;
	static C(Other: UObject | any): CineCameraActor;
}

declare class DataLayerEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): DataLayerEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): DataLayerEditorSubsystem;
	static GetDefaultObject(): DataLayerEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayerEditorSubsystem;
	UpdateAllViewVisibility(DataLayerThatChanged: DataLayer): void;
	UpdateAllActorsVisibility(bNotifySelectionChange: boolean,bRedrawViewports: boolean): boolean;
	UpdateActorVisibility(Actor: Actor,bOutSelectionChanged?: boolean,bOutActorModified?: boolean,bNotifySelectionChange?: boolean,bRedrawViewports?: boolean): {bOutSelectionChanged: boolean, bOutActorModified: boolean, $: boolean};
	UpdateActorAllViewsVisibility(Actor: Actor): void;
	ToggleDataLayerVisibility(DataLayer: DataLayer): void;
	ToggleDataLayersVisibility(DataLayers: DataLayer[]): void;
	ToggleDataLayersIsLoadedInEditor(DataLayers: DataLayer[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsLoadedInEditor(DataLayer: DataLayer,bIsFromUserChange: boolean): boolean;
	ToggleDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsFromUserChange: boolean): boolean;
	SetParentDataLayer(DataLayer: DataLayer,ParentDataLayer: DataLayer): boolean;
	SetDataLayerVisibility(DataLayer: DataLayer,bIsVisible: boolean): void;
	SetDataLayersVisibility(DataLayers: DataLayer[],bIsVisible: boolean): void;
	SetDataLayersIsLoadedInEditor(DataLayers: DataLayer[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayersIsDynamicallyLoadedInEditor(DataLayers: DataLayer[],bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsLoadedInEditor(DataLayer: DataLayer,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SetDataLayerIsDynamicallyLoadedInEditor(DataLayer: DataLayer,bIsLoadedInEditor: boolean,bIsFromUserChange: boolean): boolean;
	SelectActorsInDataLayers(DataLayers: DataLayer[],bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	SelectActorsInDataLayer(DataLayer: DataLayer,bSelect: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): boolean;
	RenameDataLayer(DataLayer: DataLayer,NewDataLayerLabel: string): boolean;
	RemoveSelectedActorsFromDataLayers(DataLayers: DataLayer[]): boolean;
	RemoveSelectedActorsFromDataLayer(DataLayer: DataLayer): boolean;
	RemoveActorsFromDataLayers(Actors: Actor[],DataLayers: DataLayer[]): boolean;
	RemoveActorsFromDataLayer(Actors: Actor[],DataLayer: DataLayer): boolean;
	RemoveActorsFromAllDataLayers(Actors: Actor[]): boolean;
	RemoveActorFromDataLayers(Actor: Actor,DataLayers: DataLayer[]): boolean;
	RemoveActorFromDataLayer(Actor: Actor,DataLayerToRemove: DataLayer): boolean;
	RemoveActorFromAllDataLayers(Actor: Actor): boolean;
	MakeAllDataLayersVisible(): void;
	IsActorValidForDataLayer(Actor: Actor): boolean;
	GetDataLayerFromLabel(DataLayerLabel: string): DataLayer;
	GetDataLayer(ActorDataLayer: ActorDataLayer): DataLayer;
	GetActorsFromDataLayers(DataLayers: DataLayer[]): Actor[];
	GetActorsFromDataLayer(DataLayer: DataLayer): Actor[];
	DeleteDataLayers(DataLayersToDelete: DataLayer[]): void;
	DeleteDataLayer(DataLayerToDelete: DataLayer): void;
	CreateDataLayer(): DataLayer;
	AppendActorsFromDataLayers(DataLayers: DataLayer[],InOutActors?: Actor[]): {InOutActors: Actor[]};
	AppendActorsFromDataLayer(DataLayer: DataLayer,InOutActors?: Actor[]): {InOutActors: Actor[]};
	AddSelectedActorsToDataLayers(DataLayers: DataLayer[]): boolean;
	AddSelectedActorsToDataLayer(DataLayer: DataLayer): boolean;
	AddActorToDataLayers(Actor: Actor,DataLayers: DataLayer[]): boolean;
	AddActorToDataLayer(Actor: Actor,DataLayer: DataLayer): boolean;
	AddActorsToDataLayers(Actors: Actor[],DataLayers: DataLayer[]): boolean;
	AddActorsToDataLayer(Actors: Actor[],DataLayer: DataLayer): boolean;
	static C(Other: UObject | any): DataLayerEditorSubsystem;
}

declare type EHardwareClass = 'Unspecified' | 'Desktop' | 'Mobile' | 'EHardwareClass_MAX';
declare var EHardwareClass : { Unspecified:'Unspecified',Desktop:'Desktop',Mobile:'Mobile',EHardwareClass_MAX:'EHardwareClass_MAX', };
declare type EGraphicsPreset = 'Unspecified' | 'Maximum' | 'Scalable' | 'EGraphicsPreset_MAX';
declare var EGraphicsPreset : { Unspecified:'Unspecified',Maximum:'Maximum',Scalable:'Scalable',EGraphicsPreset_MAX:'EGraphicsPreset_MAX', };
declare class HardwareTargetingSettings extends UObject { 
	TargetedHardwareClass: EHardwareClass;
	AppliedTargetedHardwareClass: EHardwareClass;
	DefaultGraphicsPerformance: EGraphicsPreset;
	AppliedDefaultGraphicsPerformance: EGraphicsPreset;
	static Load(ResourceName: string): HardwareTargetingSettings;
	static Find(Outer: UObject, ResourceName: string): HardwareTargetingSettings;
	static GetDefaultObject(): HardwareTargetingSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HardwareTargetingSettings;
	static C(Other: UObject | any): HardwareTargetingSettings;
}

declare class ClassTemplate extends UObject { 
	GeneratedBaseClass: UnrealEngineClass;
	static Load(ResourceName: string): ClassTemplate;
	static Find(Outer: UObject, ResourceName: string): ClassTemplate;
	static GetDefaultObject(): ClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplate;
	static C(Other: UObject | any): ClassTemplate;
}

declare class PluginClassTemplate extends ClassTemplate { 
	PluginName: string;
	static Load(ResourceName: string): PluginClassTemplate;
	static Find(Outer: UObject, ResourceName: string): PluginClassTemplate;
	static GetDefaultObject(): PluginClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginClassTemplate;
	static C(Other: UObject | any): PluginClassTemplate;
}

declare class ClassTemplateEditorSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): ClassTemplateEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): ClassTemplateEditorSubsystem;
	static GetDefaultObject(): ClassTemplateEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassTemplateEditorSubsystem;
	static C(Other: UObject | any): ClassTemplateEditorSubsystem;
}

declare class LocalizedTemplateString { 
	Language: string;
	text: string;
	clone() : LocalizedTemplateString;
	static C(Other: UObject | any): LocalizedTemplateString;
}

declare class TemplateFolderRename { 
	From: string;
	To: string;
	clone() : TemplateFolderRename;
	static C(Other: UObject | any): TemplateFolderRename;
}

declare class TemplateReplacement { 
	Extensions: string[];
	From: string;
	To: string;
	bCaseSensitive: boolean;
	clone() : TemplateReplacement;
	static C(Other: UObject | any): TemplateReplacement;
}

declare type ETemplateSetting = 'Languages' | 'HardwareTarget' | 'GraphicsPreset' | 'StarterContent' | 'XR' | 'Raytracing' | 'All' | 'ETemplateSetting_MAX';
declare var ETemplateSetting : { Languages:'Languages',HardwareTarget:'HardwareTarget',GraphicsPreset:'GraphicsPreset',StarterContent:'StarterContent',XR:'XR',Raytracing:'Raytracing',All:'All',ETemplateSetting_MAX:'ETemplateSetting_MAX', };
declare type EFeaturePackDetailLevel = 'Standard' | 'High' | 'EFeaturePackDetailLevel_MAX';
declare var EFeaturePackDetailLevel : { Standard:'Standard',High:'High',EFeaturePackDetailLevel_MAX:'EFeaturePackDetailLevel_MAX', };
declare class FeaturePackLevelSet { 
	DetailLevels: EFeaturePackDetailLevel[];
	MountName: string;
	clone() : FeaturePackLevelSet;
	static C(Other: UObject | any): FeaturePackLevelSet;
}

declare class TemplateProjectDefs extends UObject { 
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	FoldersToIgnore: string[];
	FilesToIgnore: string[];
	FolderRenames: TemplateFolderRename[];
	FilenameReplacements: TemplateReplacement[];
	ReplacementsInFiles: TemplateReplacement[];
	SortKey: string;
	Categories: string[];
	ClassTypes: string;
	AssetTypes: string;
	bAllowProjectCreation: boolean;
	bIsEnterprise: boolean;
	bIsBlank: boolean;
	bThumbnailAsIcon: boolean;
	HiddenSettings: ETemplateSetting[];
	PacksToInclude: string[];
	EditDetailLevelPreference: EFeaturePackDetailLevel;
	SharedContentPacks: FeaturePackLevelSet[];
	StarterContent: string;
	static Load(ResourceName: string): TemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): TemplateProjectDefs;
	static GetDefaultObject(): TemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateProjectDefs;
	static C(Other: UObject | any): TemplateProjectDefs;
}

declare class DefaultTemplateProjectDefs extends TemplateProjectDefs { 
	static Load(ResourceName: string): DefaultTemplateProjectDefs;
	static Find(Outer: UObject, ResourceName: string): DefaultTemplateProjectDefs;
	static GetDefaultObject(): DefaultTemplateProjectDefs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultTemplateProjectDefs;
	static C(Other: UObject | any): DefaultTemplateProjectDefs;
}

declare class TemplateCategoryDef { 
	Key: string;
	LocalizedDisplayNames: LocalizedTemplateString[];
	LocalizedDescriptions: LocalizedTemplateString[];
	Icon: string;
	IsMajorCategory: boolean;
	clone() : TemplateCategoryDef;
	static C(Other: UObject | any): TemplateCategoryDef;
}

declare class TemplateCategories extends UObject { 
	Categories: TemplateCategoryDef[];
	static Load(ResourceName: string): TemplateCategories;
	static Find(Outer: UObject, ResourceName: string): TemplateCategories;
	static GetDefaultObject(): TemplateCategories;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateCategories;
	static C(Other: UObject | any): TemplateCategories;
}

declare class SubobjectDataHandle { 
	clone() : SubobjectDataHandle;
	static C(Other: UObject | any): SubobjectDataHandle;
	GetData(OutData?: SubobjectData): {OutData: SubobjectData};
	IsHandleValid(): boolean;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
}

declare class SubobjectData { 
	WeakObjectPtr: any;
	Handle: SubobjectDataHandle;
	ParentObjectHandle: SubobjectDataHandle;
	ChildrenHandles: SubobjectDataHandle[];
	clone() : SubobjectData;
	static C(Other: UObject | any): SubobjectData;
	CanCopy(): boolean;
	CanDelete(): boolean;
	CanDuplicate(): boolean;
	CanEdit(): boolean;
	CanRename(): boolean;
	CanReparent(): boolean;
	GetHandle(OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetObject(bEvenIfPendingKill: boolean): UObject;
	GetVariableName(): string;
	IsActor(): boolean;
	IsAttachedTo(InHandle: SubobjectDataHandle): boolean;
	IsChildActor(): boolean;
	IsComponent(): boolean;
	IsDefaultSceneRoot(): boolean;
	IsInheritedComponent(): boolean;
	IsInstancedActor(): boolean;
	IsInstancedComponent(): boolean;
	IsNativeComponent(): boolean;
	IsRootActor(): boolean;
	IsRootComponent(): boolean;
	IsSceneComponent(): boolean;
	IsValid(): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanReparent(Data: SubobjectData): boolean;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetVariableName(Data: SubobjectData): string;
	static IsActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsValid(Data: SubobjectData): boolean;
}

declare class SubobjectDataBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataBlueprintFunctionLibrary;
	static GetDefaultObject(): SubobjectDataBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataBlueprintFunctionLibrary;
	static IsValid(Data: SubobjectData): boolean;
	static IsSceneComponent(Data: SubobjectData): boolean;
	static IsRootComponent(Data: SubobjectData): boolean;
	static IsRootActor(Data: SubobjectData): boolean;
	static IsNativeComponent(Data: SubobjectData): boolean;
	static IsInstancedComponent(Data: SubobjectData): boolean;
	static IsInstancedActor(Data: SubobjectData): boolean;
	static IsInheritedComponent(Data: SubobjectData): boolean;
	static IsHandleValid(DataHandle: SubobjectDataHandle): boolean;
	static IsDefaultSceneRoot(Data: SubobjectData): boolean;
	static IsComponent(Data: SubobjectData): boolean;
	static IsChildActor(Data: SubobjectData): boolean;
	static IsAttachedTo(Data: SubobjectData,InHandle: SubobjectDataHandle): boolean;
	static IsActor(Data: SubobjectData): boolean;
	static GetVariableName(Data: SubobjectData): string;
	static GetObject(Data: SubobjectData,bEvenIfPendingKill: boolean): UObject;
	static GetHandle(Data: SubobjectData,OutHandle?: SubobjectDataHandle): {OutHandle: SubobjectDataHandle};
	GetDisplayName(Data: SubobjectData): string;
	static GetData(DataHandle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData};
	GetBlueprint(Data: SubobjectData): Blueprint;
	static CanReparent(Data: SubobjectData): boolean;
	static CanRename(Data: SubobjectData): boolean;
	static CanEdit(Data: SubobjectData): boolean;
	static CanDuplicate(Data: SubobjectData): boolean;
	static CanDelete(Data: SubobjectData): boolean;
	static CanCopy(Data: SubobjectData): boolean;
	static C(Other: UObject | any): SubobjectDataBlueprintFunctionLibrary;
}

declare class ReparentSubobjectParams { 
	NewParentHandle: SubobjectDataHandle;
	BlueprintContext: Blueprint;
	ActorPreviewContext: Actor;
	clone() : ReparentSubobjectParams;
	static C(Other: UObject | any): ReparentSubobjectParams;
}

declare class AddNewSubobjectParams { 
	ParentHandle: SubobjectDataHandle;
	NewClass: UnrealEngineClass;
	BlueprintContext: Blueprint;
	bSkipMarkBlueprintModified: boolean;
	bConformTransformToParent: boolean;
	clone() : AddNewSubobjectParams;
	static C(Other: UObject | any): AddNewSubobjectParams;
}

declare class SubobjectDataSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): SubobjectDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): SubobjectDataSubsystem;
	static GetDefaultObject(): SubobjectDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectDataSubsystem;
	ReparentSubobjects(Params: ReparentSubobjectParams,HandlesToMove: SubobjectDataHandle[]): boolean;
	ReparentSubobject(Params: ReparentSubobjectParams,ToReparentHandle: SubobjectDataHandle): boolean;
	static RenameSubobjectMemberVariable(BPContext: Blueprint,InHandle: SubobjectDataHandle,NewName: string): void;
	RenameSubobject(Handle: SubobjectDataHandle,InNewName: string): boolean;
	MakeNewSceneRoot(Context: SubobjectDataHandle,NewSceneRoot: SubobjectDataHandle,BPContext: Blueprint): boolean;
	K2_GatherSubobjectDataForInstance(Context: Actor,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_GatherSubobjectDataForBlueprint(Context: Blueprint,OutArray?: SubobjectDataHandle[]): {OutArray: SubobjectDataHandle[]};
	K2_FindSubobjectDataFromHandle(Handle: SubobjectDataHandle,OutData?: SubobjectData): {OutData: SubobjectData, $: boolean};
	K2_DeleteSubobjectsFromInstance(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[]): number;
	K2_DeleteSubobjectFromInstance(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle): number;
	IsValidRename(Handle: SubobjectDataHandle,InNewText: string,OutErrorMessage?: string): {OutErrorMessage: string, $: boolean};
	FindHandleForObject(Context: SubobjectDataHandle,ObjectToFind: UObject,BPContext: Blueprint): SubobjectDataHandle;
	DetachSubobject(OwnerHandle: SubobjectDataHandle,ChildToRemove: SubobjectDataHandle): boolean;
	DeleteSubobjects(ContextHandle: SubobjectDataHandle,SubobjectsToDelete: SubobjectDataHandle[],BPContext: Blueprint): number;
	DeleteSubobject(ContextHandle: SubobjectDataHandle,SubobjectToDelete: SubobjectDataHandle,BPContext: Blueprint): number;
	static CreateNewCPPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	static CreateNewBPComponent(ComponentClass: UnrealEngineClass,NewClassPath: string,NewClassName: string): UnrealEngineClass;
	CopySubobjects(Handles: SubobjectDataHandle[],BPContext: Blueprint): void;
	ChangeSubobjectClass(Handle: SubobjectDataHandle,NewClass: UnrealEngineClass): boolean;
	CanPasteSubobjects(RootHandle: SubobjectDataHandle,BPContext: Blueprint): boolean;
	CanCopySubobjects(Handles: SubobjectDataHandle[]): boolean;
	AttachSubobject(OwnerHandle: SubobjectDataHandle,ChildToAddHandle: SubobjectDataHandle): boolean;
	AddNewSubobject(Params: AddNewSubobjectParams,FailReason?: string): {FailReason: string, $: SubobjectDataHandle};
	static C(Other: UObject | any): SubobjectDataSubsystem;
}

declare class SubobjectEditorMenuContext extends UObject { 
	static Load(ResourceName: string): SubobjectEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): SubobjectEditorMenuContext;
	static GetDefaultObject(): SubobjectEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectEditorMenuContext;
	GetSelectedObjects(): UObject[];
	static C(Other: UObject | any): SubobjectEditorMenuContext;
}

declare class Texture2DDynamic extends Texture { 
	Format: EPixelFormat;
	static Load(ResourceName: string): Texture2DDynamic;
	static Find(Outer: UObject, ResourceName: string): Texture2DDynamic;
	static GetDefaultObject(): Texture2DDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DDynamic;
	static C(Other: UObject | any): Texture2DDynamic;
}

declare class AsyncTaskDownloadImage extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	OnFail: UnrealEngineMulticastDelegate<(Texture: Texture2DDynamic) => void>;
	static Load(ResourceName: string): AsyncTaskDownloadImage;
	static Find(Outer: UObject, ResourceName: string): AsyncTaskDownloadImage;
	static GetDefaultObject(): AsyncTaskDownloadImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncTaskDownloadImage;
	static DownloadImage(URL: string): AsyncTaskDownloadImage;
	static C(Other: UObject | any): AsyncTaskDownloadImage;
}

declare class ContentWidget extends PanelWidget { 
	static Load(ResourceName: string): ContentWidget;
	static Find(Outer: UObject, ResourceName: string): ContentWidget;
	static GetDefaultObject(): ContentWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentWidget;
	SetContent(Content: Widget): PanelSlot;
	GetContentSlot(): PanelSlot;
	GetContent(): Widget;
	static C(Other: UObject | any): ContentWidget;
}

declare class BackgroundBlur extends ContentWidget { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bApplyAlphaToBlur: boolean;
	BlurStrength: number;
	bOverrideAutoRadiusCalculation: boolean;
	BlurRadius: number;
	CornerRadius: Vector4;
	LowQualityFallbackBrush: SlateBrush;
	static Load(ResourceName: string): BackgroundBlur;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlur;
	static GetDefaultObject(): BackgroundBlur;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlur;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetLowQualityFallbackBrush(InBrush: SlateBrush): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetCornerRadius(InCornerRadius: Vector4): void;
	SetBlurStrength(InStrength: number): void;
	SetBlurRadius(InBlurRadius: number): void;
	SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean): void;
	static C(Other: UObject | any): BackgroundBlur;
}

declare class BackgroundBlurSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): BackgroundBlurSlot;
	static Find(Outer: UObject, ResourceName: string): BackgroundBlurSlot;
	static GetDefaultObject(): BackgroundBlurSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BackgroundBlurSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): BackgroundBlurSlot;
}

declare class BoolBinding extends PropertyBinding { 
	static Load(ResourceName: string): BoolBinding;
	static Find(Outer: UObject, ResourceName: string): BoolBinding;
	static GetDefaultObject(): BoolBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoolBinding;
	GetValue(): boolean;
	static C(Other: UObject | any): BoolBinding;
}

declare class Border extends ContentWidget { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bShowEffectWhenDisabled: boolean;
	ContentColorAndOpacity: LinearColor;
	ContentColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	Padding: Margin;
	Background: SlateBrush;
	BackgroundDelegate: UnrealEngineDelegate<() => SlateBrush>;
	BrushColor: LinearColor;
	BrushColorDelegate: UnrealEngineDelegate<() => LinearColor>;
	DesiredSizeScale: Vector2D;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseButtonUpEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseMoveEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	OnMouseDoubleClickEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	Brush: SlateBrushAsset;
	static Load(ResourceName: string): Border;
	static Find(Outer: UObject, ResourceName: string): Border;
	static GetDefaultObject(): Border;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Border;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetDesiredSizeScale(InScale: Vector2D): void;
	SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;
	SetBrushFromTexture(Texture: Texture2D): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrushColor(InBrushColor: LinearColor): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): Border;
}

declare class BrushBinding extends PropertyBinding { 
	static Load(ResourceName: string): BrushBinding;
	static Find(Outer: UObject, ResourceName: string): BrushBinding;
	static GetDefaultObject(): BrushBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBinding;
	GetValue(): SlateBrush;
	static C(Other: UObject | any): BrushBinding;
}

declare type EButtonClickMethod = 'DownAndUp' | 'MouseDown' | 'MouseUp' | 'PreciseClick' | 'EButtonClickMethod_MAX';
declare var EButtonClickMethod : { DownAndUp:'DownAndUp',MouseDown:'MouseDown',MouseUp:'MouseUp',PreciseClick:'PreciseClick',EButtonClickMethod_MAX:'EButtonClickMethod_MAX', };
declare type EButtonTouchMethod = 'DownAndUp' | 'Down' | 'PreciseTap' | 'EButtonTouchMethod_MAX';
declare var EButtonTouchMethod : { DownAndUp:'DownAndUp',Down:'Down',PreciseTap:'PreciseTap',EButtonTouchMethod_MAX:'EButtonTouchMethod_MAX', };
declare type EButtonPressMethod = 'DownAndUp' | 'ButtonPress' | 'ButtonRelease' | 'EButtonPressMethod_MAX';
declare var EButtonPressMethod : { DownAndUp:'DownAndUp',ButtonPress:'ButtonPress',ButtonRelease:'ButtonRelease',EButtonPressMethod_MAX:'EButtonPressMethod_MAX', };
declare class Button extends ContentWidget { 
	Style: SlateWidgetStyleAsset;
	WidgetStyle: ButtonStyle;
	ColorAndOpacity: LinearColor;
	BackgroundColor: LinearColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnClicked: UnrealEngineMulticastDelegate<() => void>;
	OnPressed: UnrealEngineMulticastDelegate<() => void>;
	OnReleased: UnrealEngineMulticastDelegate<() => void>;
	OnHovered: UnrealEngineMulticastDelegate<() => void>;
	OnUnhovered: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): Button;
	static Find(Outer: UObject, ResourceName: string): Button;
	static GetDefaultObject(): Button;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Button;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetStyle(InStyle: ButtonStyle): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetBackgroundColor(InBackgroundColor: LinearColor): void;
	IsPressed(): boolean;
	static C(Other: UObject | any): Button;
}

declare class ButtonSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): ButtonSlot;
	static Find(Outer: UObject, ResourceName: string): ButtonSlot;
	static GetDefaultObject(): ButtonSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): ButtonSlot;
}

declare class CanvasPanel extends PanelWidget { 
	static Load(ResourceName: string): CanvasPanel;
	static Find(Outer: UObject, ResourceName: string): CanvasPanel;
	static GetDefaultObject(): CanvasPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanel;
	AddChildToCanvas(Content: Widget): CanvasPanelSlot;
	static C(Other: UObject | any): CanvasPanel;
}

declare class CheckBox extends ContentWidget { 
	CheckedState: ECheckBoxState;
	CheckedStateDelegate: UnrealEngineDelegate<() => ECheckBoxState>;
	WidgetStyle: CheckBoxStyle;
	Style: SlateWidgetStyleAsset;
	UncheckedImage: SlateBrushAsset;
	UncheckedHoveredImage: SlateBrushAsset;
	UncheckedPressedImage: SlateBrushAsset;
	CheckedImage: SlateBrushAsset;
	CheckedHoveredImage: SlateBrushAsset;
	CheckedPressedImage: SlateBrushAsset;
	UndeterminedImage: SlateBrushAsset;
	UndeterminedHoveredImage: SlateBrushAsset;
	UndeterminedPressedImage: SlateBrushAsset;
	HorizontalAlignment: EHorizontalAlignment;
	Padding: Margin;
	BorderBackgroundColor: SlateColor;
	ClickMethod: EButtonClickMethod;
	TouchMethod: EButtonTouchMethod;
	PressMethod: EButtonPressMethod;
	IsFocusable: boolean;
	OnCheckStateChanged: UnrealEngineMulticastDelegate<(bIsChecked: boolean) => void>;
	static Load(ResourceName: string): CheckBox;
	static Find(Outer: UObject, ResourceName: string): CheckBox;
	static GetDefaultObject(): CheckBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBox;
	SetTouchMethod(InTouchMethod: EButtonTouchMethod): void;
	SetPressMethod(InPressMethod: EButtonPressMethod): void;
	SetIsChecked(InIsChecked: boolean): void;
	SetClickMethod(InClickMethod: EButtonClickMethod): void;
	SetCheckedState(InCheckedState: ECheckBoxState): void;
	IsPressed(): boolean;
	IsChecked(): boolean;
	GetCheckedState(): ECheckBoxState;
	static C(Other: UObject | any): CheckBox;
}

declare class CheckedStateBinding extends PropertyBinding { 
	static Load(ResourceName: string): CheckedStateBinding;
	static Find(Outer: UObject, ResourceName: string): CheckedStateBinding;
	static GetDefaultObject(): CheckedStateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckedStateBinding;
	GetValue(): ECheckBoxState;
	static C(Other: UObject | any): CheckedStateBinding;
}

declare class CircularThrobber extends Widget { 
	NumberOfPieces: number;
	Period: number;
	Radius: number;
	PieceImage: SlateBrushAsset;
	UImage: SlateBrush;
	bEnableRadius: boolean;
	static Load(ResourceName: string): CircularThrobber;
	static Find(Outer: UObject, ResourceName: string): CircularThrobber;
	static GetDefaultObject(): CircularThrobber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CircularThrobber;
	SetRadius(InRadius: number): void;
	SetPeriod(InPeriod: number): void;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	static C(Other: UObject | any): CircularThrobber;
}

declare class ColorBinding extends PropertyBinding { 
	static Load(ResourceName: string): ColorBinding;
	static Find(Outer: UObject, ResourceName: string): ColorBinding;
	static GetDefaultObject(): ColorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ColorBinding;
	GetSlateValue(): SlateColor;
	GetLinearValue(): LinearColor;
	static C(Other: UObject | any): ColorBinding;
}

declare class ComboBox extends Widget { 
	Items: UObject[];
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: UObject) => Widget>;
	bIsFocusable: boolean;
	static Load(ResourceName: string): ComboBox;
	static Find(Outer: UObject, ResourceName: string): ComboBox;
	static GetDefaultObject(): ComboBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBox;
	static C(Other: UObject | any): ComboBox;
}

declare class TableRowStyle extends SlateWidgetStyle { 
	SelectorFocusedBrush: SlateBrush;
	ActiveHoveredBrush: SlateBrush;
	ActiveBrush: SlateBrush;
	InactiveHoveredBrush: SlateBrush;
	InactiveBrush: SlateBrush;
	bUseParentRowBrush: boolean;
	ParentRowBackgroundBrush: SlateBrush;
	ParentRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundHoveredBrush: SlateBrush;
	EvenRowBackgroundBrush: SlateBrush;
	OddRowBackgroundHoveredBrush: SlateBrush;
	OddRowBackgroundBrush: SlateBrush;
	TextColor: SlateColor;
	SelectedTextColor: SlateColor;
	DropIndicator_Above: SlateBrush;
	DropIndicator_Onto: SlateBrush;
	DropIndicator_Below: SlateBrush;
	ActiveHighlightedBrush: SlateBrush;
	InactiveHighlightedBrush: SlateBrush;
	clone() : TableRowStyle;
	static C(Other: UObject | any): TableRowStyle;
}

declare type ESelectInfo = 'OnKeyPress' | 'OnNavigation' | 'OnMouseClick' | 'Direct' | 'ESelectInfo_MAX';
declare var ESelectInfo : { OnKeyPress:'OnKeyPress',OnNavigation:'OnNavigation',OnMouseClick:'OnMouseClick',Direct:'Direct',ESelectInfo_MAX:'ESelectInfo_MAX', };
declare class ComboBoxKey extends Widget { 
	Options: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ForegroundColor: SlateColor;
	ContentPadding: Margin;
	MaxListHeight: number;
	bHasDownArrow: boolean;
	bEnableGamepadNavigationMode: boolean;
	bIsFocusable: boolean;
	OnGenerateContentWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnGenerateItemWidget: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxKey;
	static Find(Outer: UObject, ResourceName: string): ComboBoxKey;
	static GetDefaultObject(): ComboBoxKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxKey;
	SetSelectedOption(Option: string): void;
	RemoveOption(Option: string): boolean;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxKey;
}

declare class ComboBoxString extends Widget { 
	DefaultOptions: string[];
	SelectedOption: string;
	WidgetStyle: ComboBoxStyle;
	ItemStyle: TableRowStyle;
	ContentPadding: Margin;
	MaxListHeight: number;
	HasDownArrow: boolean;
	EnableGamepadNavigationMode: boolean;
	Font: SlateFontInfo;
	ForegroundColor: SlateColor;
	bIsFocusable: boolean;
	OnGenerateWidgetEvent: UnrealEngineDelegate<(Item: string) => Widget>;
	OnSelectionChanged: UnrealEngineMulticastDelegate<(SelectedItem: string, SelectionType: ESelectInfo) => void>;
	OnOpening: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): ComboBoxString;
	static Find(Outer: UObject, ResourceName: string): ComboBoxString;
	static GetDefaultObject(): ComboBoxString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComboBoxString;
	SetSelectedOption(Option: string): void;
	SetSelectedIndex(index: number): void;
	RemoveOption(Option: string): boolean;
	RefreshOptions(): void;
	IsOpen(): boolean;
	GetSelectedOption(): string;
	GetSelectedIndex(): number;
	GetOptionCount(): number;
	GetOptionAtIndex(index: number): string;
	FindOptionIndex(Option: string): number;
	ClearSelection(): void;
	ClearOptions(): void;
	AddOption(Option: string): void;
	static C(Other: UObject | any): ComboBoxString;
}

declare type EDynamicBoxType = 'Horizontal' | 'Vertical' | 'Wrap' | 'VerticalWrap' | 'Radial' | 'Overlay' | 'EDynamicBoxType_MAX';
declare var EDynamicBoxType : { Horizontal:'Horizontal',Vertical:'Vertical',Wrap:'Wrap',VerticalWrap:'VerticalWrap',Radial:'Radial',Overlay:'Overlay',EDynamicBoxType_MAX:'EDynamicBoxType_MAX', };
declare class RadialBoxSettings { 
	StartingAngle: number;
	bDistributeItemsEvenly: boolean;
	AngleBetweenItems: number;
	SectorCentralAngle: number;
	clone() : RadialBoxSettings;
	static C(Other: UObject | any): RadialBoxSettings;
}

declare class UserWidgetPool { 
	ActiveWidgets: UserWidget[];
	InactiveWidgets: UserWidget[];
	clone() : UserWidgetPool;
	static C(Other: UObject | any): UserWidgetPool;
}

declare class DynamicEntryBoxBase extends Widget { 
	EntryBoxType: EDynamicBoxType;
	EntrySpacing: Vector2D;
	SpacingPattern: Vector2D[];
	EntrySizeRule: SlateChildSize;
	EntryHorizontalAlignment: EHorizontalAlignment;
	EntryVerticalAlignment: EVerticalAlignment;
	MaxElementSize: number;
	RadialBoxSettings: RadialBoxSettings;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): DynamicEntryBoxBase;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBoxBase;
	static GetDefaultObject(): DynamicEntryBoxBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBoxBase;
	SetRadialSettings(InSettings: RadialBoxSettings): void;
	SetEntrySpacing(InEntrySpacing: Vector2D): void;
	GetNumEntries(): number;
	GetAllEntries(): UserWidget[];
	static C(Other: UObject | any): DynamicEntryBoxBase;
}

declare class DynamicEntryBox extends DynamicEntryBoxBase { 
	NumDesignerPreviewEntries: number;
	EntryWidgetClass: UnrealEngineClass;
	static Load(ResourceName: string): DynamicEntryBox;
	static Find(Outer: UObject, ResourceName: string): DynamicEntryBox;
	static GetDefaultObject(): DynamicEntryBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicEntryBox;
	Reset(bDeleteWidgets: boolean): void;
	RemoveEntry(EntryWidget: UserWidget): void;
	BP_CreateEntryOfClass(EntryClass: UnrealEngineClass): UserWidget;
	BP_CreateEntry(): UserWidget;
	static C(Other: UObject | any): DynamicEntryBox;
}

declare type EVirtualKeyboardType = 'Default' | 'Number' | 'Web' | 'Email' | 'Password' | 'AlphaNumeric' | 'EVirtualKeyboardType_MAX';
declare var EVirtualKeyboardType : { Default:'Default',Number:'Number',Web:'Web',Email:'Email',Password:'Password',AlphaNumeric:'AlphaNumeric',EVirtualKeyboardType_MAX:'EVirtualKeyboardType_MAX', };
declare class VirtualKeyboardOptions { 
	bEnableAutocorrect: boolean;
	clone() : VirtualKeyboardOptions;
	static C(Other: UObject | any): VirtualKeyboardOptions;
}

declare type EVirtualKeyboardTrigger = 'OnFocusByPointer' | 'OnAllFocusEvents' | 'EVirtualKeyboardTrigger_MAX';
declare var EVirtualKeyboardTrigger : { OnFocusByPointer:'OnFocusByPointer',OnAllFocusEvents:'OnAllFocusEvents',EVirtualKeyboardTrigger_MAX:'EVirtualKeyboardTrigger_MAX', };
declare type EVirtualKeyboardDismissAction = 'TextChangeOnDismiss' | 'TextCommitOnAccept' | 'TextCommitOnDismiss' | 'EVirtualKeyboardDismissAction_MAX';
declare var EVirtualKeyboardDismissAction : { TextChangeOnDismiss:'TextChangeOnDismiss',TextCommitOnAccept:'TextCommitOnAccept',TextCommitOnDismiss:'TextCommitOnDismiss',EVirtualKeyboardDismissAction_MAX:'EVirtualKeyboardDismissAction_MAX', };
declare type ETextJustify = 'Left' | 'Center' | 'Right' | 'ETextJustify_MAX';
declare var ETextJustify : { Left:'Left',Center:'Center',Right:'Right',ETextJustify_MAX:'ETextJustify_MAX', };
declare type ETextShapingMethod = 'Auto' | 'KerningOnly' | 'FullShaping' | 'ETextShapingMethod_MAX';
declare var ETextShapingMethod : { Auto:'Auto',KerningOnly:'KerningOnly',FullShaping:'FullShaping',ETextShapingMethod_MAX:'ETextShapingMethod_MAX', };
declare type ETextFlowDirection = 'Auto' | 'LeftToRight' | 'RightToLeft' | 'ETextFlowDirection_MAX';
declare var ETextFlowDirection : { Auto:'Auto',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',ETextFlowDirection_MAX:'ETextFlowDirection_MAX', };
declare class ShapedTextOptions { 
	bOverride_TextShapingMethod: boolean;
	bOverride_TextFlowDirection: boolean;
	TextShapingMethod: ETextShapingMethod;
	TextFlowDirection: ETextFlowDirection;
	clone() : ShapedTextOptions;
	static C(Other: UObject | any): ShapedTextOptions;
}

declare type ETextCommit = 'Default' | 'OnEnter' | 'OnUserMovedFocus' | 'OnCleared' | 'ETextCommit_MAX';
declare var ETextCommit : { Default:'Default',OnEnter:'OnEnter',OnUserMovedFocus:'OnUserMovedFocus',OnCleared:'OnCleared',ETextCommit_MAX:'ETextCommit_MAX', };
declare class EditableText extends Widget { 
	text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextStyle;
	Style: SlateWidgetStyleAsset;
	BackgroundImageSelected: SlateBrushAsset;
	BackgroundImageComposing: SlateBrushAsset;
	CaretImage: SlateBrushAsset;
	Font: SlateFontInfo;
	ColorAndOpacity: SlateColor;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): EditableText;
	static Find(Outer: UObject, ResourceName: string): EditableText;
	static GetDefaultObject(): EditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableText;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(InbIsReadyOnly: boolean): void;
	SetIsPassword(InbIsPassword: boolean): void;
	SetHintText(InHintText: string): void;
	GetText(): string;
	static C(Other: UObject | any): EditableText;
}

declare class EditableTextBox extends Widget { 
	text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	Style: SlateWidgetStyleAsset;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	Font: SlateFontInfo;
	ForegroundColor: LinearColor;
	BackgroundColor: LinearColor;
	ReadOnlyForegroundColor: LinearColor;
	IsReadOnly: boolean;
	IsPassword: boolean;
	MinimumDesiredWidth: number;
	Padding: Margin;
	IsCaretMovedWhenGainFocus: boolean;
	SelectAllTextWhenFocused: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	AllowContextMenu: boolean;
	KeyboardType: EVirtualKeyboardType;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardTrigger: EVirtualKeyboardTrigger;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Justification: ETextJustify;
	OverflowPolicy: ETextOverflowPolicy;
	ShapedTextOptions: ShapedTextOptions;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): EditableTextBox;
	static Find(Outer: UObject, ResourceName: string): EditableTextBox;
	static GetDefaultObject(): EditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditableTextBox;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetJustification(InJustification: ETextJustify): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetIsPassword(bIsPassword: boolean): void;
	SetHintText(InText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	HasError(): boolean;
	GetText(): string;
	ClearError(): void;
	static C(Other: UObject | any): EditableTextBox;
}

declare class ExpandableAreaStyle extends SlateWidgetStyle { 
	CollapsedImage: SlateBrush;
	ExpandedImage: SlateBrush;
	RolloutAnimationSeconds: number;
	clone() : ExpandableAreaStyle;
	static C(Other: UObject | any): ExpandableAreaStyle;
}

declare class ExpandableArea extends Widget { 
	Style: ExpandableAreaStyle;
	BorderBrush: SlateBrush;
	BorderColor: SlateColor;
	bIsExpanded: boolean;
	MaxHeight: number;
	HeaderPadding: Margin;
	AreaPadding: Margin;
	OnExpansionChanged: UnrealEngineMulticastDelegate<(Area: ExpandableArea, bIsExpanded: boolean) => void>;
	HeaderContent: Widget;
	BodyContent: Widget;
	static Load(ResourceName: string): ExpandableArea;
	static Find(Outer: UObject, ResourceName: string): ExpandableArea;
	static GetDefaultObject(): ExpandableArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ExpandableArea;
	SetIsExpanded_Animated(IsExpanded: boolean): void;
	SetIsExpanded(IsExpanded: boolean): void;
	GetIsExpanded(): boolean;
	static C(Other: UObject | any): ExpandableArea;
}

declare class FloatBinding extends PropertyBinding { 
	static Load(ResourceName: string): FloatBinding;
	static Find(Outer: UObject, ResourceName: string): FloatBinding;
	static GetDefaultObject(): FloatBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatBinding;
	GetValue(): number;
	static C(Other: UObject | any): FloatBinding;
}

declare class GridPanel extends PanelWidget { 
	ColumnFill: number[];
	RowFill: number[];
	static Load(ResourceName: string): GridPanel;
	static Find(Outer: UObject, ResourceName: string): GridPanel;
	static GetDefaultObject(): GridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridPanel;
	SetRowFill(ColumnIndex: number,Coefficient: number): void;
	SetColumnFill(ColumnIndex: number,Coefficient: number): void;
	AddChildToGrid(Content: Widget,InRow: number,InColumn: number): GridSlot;
	static C(Other: UObject | any): GridPanel;
}

declare class HorizontalBox extends PanelWidget { 
	static Load(ResourceName: string): HorizontalBox;
	static Find(Outer: UObject, ResourceName: string): HorizontalBox;
	static GetDefaultObject(): HorizontalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBox;
	AddChildToHorizontalBox(Content: Widget): HorizontalBoxSlot;
	static C(Other: UObject | any): HorizontalBox;
}

declare class UImage extends Widget { 
	UImage: SlateBrushAsset;
	Brush: SlateBrush;
	BrushDelegate: UnrealEngineDelegate<() => SlateBrush>;
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	bFlipForRightToLeftFlowDirection: boolean;
	OnMouseButtonDownEvent: UnrealEngineDelegate<(MyGeometry: Geometry, MouseEvent: UPointerEvent) => EventReply>;
	static Load(ResourceName: string): UImage;
	static Find(Outer: UObject, ResourceName: string): UImage;
	static GetDefaultObject(): UImage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UImage;
	SetOpacity(InOpacity: number): void;
	SetDesiredSizeOverride(DesiredSize: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetBrushTintColor(TintColor: SlateColor): void;
	SetBrushResourceObject(ResourceObject: UObject): void;
	SetBrushFromTextureDynamic(Texture: Texture2DDynamic,bMatchSize: boolean): void;
	SetBrushFromTexture(Texture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftTexture(SoftTexture: Texture2D,bMatchSize: boolean): void;
	SetBrushFromSoftMaterial(SoftMaterial: MaterialInterface): void;
	SetBrushFromMaterial(Material: MaterialInterface): void;
	SetBrushFromAsset(Asset: SlateBrushAsset): void;
	SetBrush(InBrush: SlateBrush): void;
	GetDynamicMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): UImage;
}

declare class InputChord { 
	Key: Key;
	bShift: boolean;
	bCtrl: boolean;
	bAlt: boolean;
	bCmd: boolean;
	clone() : InputChord;
	static C(Other: UObject | any): InputChord;
	EqualEqual_InputChordInputChord(B: InputChord): boolean;
	InputChord_GetDisplayName(): string;
	static EqualEqual_InputChordInputChord(A: InputChord,B: InputChord): boolean;
	static InputChord_GetDisplayName(Key: InputChord): string;
}

declare class InputKeySelector extends Widget { 
	WidgetStyle: ButtonStyle;
	TextStyle: TextBlockStyle;
	SelectedKey: InputChord;
	Font: SlateFontInfo;
	Margin: Margin;
	ColorAndOpacity: LinearColor;
	KeySelectionText: string;
	NoKeySpecifiedText: string;
	bAllowModifierKeys: boolean;
	bAllowGamepadKeys: boolean;
	EscapeKeys: Key[];
	OnKeySelected: UnrealEngineMulticastDelegate<(SelectedKey: InputChord) => void>;
	OnIsSelectingKeyChanged: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): InputKeySelector;
	static Find(Outer: UObject, ResourceName: string): InputKeySelector;
	static GetDefaultObject(): InputKeySelector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputKeySelector;
	SetTextBlockVisibility(InVisibility: ESlateVisibility): void;
	SetSelectedKey(InSelectedKey: InputChord): void;
	SetNoKeySpecifiedText(InNoKeySpecifiedText: string): void;
	SetKeySelectionText(InKeySelectionText: string): void;
	SetEscapeKeys(InKeys: Key[]): void;
	SetAllowModifierKeys(bInAllowModifierKeys: boolean): void;
	SetAllowGamepadKeys(bInAllowGamepadKeys: boolean): void;
	GetIsSelectingKey(): boolean;
	static C(Other: UObject | any): InputKeySelector;
}

declare class Int32Binding extends PropertyBinding { 
	static Load(ResourceName: string): Int32Binding;
	static Find(Outer: UObject, ResourceName: string): Int32Binding;
	static GetDefaultObject(): Int32Binding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Int32Binding;
	GetValue(): number;
	static C(Other: UObject | any): Int32Binding;
}

declare class InvalidationBox extends ContentWidget { 
	bCanCache: boolean;
	CacheRelativeTransforms: boolean;
	static Load(ResourceName: string): InvalidationBox;
	static Find(Outer: UObject, ResourceName: string): InvalidationBox;
	static GetDefaultObject(): InvalidationBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InvalidationBox;
	SetCanCache(CanCache: boolean): void;
	InvalidateCache(): void;
	GetCanCache(): boolean;
	static C(Other: UObject | any): InvalidationBox;
}

declare class UserListEntry extends Interface { 
	static Load(ResourceName: string): UserListEntry;
	static Find(Outer: UObject, ResourceName: string): UserListEntry;
	static GetDefaultObject(): UserListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntry;
	BP_OnItemSelectionChanged(bIsSelected: boolean): void;
	BP_OnItemExpansionChanged(bIsExpanded: boolean): void;
	BP_OnEntryReleased(): void;
	static C(Other: UObject | any): UserListEntry;
}

declare class UserListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserListEntryLibrary;
	static GetDefaultObject(): UserListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserListEntryLibrary;
	static C(Other: UObject | any): UserListEntryLibrary;
}

declare class UserObjectListEntry extends UserListEntry { 
	static Load(ResourceName: string): UserObjectListEntry;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntry;
	static GetDefaultObject(): UserObjectListEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntry;
	OnListItemObjectSet(ListItemObject: UObject): void;
	static C(Other: UObject | any): UserObjectListEntry;
}

declare class UserObjectListEntryLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): UserObjectListEntryLibrary;
	static Find(Outer: UObject, ResourceName: string): UserObjectListEntryLibrary;
	static GetDefaultObject(): UserObjectListEntryLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserObjectListEntryLibrary;
	static C(Other: UObject | any): UserObjectListEntryLibrary;
}

declare class ListViewBase extends Widget { 
	EntryWidgetClass: UnrealEngineClass;
	WheelScrollMultiplier: number;
	bEnableScrollAnimation: boolean;
	AllowOverscroll: boolean;
	bEnableRightClickScrolling: boolean;
	bEnableFixedLineOffset: boolean;
	FixedLineScrollOffset: number;
	bAllowDragging: boolean;
	BP_OnEntryGenerated: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	BP_OnEntryReleased: UnrealEngineMulticastDelegate<(Widget: UserWidget) => void>;
	NumDesignerPreviewEntries: number;
	EntryWidgetPool: UserWidgetPool;
	static Load(ResourceName: string): ListViewBase;
	static Find(Outer: UObject, ResourceName: string): ListViewBase;
	static GetDefaultObject(): ListViewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewBase;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollOffset(InScrollOffset: number): void;
	SetScrollbarVisibility(InVisibility: ESlateVisibility): void;
	ScrollToTop(): void;
	ScrollToBottom(): void;
	RequestRefresh(): void;
	RegenerateAllEntries(): void;
	GetScrollOffset(): number;
	GetDisplayedEntryWidgets(): UserWidget[];
	static C(Other: UObject | any): ListViewBase;
}

declare class TableViewStyle extends SlateWidgetStyle { 
	BackgroundBrush: SlateBrush;
	clone() : TableViewStyle;
	static C(Other: UObject | any): TableViewStyle;
}

declare type EOrientation = 'Orient_Horizontal' | 'Orient_Vertical' | 'Orient_MAX';
declare var EOrientation : { Orient_Horizontal:'Orient_Horizontal',Orient_Vertical:'Orient_Vertical',Orient_MAX:'Orient_MAX', };
declare type ESelectionMode = 'None' | 'Single' | 'SingleToggle' | 'Multi' | 'ESelectionMode_MAX';
declare var ESelectionMode : { None:'None',Single:'Single',SingleToggle:'SingleToggle',Multi:'Multi',ESelectionMode_MAX:'ESelectionMode_MAX', };
declare type EConsumeMouseWheel = 'WhenScrollingPossible' | 'Always' | 'Never' | 'EConsumeMouseWheel_MAX';
declare var EConsumeMouseWheel : { WhenScrollingPossible:'WhenScrollingPossible',Always:'Always',Never:'Never',EConsumeMouseWheel_MAX:'EConsumeMouseWheel_MAX', };
declare class ListView extends ListViewBase { 
	WidgetStyle: TableViewStyle;
	ScrollBarStyle: ScrollBarStyle;
	Orientation: EOrientation;
	SelectionMode: ESelectionMode;
	ConsumeMouseWheel: EConsumeMouseWheel;
	bClearSelectionOnClick: boolean;
	bIsFocusable: boolean;
	EntrySpacing: number;
	bReturnFocusToSelection: boolean;
	ListItems: UObject[];
	BP_OnEntryInitialized: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	BP_OnItemClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemDoubleClicked: UnrealEngineMulticastDelegate<(Item: UObject) => void>;
	BP_OnItemIsHoveredChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsHovered: boolean) => void>;
	BP_OnItemSelectionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsSelected: boolean) => void>;
	BP_OnItemScrolledIntoView: UnrealEngineMulticastDelegate<(Item: UObject, Widget: UserWidget) => void>;
	static Load(ResourceName: string): ListView;
	static Find(Outer: UObject, ResourceName: string): ListView;
	static GetDefaultObject(): ListView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListView;
	SetSelectionMode(SelectionMode: ESelectionMode): void;
	SetSelectedIndex(index: number): void;
	ScrollIndexIntoView(index: number): void;
	RemoveItem(Item: UObject): void;
	OnListItemOuterEndPlayed(ItemOuter: Actor,EndPlayReason: EEndPlayReason): void;
	OnListItemEndPlayed(Item: Actor,EndPlayReason: EEndPlayReason): void;
	NavigateToIndex(index: number): void;
	IsRefreshPending(): boolean;
	GetNumItems(): number;
	GetListItems(): UObject[];
	GetItemAt(index: number): UObject;
	GetIndexForItem(Item: UObject): number;
	ClearListItems(): void;
	BP_SetSelectedItem(Item: UObject): void;
	BP_SetListItems(InListItems: UObject[]): void;
	BP_SetItemSelection(Item: UObject,bSelected: boolean): void;
	BP_ScrollItemIntoView(Item: UObject): void;
	BP_NavigateToItem(Item: UObject): void;
	BP_IsItemVisible(Item: UObject): boolean;
	BP_GetSelectedItems(Items?: UObject[]): {Items: UObject[], $: boolean};
	BP_GetSelectedItem(): UObject;
	BP_GetNumItemsSelected(): number;
	BP_ClearSelection(): void;
	BP_CancelScrollIntoView(): void;
	AddItem(Item: UObject): void;
	static C(Other: UObject | any): ListView;
}

declare class ListViewDesignerPreviewItem extends UObject { 
	static Load(ResourceName: string): ListViewDesignerPreviewItem;
	static Find(Outer: UObject, ResourceName: string): ListViewDesignerPreviewItem;
	static GetDefaultObject(): ListViewDesignerPreviewItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ListViewDesignerPreviewItem;
	static C(Other: UObject | any): ListViewDesignerPreviewItem;
}

declare type EMenuPlacement = 'MenuPlacement_BelowAnchor' | 'MenuPlacement_CenteredBelowAnchor' | 'MenuPlacement_BelowRightAnchor' | 'MenuPlacement_ComboBox' | 'MenuPlacement_ComboBoxRight' | 'MenuPlacement_MenuRight' | 'MenuPlacement_AboveAnchor' | 'MenuPlacement_CenteredAboveAnchor' | 'MenuPlacement_AboveRightAnchor' | 'MenuPlacement_MenuLeft' | 'MenuPlacement_Center' | 'MenuPlacement_RightLeftCenter' | 'MenuPlacement_MatchBottomLeft' | 'MenuPlacement_MAX';
declare var EMenuPlacement : { MenuPlacement_BelowAnchor:'MenuPlacement_BelowAnchor',MenuPlacement_CenteredBelowAnchor:'MenuPlacement_CenteredBelowAnchor',MenuPlacement_BelowRightAnchor:'MenuPlacement_BelowRightAnchor',MenuPlacement_ComboBox:'MenuPlacement_ComboBox',MenuPlacement_ComboBoxRight:'MenuPlacement_ComboBoxRight',MenuPlacement_MenuRight:'MenuPlacement_MenuRight',MenuPlacement_AboveAnchor:'MenuPlacement_AboveAnchor',MenuPlacement_CenteredAboveAnchor:'MenuPlacement_CenteredAboveAnchor',MenuPlacement_AboveRightAnchor:'MenuPlacement_AboveRightAnchor',MenuPlacement_MenuLeft:'MenuPlacement_MenuLeft',MenuPlacement_Center:'MenuPlacement_Center',MenuPlacement_RightLeftCenter:'MenuPlacement_RightLeftCenter',MenuPlacement_MatchBottomLeft:'MenuPlacement_MatchBottomLeft',MenuPlacement_MAX:'MenuPlacement_MAX', };
declare class MenuAnchor extends ContentWidget { 
	MenuClass: UnrealEngineClass;
	OnGetMenuContentEvent: UnrealEngineDelegate<() => Widget>;
	OnGetUserMenuContentEvent: UnrealEngineDelegate<() => UserWidget>;
	PLACEMENT: EMenuPlacement;
	bFitInWindow: boolean;
	ShouldDeferPaintingAfterWindowContent: boolean;
	UseApplicationMenuStack: boolean;
	OnMenuOpenChanged: UnrealEngineMulticastDelegate<(bIsOpen: boolean) => void>;
	static Load(ResourceName: string): MenuAnchor;
	static Find(Outer: UObject, ResourceName: string): MenuAnchor;
	static GetDefaultObject(): MenuAnchor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MenuAnchor;
	ToggleOpen(bFocusOnOpen: boolean): void;
	ShouldOpenDueToClick(): boolean;
	SetPlacement(InPlacement: EMenuPlacement): void;
	Open(bFocusMenu: boolean): void;
	IsOpen(): boolean;
	HasOpenSubMenus(): boolean;
	GetMenuPosition(): Vector2D;
	FitInWindow(bFit: boolean): void;
	Close(): void;
	static C(Other: UObject | any): MenuAnchor;
}

declare class MouseCursorBinding extends PropertyBinding { 
	static Load(ResourceName: string): MouseCursorBinding;
	static Find(Outer: UObject, ResourceName: string): MouseCursorBinding;
	static GetDefaultObject(): MouseCursorBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorBinding;
	GetValue(): EMouseCursor;
	static C(Other: UObject | any): MouseCursorBinding;
}

declare class MovieSceneEntitySystem extends UObject { 
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): MovieSceneEntitySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntitySystem;
	static GetDefaultObject(): MovieSceneEntitySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntitySystem;
	static C(Other: UObject | any): MovieSceneEntitySystem;
}

declare class MovieSceneEntityInstantiatorSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntityInstantiatorSystem;
	static GetDefaultObject(): MovieSceneEntityInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntityInstantiatorSystem;
	static C(Other: UObject | any): MovieSceneEntityInstantiatorSystem;
}

declare class MovieScenePropertyInstantiatorSystem extends MovieSceneEntityInstantiatorSystem { 
	static Load(ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyInstantiatorSystem;
	static GetDefaultObject(): MovieScenePropertyInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyInstantiatorSystem;
	static C(Other: UObject | any): MovieScenePropertyInstantiatorSystem;
}

declare class MovieScenePropertySystem extends MovieSceneEntitySystem { 
	InstantiatorSystem: MovieScenePropertyInstantiatorSystem;
	static Load(ResourceName: string): MovieScenePropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertySystem;
	static GetDefaultObject(): MovieScenePropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertySystem;
	static C(Other: UObject | any): MovieScenePropertySystem;
}

declare class MovieScene2DTransformPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieScene2DTransformPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformPropertySystem;
	static GetDefaultObject(): MovieScene2DTransformPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformPropertySystem;
	static C(Other: UObject | any): MovieScene2DTransformPropertySystem;
}

declare class MovieScene2DTransformMask { 
	mask: any;
	clone() : MovieScene2DTransformMask;
	static C(Other: UObject | any): MovieScene2DTransformMask;
}

declare class MovieScene2DTransformSection extends MovieSceneSection { 
	TransformMask: MovieScene2DTransformMask;
	Translation: MovieSceneFloatChannel;
	Rotation: MovieSceneFloatChannel;
	Scale: MovieSceneFloatChannel;
	Shear: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieScene2DTransformSection;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformSection;
	static GetDefaultObject(): MovieScene2DTransformSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformSection;
	static C(Other: UObject | any): MovieScene2DTransformSection;
}

declare class MovieScenePropertyBinding { 
	PropertyName: string;
	PropertyPath: string;
	bCanUseClassLookup: boolean;
	clone() : MovieScenePropertyBinding;
	static C(Other: UObject | any): MovieScenePropertyBinding;
}

declare class MovieScenePropertyTrack extends MovieSceneNameableTrack { 
	UniqueTrackName: string;
	PropertyName: string;
	PropertyPath: string;
	SectionToKey: MovieSceneSection;
	PropertyBinding: MovieScenePropertyBinding;
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieScenePropertyTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScenePropertyTrack;
	static GetDefaultObject(): MovieScenePropertyTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScenePropertyTrack;
	static C(Other: UObject | any): MovieScenePropertyTrack;
	GetPropertyName(): string;
	GetPropertyPath(): string;
	GetUniqueTrackName(): string;
	SetPropertyNameAndPath(InPropertyName: string,InPropertyPath: string): void;
	static GetPropertyName(Track: MovieScenePropertyTrack): string;
	static GetPropertyPath(Track: MovieScenePropertyTrack): string;
	static GetUniqueTrackName(Track: MovieScenePropertyTrack): string;
	static SetPropertyNameAndPath(Track: MovieScenePropertyTrack,InPropertyName: string,InPropertyPath: string): void;
}

declare class MovieScene2DTransformTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieScene2DTransformTrack;
	static Find(Outer: UObject, ResourceName: string): MovieScene2DTransformTrack;
	static GetDefaultObject(): MovieScene2DTransformTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene2DTransformTrack;
	static C(Other: UObject | any): MovieScene2DTransformTrack;
}

declare class MovieSceneMarginPropertySystem extends MovieScenePropertySystem { 
	static Load(ResourceName: string): MovieSceneMarginPropertySystem;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginPropertySystem;
	static GetDefaultObject(): MovieSceneMarginPropertySystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginPropertySystem;
	static C(Other: UObject | any): MovieSceneMarginPropertySystem;
}

declare class MovieSceneMarginSection extends MovieSceneSection { 
	TopCurve: MovieSceneFloatChannel;
	LeftCurve: MovieSceneFloatChannel;
	RightCurve: MovieSceneFloatChannel;
	BottomCurve: MovieSceneFloatChannel;
	static Load(ResourceName: string): MovieSceneMarginSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginSection;
	static GetDefaultObject(): MovieSceneMarginSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginSection;
	static C(Other: UObject | any): MovieSceneMarginSection;
}

declare class MovieSceneMarginTrack extends MovieScenePropertyTrack { 
	static Load(ResourceName: string): MovieSceneMarginTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMarginTrack;
	static GetDefaultObject(): MovieSceneMarginTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMarginTrack;
	static C(Other: UObject | any): MovieSceneMarginTrack;
}

declare class MovieSceneMaterialTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMaterialTrack;
	static GetDefaultObject(): MovieSceneMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMaterialTrack;
	static C(Other: UObject | any): MovieSceneMaterialTrack;
}

declare class MovieSceneWidgetMaterialTrack extends MovieSceneMaterialTrack { 
	BrushPropertyNamePath: string[];
	TrackName: string;
	static Load(ResourceName: string): MovieSceneWidgetMaterialTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneWidgetMaterialTrack;
	static GetDefaultObject(): MovieSceneWidgetMaterialTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneWidgetMaterialTrack;
	static C(Other: UObject | any): MovieSceneWidgetMaterialTrack;
}

declare type ETextWrappingPolicy = 'DefaultWrapping' | 'AllowPerCharacterWrapping' | 'ETextWrappingPolicy_MAX';
declare var ETextWrappingPolicy : { DefaultWrapping:'DefaultWrapping',AllowPerCharacterWrapping:'AllowPerCharacterWrapping',ETextWrappingPolicy_MAX:'ETextWrappingPolicy_MAX', };
declare class TextLayoutWidget extends Widget { 
	ShapedTextOptions: ShapedTextOptions;
	Justification: ETextJustify;
	WrappingPolicy: ETextWrappingPolicy;
	AutoWrapText: boolean;
	WrapTextAt: number;
	Margin: Margin;
	LineHeightPercentage: number;
	static Load(ResourceName: string): TextLayoutWidget;
	static Find(Outer: UObject, ResourceName: string): TextLayoutWidget;
	static GetDefaultObject(): TextLayoutWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextLayoutWidget;
	SetJustification(InJustification: ETextJustify): void;
	static C(Other: UObject | any): TextLayoutWidget;
}

declare class MultiLineEditableText extends TextLayoutWidget { 
	text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	Font: SlateFontInfo;
	SelectAllTextWhenFocused: boolean;
	ClearTextSelectionOnFocusLoss: boolean;
	RevertTextOnEscape: boolean;
	ClearKeyboardFocusOnCommit: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): MultiLineEditableText;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableText;
	static GetDefaultObject(): MultiLineEditableText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableText;
	SetWidgetStyle(InWidgetStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	GetText(): string;
	GetHintText(): string;
	static C(Other: UObject | any): MultiLineEditableText;
}

declare class MultiLineEditableTextBox extends TextLayoutWidget { 
	text: string;
	HintText: string;
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	WidgetStyle: EditableTextBoxStyle;
	TextStyle: TextBlockStyle;
	bIsReadOnly: boolean;
	AllowContextMenu: boolean;
	VirtualKeyboardOptions: VirtualKeyboardOptions;
	VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
	Style: SlateWidgetStyleAsset;
	Font: SlateFontInfo;
	ForegroundColor: LinearColor;
	BackgroundColor: LinearColor;
	ReadOnlyForegroundColor: LinearColor;
	OnTextChanged: UnrealEngineMulticastDelegate<(text: string) => void>;
	OnTextCommitted: UnrealEngineMulticastDelegate<(text: string, CommitMethod: ETextCommit) => void>;
	static Load(ResourceName: string): MultiLineEditableTextBox;
	static Find(Outer: UObject, ResourceName: string): MultiLineEditableTextBox;
	static GetDefaultObject(): MultiLineEditableTextBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MultiLineEditableTextBox;
	SetTextStyle(InTextStyle: TextBlockStyle): void;
	SetText(InText: string): void;
	SetIsReadOnly(bReadOnly: boolean): void;
	SetHintText(InHintText: string): void;
	SetForegroundColor(Color: LinearColor): void;
	SetError(InError: string): void;
	GetText(): string;
	GetHintText(): string;
	static C(Other: UObject | any): MultiLineEditableTextBox;
}

declare class NamedSlot extends ContentWidget { 
	static Load(ResourceName: string): NamedSlot;
	static Find(Outer: UObject, ResourceName: string): NamedSlot;
	static GetDefaultObject(): NamedSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlot;
	static C(Other: UObject | any): NamedSlot;
}

declare class NamedSlotInterface extends Interface { 
	static Load(ResourceName: string): NamedSlotInterface;
	static Find(Outer: UObject, ResourceName: string): NamedSlotInterface;
	static GetDefaultObject(): NamedSlotInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedSlotInterface;
	static C(Other: UObject | any): NamedSlotInterface;
}

declare class NativeWidgetHost extends Widget { 
	static Load(ResourceName: string): NativeWidgetHost;
	static Find(Outer: UObject, ResourceName: string): NativeWidgetHost;
	static GetDefaultObject(): NativeWidgetHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NativeWidgetHost;
	static C(Other: UObject | any): NativeWidgetHost;
	SetContent(SlateWidget: JavascriptSlateWidget): Widget;
	static SetContent(TargetWidget: NativeWidgetHost,SlateWidget: JavascriptSlateWidget): Widget;
}

declare class Overlay extends PanelWidget { 
	static Load(ResourceName: string): Overlay;
	static Find(Outer: UObject, ResourceName: string): Overlay;
	static GetDefaultObject(): Overlay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Overlay;
	AddChildToOverlay(Content: Widget): OverlaySlot;
	static C(Other: UObject | any): Overlay;
}

declare type EProgressBarFillType = 'LeftToRight' | 'RightToLeft' | 'FillFromCenter' | 'FillFromCenterHorizontal' | 'FillFromCenterVertical' | 'TopToBottom' | 'BottomToTop' | 'EProgressBarFillType_MAX';
declare var EProgressBarFillType : { LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',FillFromCenter:'FillFromCenter',FillFromCenterHorizontal:'FillFromCenterHorizontal',FillFromCenterVertical:'FillFromCenterVertical',TopToBottom:'TopToBottom',BottomToTop:'BottomToTop',EProgressBarFillType_MAX:'EProgressBarFillType_MAX', };
declare type EProgressBarFillStyle = 'Mask' | 'Scale' | 'EProgressBarFillStyle_MAX';
declare var EProgressBarFillStyle : { Mask:'Mask',Scale:'Scale',EProgressBarFillStyle_MAX:'EProgressBarFillStyle_MAX', };
declare class ProgressBar extends Widget { 
	WidgetStyle: ProgressBarStyle;
	Style: SlateWidgetStyleAsset;
	BackgroundImage: SlateBrushAsset;
	FillImage: SlateBrushAsset;
	MarqueeImage: SlateBrushAsset;
	Percent: number;
	BarFillType: EProgressBarFillType;
	BarFillStyle: EProgressBarFillStyle;
	bIsMarquee: boolean;
	BorderPadding: Vector2D;
	PercentDelegate: UnrealEngineDelegate<() => number>;
	FillColorAndOpacity: LinearColor;
	FillColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	static Load(ResourceName: string): ProgressBar;
	static Find(Outer: UObject, ResourceName: string): ProgressBar;
	static GetDefaultObject(): ProgressBar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProgressBar;
	SetPercent(InPercent: number): void;
	SetIsMarquee(InbIsMarquee: boolean): void;
	SetFillColorAndOpacity(InColor: LinearColor): void;
	static C(Other: UObject | any): ProgressBar;
}

declare class RetainerBox extends ContentWidget { 
	bRetainRender: boolean;
	RenderOnInvalidation: boolean;
	RenderOnPhase: boolean;
	Phase: number;
	PhaseCount: number;
	EffectMaterial: MaterialInterface;
	TextureParameter: string;
	static Load(ResourceName: string): RetainerBox;
	static Find(Outer: UObject, ResourceName: string): RetainerBox;
	static GetDefaultObject(): RetainerBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RetainerBox;
	SetTextureParameter(TextureParameter: string): void;
	SetRetainRendering(bInRetainRendering: boolean): void;
	SetRenderingPhase(RenderPhase: number,TotalPhases: number): void;
	SetEffectMaterial(EffectMaterial: MaterialInterface): void;
	RequestRender(): void;
	GetEffectMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): RetainerBox;
}

declare class RichTextBlockDecorator extends UObject { 
	static Load(ResourceName: string): RichTextBlockDecorator;
	static Find(Outer: UObject, ResourceName: string): RichTextBlockDecorator;
	static GetDefaultObject(): RichTextBlockDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockDecorator;
	static C(Other: UObject | any): RichTextBlockDecorator;
}

declare class RichTextBlock extends TextLayoutWidget { 
	text: string;
	TextStyleSet: DataTable;
	DecoratorClasses: UnrealEngineClass[];
	bOverrideDefaultStyle: boolean;
	DefaultTextStyleOverride: TextBlockStyle;
	MinDesiredWidth: number;
	TextTransformPolicy: ETextTransformPolicy;
	TextOverflowPolicy: ETextOverflowPolicy;
	DefaultTextStyle: TextBlockStyle;
	InstanceDecorators: RichTextBlockDecorator[];
	static Load(ResourceName: string): RichTextBlock;
	static Find(Outer: UObject, ResourceName: string): RichTextBlock;
	static GetDefaultObject(): RichTextBlock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlock;
	SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;
	SetTextStyleSet(NewTextStyleSet: DataTable): void;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetDefaultTextStyle(InDefaultTextStyle: TextBlockStyle): void;
	SetDefaultStrikeBrush(InStrikeBrush?: SlateBrush): {InStrikeBrush: SlateBrush};
	SetDefaultShadowOffset(InShadowOffset: Vector2D): void;
	SetDefaultShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetDefaultFont(InFontInfo: SlateFontInfo): void;
	SetDefaultColorAndOpacity(InColorAndOpacity: SlateColor): void;
	SetAutoWrapText(InAutoTextWrap: boolean): void;
	RefreshTextLayout(): void;
	GetText(): string;
	GetDefaultDynamicMaterial(): MaterialInstanceDynamic;
	GetDecoratorByClass(DecoratorClass: UnrealEngineClass): RichTextBlockDecorator;
	ClearAllDefaultStyleOverrides(): void;
	static C(Other: UObject | any): RichTextBlock;
}

declare class RichTextBlockImageDecorator extends RichTextBlockDecorator { 
	ImageSet: DataTable;
	static Load(ResourceName: string): RichTextBlockImageDecorator;
	static Find(Outer: UObject, ResourceName: string): RichTextBlockImageDecorator;
	static GetDefaultObject(): RichTextBlockImageDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RichTextBlockImageDecorator;
	static C(Other: UObject | any): RichTextBlockImageDecorator;
}

declare class SafeZone extends ContentWidget { 
	PadLeft: boolean;
	PadRight: boolean;
	PadTop: boolean;
	PadBottom: boolean;
	static Load(ResourceName: string): SafeZone;
	static Find(Outer: UObject, ResourceName: string): SafeZone;
	static GetDefaultObject(): SafeZone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SafeZone;
	SetSidesToPad(InPadLeft: boolean,InPadRight: boolean,InPadTop: boolean,InPadBottom: boolean): void;
	static C(Other: UObject | any): SafeZone;
}

declare type EStretch = 'None' | 'Fill' | 'ScaleToFit' | 'ScaleToFitX' | 'ScaleToFitY' | 'ScaleToFill' | 'ScaleBySafeZone' | 'UserSpecified' | 'EStretch_MAX';
declare var EStretch : { None:'None',Fill:'Fill',ScaleToFit:'ScaleToFit',ScaleToFitX:'ScaleToFitX',ScaleToFitY:'ScaleToFitY',ScaleToFill:'ScaleToFill',ScaleBySafeZone:'ScaleBySafeZone',UserSpecified:'UserSpecified',EStretch_MAX:'EStretch_MAX', };
declare type EStretchDirection = 'Both' | 'DownOnly' | 'UpOnly' | 'EStretchDirection_MAX';
declare var EStretchDirection : { Both:'Both',DownOnly:'DownOnly',UpOnly:'UpOnly',EStretchDirection_MAX:'EStretchDirection_MAX', };
declare class ScaleBox extends ContentWidget { 
	Stretch: EStretch;
	StretchDirection: EStretchDirection;
	UserSpecifiedScale: number;
	IgnoreInheritedScale: boolean;
	static Load(ResourceName: string): ScaleBox;
	static Find(Outer: UObject, ResourceName: string): ScaleBox;
	static GetDefaultObject(): ScaleBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleBox;
	SetUserSpecifiedScale(InUserSpecifiedScale: number): void;
	SetStretchDirection(InStretchDirection: EStretchDirection): void;
	SetStretch(InStretch: EStretch): void;
	SetIgnoreInheritedScale(bInIgnoreInheritedScale: boolean): void;
	static C(Other: UObject | any): ScaleBox;
}

declare class ScrollBar extends Widget { 
	WidgetStyle: ScrollBarStyle;
	Style: SlateWidgetStyleAsset;
	bAlwaysShowScrollbar: boolean;
	bAlwaysShowScrollbarTrack: boolean;
	Orientation: EOrientation;
	Thickness: Vector2D;
	Padding: Margin;
	static Load(ResourceName: string): ScrollBar;
	static Find(Outer: UObject, ResourceName: string): ScrollBar;
	static GetDefaultObject(): ScrollBar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBar;
	SetState(InOffsetFraction: number,InThumbSizeFraction: number): void;
	static C(Other: UObject | any): ScrollBar;
}

declare type EDescendantScrollDestination = 'IntoView' | 'TopOrLeft' | 'Center' | 'BottomOrRight' | 'EDescendantScrollDestination_MAX';
declare var EDescendantScrollDestination : { IntoView:'IntoView',TopOrLeft:'TopOrLeft',Center:'Center',BottomOrRight:'BottomOrRight',EDescendantScrollDestination_MAX:'EDescendantScrollDestination_MAX', };
declare type EScrollWhenFocusChanges = 'NoScroll' | 'InstantScroll' | 'AnimatedScroll' | 'EScrollWhenFocusChanges_MAX';
declare var EScrollWhenFocusChanges : { NoScroll:'NoScroll',InstantScroll:'InstantScroll',AnimatedScroll:'AnimatedScroll',EScrollWhenFocusChanges_MAX:'EScrollWhenFocusChanges_MAX', };
declare class ScrollBox extends PanelWidget { 
	WidgetStyle: ScrollBoxStyle;
	WidgetBarStyle: ScrollBarStyle;
	Style: SlateWidgetStyleAsset;
	BarStyle: SlateWidgetStyleAsset;
	Orientation: EOrientation;
	ScrollBarVisibility: ESlateVisibility;
	ConsumeMouseWheel: EConsumeMouseWheel;
	ScrollbarThickness: Vector2D;
	ScrollbarPadding: Margin;
	AlwaysShowScrollbar: boolean;
	AlwaysShowScrollbarTrack: boolean;
	AllowOverscroll: boolean;
	BackPadScrolling: boolean;
	FrontPadScrolling: boolean;
	bAnimateWheelScrolling: boolean;
	NavigationDestination: EDescendantScrollDestination;
	NavigationScrollPadding: number;
	ScrollWhenFocusChanges: EScrollWhenFocusChanges;
	bAllowRightClickDragScrolling: boolean;
	WheelScrollMultiplier: number;
	OnUserScrolled: UnrealEngineMulticastDelegate<(CurrentOffset: number) => void>;
	static Load(ResourceName: string): ScrollBox;
	static Find(Outer: UObject, ResourceName: string): ScrollBox;
	static GetDefaultObject(): ScrollBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBox;
	SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
	SetScrollWhenFocusChanges(NewScrollWhenFocusChanges: EScrollWhenFocusChanges): void;
	SetScrollOffset(NewScrollOffset: number): void;
	SetScrollBarVisibility(NewScrollBarVisibility: ESlateVisibility): void;
	SetScrollbarThickness(NewScrollbarThickness: Vector2D): void;
	SetScrollbarPadding(NewScrollbarPadding: Margin): void;
	SetOrientation(NewOrientation: EOrientation): void;
	SetNavigationDestination(NewNavigationDestination: EDescendantScrollDestination): void;
	SetConsumeMouseWheel(NewConsumeMouseWheel: EConsumeMouseWheel): void;
	SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean): void;
	SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean): void;
	SetAllowOverscroll(NewAllowOverscroll: boolean): void;
	ScrollWidgetIntoView(WidgetToFind: Widget,AnimateScroll: boolean,ScrollDestination: EDescendantScrollDestination,Padding: number): void;
	ScrollToStart(): void;
	ScrollToEnd(): void;
	GetViewOffsetFraction(): number;
	GetScrollOffsetOfEnd(): number;
	GetScrollOffset(): number;
	EndInertialScrolling(): void;
	static C(Other: UObject | any): ScrollBox;
}

declare class SizeBox extends ContentWidget { 
	WidthOverride: number;
	HeightOverride: number;
	MinDesiredWidth: number;
	MinDesiredHeight: number;
	MaxDesiredWidth: number;
	MaxDesiredHeight: number;
	MinAspectRatio: number;
	MaxAspectRatio: number;
	bOverride_WidthOverride: boolean;
	bOverride_HeightOverride: boolean;
	bOverride_MinDesiredWidth: boolean;
	bOverride_MinDesiredHeight: boolean;
	bOverride_MaxDesiredWidth: boolean;
	bOverride_MaxDesiredHeight: boolean;
	bOverride_MinAspectRatio: boolean;
	bOverride_MaxAspectRatio: boolean;
	static Load(ResourceName: string): SizeBox;
	static Find(Outer: UObject, ResourceName: string): SizeBox;
	static GetDefaultObject(): SizeBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SizeBox;
	SetWidthOverride(InWidthOverride: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetMinDesiredHeight(InMinDesiredHeight: number): void;
	SetMinAspectRatio(InMinAspectRatio: number): void;
	SetMaxDesiredWidth(InMaxDesiredWidth: number): void;
	SetMaxDesiredHeight(InMaxDesiredHeight: number): void;
	SetMaxAspectRatio(InMaxAspectRatio: number): void;
	SetHeightOverride(InHeightOverride: number): void;
	ClearWidthOverride(): void;
	ClearMinDesiredWidth(): void;
	ClearMinDesiredHeight(): void;
	ClearMinAspectRatio(): void;
	ClearMaxDesiredWidth(): void;
	ClearMaxDesiredHeight(): void;
	ClearMaxAspectRatio(): void;
	ClearHeightOverride(): void;
	static C(Other: UObject | any): SizeBox;
}

declare class SlateBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SlateBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SlateBlueprintLibrary;
	static GetDefaultObject(): SlateBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBlueprintLibrary;
	static TransformVectorLocalToAbsolute(Geometry: Geometry,LocalVector: Vector2D): Vector2D;
	static TransformVectorAbsoluteToLocal(Geometry: Geometry,AbsoluteVector: Vector2D): Vector2D;
	static TransformScalarLocalToAbsolute(Geometry: Geometry,LocalScalar: number): number;
	static TransformScalarAbsoluteToLocal(Geometry: Geometry,AbsoluteScalar: number): number;
	static ScreenToWidgetLocal(WorldContextObject: UObject,Geometry: Geometry,ScreenPosition: Vector2D,LocalCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {LocalCoordinate: Vector2D};
	static ScreenToWidgetAbsolute(WorldContextObject: UObject,ScreenPosition: Vector2D,AbsoluteCoordinate?: Vector2D,bIncludeWindowPosition?: boolean): {AbsoluteCoordinate: Vector2D};
	static ScreenToViewport(WorldContextObject: UObject,ScreenPosition: Vector2D,ViewportPosition?: Vector2D): {ViewportPosition: Vector2D};
	static LocalToViewport(WorldContextObject: UObject,Geometry: Geometry,LocalCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static LocalToAbsolute(Geometry: Geometry,LocalCoordinate: Vector2D): Vector2D;
	static IsUnderLocation(Geometry: Geometry,AbsoluteCoordinate: Vector2D): boolean;
	static GetLocalTopLeft(Geometry: Geometry): Vector2D;
	static GetLocalSize(Geometry: Geometry): Vector2D;
	static GetAbsoluteSize(Geometry: Geometry): Vector2D;
	static EqualEqual_SlateBrush(A: SlateBrush,B: SlateBrush): boolean;
	static AbsoluteToViewport(WorldContextObject: UObject,AbsoluteDesktopCoordinate: Vector2D,PixelPosition?: Vector2D,ViewportPosition?: Vector2D): {PixelPosition: Vector2D, ViewportPosition: Vector2D};
	static AbsoluteToLocal(Geometry: Geometry,AbsoluteCoordinate: Vector2D): Vector2D;
	static C(Other: UObject | any): SlateBlueprintLibrary;
}

declare class SlateMeshVertex { 
	position: Vector2f;
	Color: Color;
	UV0: Vector2f;
	UV1: Vector2f;
	UV2: Vector2f;
	UV3: Vector2f;
	UV4: Vector2f;
	UV5: Vector2f;
	clone() : SlateMeshVertex;
	static C(Other: UObject | any): SlateMeshVertex;
}

declare class SlateVectorArtData extends UObject { 
	MeshAsset: StaticMesh;
	SourceMaterial: MaterialInterface;
	VertexData: SlateMeshVertex[];
	IndexData: any[];
	Material: MaterialInterface;
	ExtentMin: Vector2D;
	ExtentMax: Vector2D;
	static Load(ResourceName: string): SlateVectorArtData;
	static Find(Outer: UObject, ResourceName: string): SlateVectorArtData;
	static GetDefaultObject(): SlateVectorArtData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateVectorArtData;
	static C(Other: UObject | any): SlateVectorArtData;
}

declare class SliderStyle extends SlateWidgetStyle { 
	NormalBarImage: SlateBrush;
	HoveredBarImage: SlateBrush;
	DisabledBarImage: SlateBrush;
	NormalThumbImage: SlateBrush;
	HoveredThumbImage: SlateBrush;
	DisabledThumbImage: SlateBrush;
	BarThickness: number;
	clone() : SliderStyle;
	static C(Other: UObject | any): SliderStyle;
}

declare class Slider extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	MinValue: number;
	MaxValue: number;
	WidgetStyle: SliderStyle;
	Orientation: EOrientation;
	SliderBarColor: LinearColor;
	SliderHandleColor: LinearColor;
	IndentHandle: boolean;
	Locked: boolean;
	MouseUsesStep: boolean;
	RequiresControllerLock: boolean;
	StepSize: number;
	IsFocusable: boolean;
	OnMouseCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnMouseCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureBegin: UnrealEngineMulticastDelegate<() => void>;
	OnControllerCaptureEnd: UnrealEngineMulticastDelegate<() => void>;
	OnValueChanged: UnrealEngineMulticastDelegate<(Value: number) => void>;
	static Load(ResourceName: string): Slider;
	static Find(Outer: UObject, ResourceName: string): Slider;
	static GetDefaultObject(): Slider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Slider;
	SetValue(InValue: number): void;
	SetStepSize(InValue: number): void;
	SetSliderHandleColor(InValue: LinearColor): void;
	SetSliderBarColor(InValue: LinearColor): void;
	SetMinValue(InValue: number): void;
	SetMaxValue(InValue: number): void;
	SetLocked(InValue: boolean): void;
	SetIndentHandle(InValue: boolean): void;
	GetValue(): number;
	GetNormalizedValue(): number;
	static C(Other: UObject | any): Slider;
}

declare class Spacer extends Widget { 
	Size: Vector2D;
	static Load(ResourceName: string): Spacer;
	static Find(Outer: UObject, ResourceName: string): Spacer;
	static GetDefaultObject(): Spacer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Spacer;
	SetSize(InSize: Vector2D): void;
	static C(Other: UObject | any): Spacer;
}

declare class SpinBox extends Widget { 
	Value: number;
	ValueDelegate: UnrealEngineDelegate<() => number>;
	WidgetStyle: SpinBoxStyle;
	Style: SlateWidgetStyleAsset;
	MinFractionalDigits: number;
	MaxFractionalDigits: number;
	bAlwaysUsesDeltaSnap: boolean;
	Delta: number;
	SliderExponent: number;
	Font: SlateFontInfo;
	Justification: ETextJustify;
	MinDesiredWidth: number;
	ClearKeyboardFocusOnCommit: boolean;
	SelectAllTextOnCommit: boolean;
	ForegroundColor: SlateColor;
	OnValueChanged: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	OnValueCommitted: UnrealEngineMulticastDelegate<(InValue: number, CommitMethod: ETextCommit) => void>;
	OnBeginSliderMovement: UnrealEngineMulticastDelegate<() => void>;
	OnEndSliderMovement: UnrealEngineMulticastDelegate<(InValue: number) => void>;
	bOverride_MinValue: boolean;
	bOverride_MaxValue: boolean;
	bOverride_MinSliderValue: boolean;
	bOverride_MaxSliderValue: boolean;
	MinValue: number;
	MaxValue: number;
	MinSliderValue: number;
	MaxSliderValue: number;
	static Load(ResourceName: string): SpinBox;
	static Find(Outer: UObject, ResourceName: string): SpinBox;
	static GetDefaultObject(): SpinBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpinBox;
	SetValue(NewValue: number): void;
	SetMinValue(NewValue: number): void;
	SetMinSliderValue(NewValue: number): void;
	SetMinFractionalDigits(NewValue: number): void;
	SetMaxValue(NewValue: number): void;
	SetMaxSliderValue(NewValue: number): void;
	SetMaxFractionalDigits(NewValue: number): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	SetDelta(NewValue: number): void;
	SetAlwaysUsesDeltaSnap(bNewValue: boolean): void;
	GetValue(): number;
	GetMinValue(): number;
	GetMinSliderValue(): number;
	GetMinFractionalDigits(): number;
	GetMaxValue(): number;
	GetMaxSliderValue(): number;
	GetMaxFractionalDigits(): number;
	GetDelta(): number;
	GetAlwaysUsesDeltaSnap(): boolean;
	ClearMinValue(): void;
	ClearMinSliderValue(): void;
	ClearMaxValue(): void;
	ClearMaxSliderValue(): void;
	static C(Other: UObject | any): SpinBox;
}

declare class TextBinding extends PropertyBinding { 
	static Load(ResourceName: string): TextBinding;
	static Find(Outer: UObject, ResourceName: string): TextBinding;
	static GetDefaultObject(): TextBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBinding;
	GetTextValue(): string;
	GetStringValue(): string;
	static C(Other: UObject | any): TextBinding;
}

declare class TextBlock extends TextLayoutWidget { 
	text: string;
	TextDelegate: UnrealEngineDelegate<() => string>;
	ColorAndOpacity: SlateColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => SlateColor>;
	Font: SlateFontInfo;
	StrikeBrush: SlateBrush;
	ShadowOffset: Vector2D;
	ShadowColorAndOpacity: LinearColor;
	ShadowColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	MinDesiredWidth: number;
	bWrapWithInvalidationPanel: boolean;
	bAutoWrapText: boolean;
	TextTransformPolicy: ETextTransformPolicy;
	TextOverflowPolicy: ETextOverflowPolicy;
	bSimpleTextMode: boolean;
	static Load(ResourceName: string): TextBlock;
	static Find(Outer: UObject, ResourceName: string): TextBlock;
	static GetDefaultObject(): TextBlock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextBlock;
	SetTextTransformPolicy(InTransformPolicy: ETextTransformPolicy): void;
	SetTextOverflowPolicy(InOverflowPolicy: ETextOverflowPolicy): void;
	SetText(InText: string): void;
	SetStrikeBrush(InStrikeBrush: SlateBrush): void;
	SetShadowOffset(InShadowOffset: Vector2D): void;
	SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
	SetOpacity(InOpacity: number): void;
	SetMinDesiredWidth(InMinDesiredWidth: number): void;
	SetFont(InFontInfo: SlateFontInfo): void;
	SetColorAndOpacity(InColorAndOpacity: SlateColor): void;
	SetAutoWrapText(InAutoTextWrap: boolean): void;
	GetText(): string;
	GetDynamicOutlineMaterial(): MaterialInstanceDynamic;
	GetDynamicFontMaterial(): MaterialInstanceDynamic;
	static C(Other: UObject | any): TextBlock;
}

declare class Throbber extends Widget { 
	NumberOfPieces: number;
	bAnimateHorizontally: boolean;
	bAnimateVertically: boolean;
	bAnimateOpacity: boolean;
	PieceImage: SlateBrushAsset;
	UImage: SlateBrush;
	static Load(ResourceName: string): Throbber;
	static Find(Outer: UObject, ResourceName: string): Throbber;
	static GetDefaultObject(): Throbber;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Throbber;
	SetNumberOfPieces(InNumberOfPieces: number): void;
	SetAnimateVertically(bInAnimateVertically: boolean): void;
	SetAnimateOpacity(bInAnimateOpacity: boolean): void;
	SetAnimateHorizontally(bInAnimateHorizontally: boolean): void;
	static C(Other: UObject | any): Throbber;
}

declare type EListItemAlignment = 'EvenlyDistributed' | 'EvenlySize' | 'EvenlyWide' | 'LeftAligned' | 'RightAligned' | 'CenterAligned' | 'Fill' | 'EListItemAlignment_MAX';
declare var EListItemAlignment : { EvenlyDistributed:'EvenlyDistributed',EvenlySize:'EvenlySize',EvenlyWide:'EvenlyWide',LeftAligned:'LeftAligned',RightAligned:'RightAligned',CenterAligned:'CenterAligned',Fill:'Fill',EListItemAlignment_MAX:'EListItemAlignment_MAX', };
declare class TileView extends ListView { 
	EntryHeight: number;
	EntryWidth: number;
	TileAlignment: EListItemAlignment;
	bWrapHorizontalNavigation: boolean;
	static Load(ResourceName: string): TileView;
	static Find(Outer: UObject, ResourceName: string): TileView;
	static GetDefaultObject(): TileView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileView;
	SetEntryWidth(NewWidth: number): void;
	SetEntryHeight(NewHeight: number): void;
	GetEntryWidth(): number;
	GetEntryHeight(): number;
	static C(Other: UObject | any): TileView;
}

declare class TreeView extends ListView { 
	BP_OnGetItemChildren: UnrealEngineDelegate<(Item: UObject, Children: UObject[]) => void>;
	BP_OnItemExpansionChanged: UnrealEngineMulticastDelegate<(Item: UObject, bIsExpanded: boolean) => void>;
	static Load(ResourceName: string): TreeView;
	static Find(Outer: UObject, ResourceName: string): TreeView;
	static GetDefaultObject(): TreeView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TreeView;
	SetItemExpansion(Item: UObject,bExpandItem: boolean): void;
	ExpandAll(): void;
	CollapseAll(): void;
	static C(Other: UObject | any): TreeView;
}

declare class UniformGridPanel extends PanelWidget { 
	SlotPadding: Margin;
	MinDesiredSlotWidth: number;
	MinDesiredSlotHeight: number;
	static Load(ResourceName: string): UniformGridPanel;
	static Find(Outer: UObject, ResourceName: string): UniformGridPanel;
	static GetDefaultObject(): UniformGridPanel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridPanel;
	SetSlotPadding(InSlotPadding: Margin): void;
	SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number): void;
	SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number): void;
	AddChildToUniformGrid(Content: Widget,InRow: number,InColumn: number): UniformGridSlot;
	static C(Other: UObject | any): UniformGridPanel;
}

declare class UserWidgetBlueprint extends Blueprint { 
	static Load(ResourceName: string): UserWidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): UserWidgetBlueprint;
	static GetDefaultObject(): UserWidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidgetBlueprint;
	static C(Other: UObject | any): UserWidgetBlueprint;
}

declare class VerticalBox extends PanelWidget { 
	static Load(ResourceName: string): VerticalBox;
	static Find(Outer: UObject, ResourceName: string): VerticalBox;
	static GetDefaultObject(): VerticalBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBox;
	AddChildToVerticalBox(Content: Widget): VerticalBoxSlot;
	static C(Other: UObject | any): VerticalBox;
}

declare class Viewport extends ContentWidget { 
	BackgroundColor: LinearColor;
	static Load(ResourceName: string): Viewport;
	static Find(Outer: UObject, ResourceName: string): Viewport;
	static GetDefaultObject(): Viewport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Viewport;
	Spawn(ActorClass: UnrealEngineClass): Actor;
	SetViewRotation(Rotation: Rotator): void;
	SetViewLocation(Location: Vector): void;
	GetViewRotation(): Rotator;
	GetViewportWorld(): World;
	GetViewLocation(): Vector;
	static C(Other: UObject | any): Viewport;
}

declare class VisibilityBinding extends PropertyBinding { 
	static Load(ResourceName: string): VisibilityBinding;
	static Find(Outer: UObject, ResourceName: string): VisibilityBinding;
	static GetDefaultObject(): VisibilityBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisibilityBinding;
	GetValue(): ESlateVisibility;
	static C(Other: UObject | any): VisibilityBinding;
}

declare class BlueprintWidgetAnimationDelegateBinding { 
	Action: EWidgetAnimationEvent;
	AnimationToBind: string;
	FunctionNameToBind: string;
	UserTag: string;
	clone() : BlueprintWidgetAnimationDelegateBinding;
	static C(Other: UObject | any): BlueprintWidgetAnimationDelegateBinding;
}

declare class WidgetAnimationDelegateBinding extends DynamicBlueprintBinding { 
	WidgetAnimationDelegateBindings: BlueprintWidgetAnimationDelegateBinding[];
	static Load(ResourceName: string): WidgetAnimationDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationDelegateBinding;
	static GetDefaultObject(): WidgetAnimationDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationDelegateBinding;
	static C(Other: UObject | any): WidgetAnimationDelegateBinding;
}

declare class WidgetAnimationPlayCallbackProxy extends UObject { 
	Finished: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimationPlayCallbackProxy;
	static GetDefaultObject(): WidgetAnimationPlayCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimationPlayCallbackProxy;
	static CreatePlayAnimationTimeRangeProxyObject(Result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,EndAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {Result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static CreatePlayAnimationProxyObject(Result?: UMGSequencePlayer,Widget?: UserWidget,InAnimation?: WidgetAnimation,StartAtTime?: number,NumLoopsToPlay?: number,PlayMode?: EUMGSequencePlayMode,PlaybackSpeed?: number): {Result: UMGSequencePlayer, $: WidgetAnimationPlayCallbackProxy};
	static C(Other: UObject | any): WidgetAnimationPlayCallbackProxy;
}

declare class WidgetBinding extends PropertyBinding { 
	static Load(ResourceName: string): WidgetBinding;
	static Find(Outer: UObject, ResourceName: string): WidgetBinding;
	static GetDefaultObject(): WidgetBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBinding;
	GetValue(): Widget;
	static C(Other: UObject | any): WidgetBinding;
}

declare class EventGraphFastCallPair { 
	FunctionToPatch: UFunction;
	EventGraphCallOffset: number;
	clone() : EventGraphFastCallPair;
	static C(Other: UObject | any): EventGraphFastCallPair;
}

declare class BlueprintGeneratedClass extends Class { 
	NumReplicatedProperties: number;
	bHasNativizedParent: boolean;
	bHasCookedComponentInstancingData: boolean;
	bIsSparseClassDataSerializable: boolean;
	DynamicBindingObjects: DynamicBlueprintBinding[];
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	SimpleConstructionScript: SimpleConstructionScript;
	InheritableComponentHandler: InheritableComponentHandler;
	UberGraphFramePointerProperty: StructProperty;
	UberGraphFunction: UFunction;
	FastCallPairs: EventGraphFastCallPair[];
	OverridenArchetypeForCDO: UObject;
	PropertyGuids: any;
	CalledFunctions: UFunction[];
	CookedComponentInstancingData: any;
	static Load(ResourceName: string): BlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): BlueprintGeneratedClass;
	static GetDefaultObject(): BlueprintGeneratedClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintGeneratedClass;
	static C(Other: UObject | any): BlueprintGeneratedClass;
}

declare type EBindingKind = 'Function' | 'Property' | 'EBindingKind_MAX';
declare var EBindingKind : { Function:'Function',Property:'Property',EBindingKind_MAX:'EBindingKind_MAX', };
declare class DelegateRuntimeBinding { 
	ObjectName: string;
	PropertyName: string;
	FunctionName: string;
	SourcePath: DynamicPropertyPath;
	Kind: EBindingKind;
	clone() : DelegateRuntimeBinding;
	static C(Other: UObject | any): DelegateRuntimeBinding;
}

declare class WidgetBlueprintGeneratedClass extends BlueprintGeneratedClass { 
	WidgetTree: WidgetTree;
	bCanCallPreConstruct: boolean;
	bClassRequiresNativeTick: boolean;
	Bindings: DelegateRuntimeBinding[];
	Animations: WidgetAnimation[];
	NamedSlots: string[];
	static Load(ResourceName: string): WidgetBlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintGeneratedClass;
	static GetDefaultObject(): WidgetBlueprintGeneratedClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintGeneratedClass;
	static C(Other: UObject | any): WidgetBlueprintGeneratedClass;
}

declare class NavigationEvent extends InputEvent { 
	clone() : NavigationEvent;
	static C(Other: UObject | any): NavigationEvent;
	GetInputEventFromNavigationEvent(): InputEvent;
	static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;
}

declare class WidgetBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): WidgetBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintLibrary;
	static GetDefaultObject(): WidgetBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintLibrary;
	static UnlockMouse(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static Unhandled(): EventReply;
	static SetWindowTitleBarState(TitleBarContent: Widget,Mode: EWindowTitleBarMode,bTitleBarDragEnabled: boolean,bWindowButtonsVisible: boolean,bTitleBarVisible: boolean): void;
	static SetWindowTitleBarCloseButtonActive(bActive: boolean): void;
	static SetUserFocus(Reply?: EventReply,FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static SetMousePosition(Reply?: EventReply,NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	static SetInputMode_UIOnlyEx(PlayerController: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode): void;
	static SetInputMode_GameOnly(PlayerController: PlayerController): void;
	static SetInputMode_GameAndUIEx(PlayerController: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode,bHideCursorDuringCapture: boolean): void;
	static SetHardwareCursor(WorldContextObject: UObject,CursorShape: EMouseCursor,CursorName: string,HotSpot: Vector2D): boolean;
	static SetFocusToGameViewport(): void;
	static SetColorVisionDeficiencyType(Type: EColorVisionDeficiency,Severity: number,CorrectDeficiency: boolean,ShowCorrectionWithDeficiency: boolean): void;
	static SetBrushResourceToTexture(Brush?: SlateBrush,Texture?: Texture2D): {Brush: SlateBrush};
	static SetBrushResourceToMaterial(Brush?: SlateBrush,Material?: MaterialInterface): {Brush: SlateBrush};
	static RestorePreviousWindowTitleBarState(): void;
	static ReleaseMouseCapture(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static ReleaseJoystickCapture(Reply?: EventReply,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static NoResourceBrush(): SlateBrush;
	static MakeBrushFromTexture(Texture: Texture2D,Width: number,Height: number): SlateBrush;
	static MakeBrushFromMaterial(Material: MaterialInterface,Width: number,Height: number): SlateBrush;
	static MakeBrushFromAsset(BrushAsset: SlateBrushAsset): SlateBrush;
	static LockMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static IsDragDropping(): boolean;
	static Handled(): EventReply;
	static GetSafeZonePadding(WorldContextObject: UObject,SafePadding?: Vector4,SafePaddingScale?: Vector2D,SpillOverPadding?: Vector4): {SafePadding: Vector4, SafePaddingScale: Vector2D, SpillOverPadding: Vector4};
	static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;
	static GetInputEventFromPointerEvent(Event: UPointerEvent): InputEvent;
	static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;
	static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;
	static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;
	static GetDynamicMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	static GetDragDroppingContent(): DragDropOperation;
	static GetBrushResourceAsTexture2D(Brush: SlateBrush): Texture2D;
	static GetBrushResourceAsMaterial(Brush: SlateBrush): MaterialInterface;
	static GetBrushResource(Brush: SlateBrush): UObject;
	static GetAllWidgetsWithInterface(WorldContextObject: UObject,FoundWidgets?: UserWidget[],Interface?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static GetAllWidgetsOfClass(WorldContextObject: UObject,FoundWidgets?: UserWidget[],WidgetClass?: UnrealEngineClass,TopLevelOnly?: boolean): {FoundWidgets: UserWidget[]};
	static EndDragDrop(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static DrawTextFormatted(Context?: PaintContext,text?: string,position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
	static DrawText(Context?: PaintContext,InString?: string,position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	static DrawLines(Context?: PaintContext,Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	static DrawLine(Context?: PaintContext,PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	static DrawBox(Context?: PaintContext,position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	static DismissAllMenus(): void;
	static DetectDragIfPressed(UPointerEvent: UPointerEvent,WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	static DetectDrag(Reply?: EventReply,WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	static CreateDragDropOperation(OperationClass: UnrealEngineClass): DragDropOperation;
	static Create(WorldContextObject: UObject,WidgetType: UnrealEngineClass,OwningPlayer: PlayerController): UserWidget;
	static ClearUserFocus(Reply?: EventReply,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static CaptureMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static CaptureJoystick(Reply?: EventReply,CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static CancelDragDrop(): void;
	static C(Other: UObject | any): WidgetBlueprintLibrary;
}

declare type EWidgetInteractionSource = 'World' | 'Mouse' | 'CenterScreen' | 'Custom' | 'EWidgetInteractionSource_MAX';
declare var EWidgetInteractionSource : { World:'World',Mouse:'Mouse',CenterScreen:'CenterScreen',Custom:'Custom',EWidgetInteractionSource_MAX:'EWidgetInteractionSource_MAX', };
declare class WidgetInteractionComponent extends SceneComponent { 
	OnHoveredWidgetChanged: UnrealEngineMulticastDelegate<(WidgetComponent: WidgetComponent, PreviousWidgetComponent: WidgetComponent) => void>;
	VirtualUserIndex: number;
	PointerIndex: number;
	TraceChannel: ECollisionChannel;
	InteractionDistance: number;
	InteractionSource: EWidgetInteractionSource;
	bEnableHitTesting: boolean;
	bShowDebug: boolean;
	DebugSphereLineThickness: number;
	DebugLineThickness: number;
	DebugColor: LinearColor;
	CustomHitResult: HitResult;
	LocalHitLocation: Vector2D;
	LastLocalHitLocation: Vector2D;
	HoveredWidgetComponent: WidgetComponent;
	LastHitResult: HitResult;
	bIsHoveredWidgetInteractable: boolean;
	bIsHoveredWidgetFocusable: boolean;
	bIsHoveredWidgetHitTestVisible: boolean;
	ArrowComponent: ArrowComponent;
	static Load(ResourceName: string): WidgetInteractionComponent;
	static Find(Outer: UObject, ResourceName: string): WidgetInteractionComponent;
	static GetDefaultObject(): WidgetInteractionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetInteractionComponent;
	SetFocus(FocusWidget: Widget): void;
	SetCustomHitResult(HitResult: HitResult): void;
	SendKeyChar(Characters: string,bRepeat: boolean): boolean;
	ScrollWheel(ScrollDelta: number): void;
	ReleasePointerKey(Key: Key): void;
	ReleaseKey(Key: Key): boolean;
	PressPointerKey(Key: Key): void;
	PressKey(Key: Key,bRepeat: boolean): boolean;
	PressAndReleaseKey(Key: Key): boolean;
	IsOverInteractableWidget(): boolean;
	IsOverHitTestVisibleWidget(): boolean;
	IsOverFocusableWidget(): boolean;
	GetLastHitResult(): HitResult;
	GetHoveredWidgetComponent(): WidgetComponent;
	Get2DHitLocation(): Vector2D;
	static C(Other: UObject | any): WidgetInteractionComponent;
}

declare class WidgetLayoutLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): WidgetLayoutLibrary;
	static Find(Outer: UObject, ResourceName: string): WidgetLayoutLibrary;
	static GetDefaultObject(): WidgetLayoutLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetLayoutLibrary;
	static SlotAsWrapBoxSlot(Widget: Widget): WrapBoxSlot;
	static SlotAsWidgetSwitcherSlot(Widget: Widget): WidgetSwitcherSlot;
	static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
	static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
	static SlotAsSizeBoxSlot(Widget: Widget): SizeBoxSlot;
	static SlotAsScrollBoxSlot(Widget: Widget): ScrollBoxSlot;
	static SlotAsScaleBoxSlot(Widget: Widget): ScaleBoxSlot;
	static SlotAsSafeBoxSlot(Widget: Widget): SafeZoneSlot;
	static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
	static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
	static SlotAsGridSlot(Widget: Widget): GridSlot;
	static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
	static SlotAsBorderSlot(Widget: Widget): BorderSlot;
	static RemoveAllWidgets(WorldContextObject: UObject): void;
	static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController,WorldLocation: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	static GetViewportWidgetGeometry(WorldContextObject: UObject): Geometry;
	static GetViewportSize(WorldContextObject: UObject): Vector2D;
	static GetViewportScale(WorldContextObject: UObject): number;
	static GetPlayerScreenWidgetGeometry(PlayerController: PlayerController): Geometry;
	static GetMousePositionScaledByDPI(Player: PlayerController,LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	static GetMousePositionOnViewport(WorldContextObject: UObject): Vector2D;
	static GetMousePositionOnPlatform(): Vector2D;
	static C(Other: UObject | any): WidgetLayoutLibrary;
}

declare class WidgetSwitcher extends PanelWidget { 
	ActiveWidgetIndex: number;
	static Load(ResourceName: string): WidgetSwitcher;
	static Find(Outer: UObject, ResourceName: string): WidgetSwitcher;
	static GetDefaultObject(): WidgetSwitcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSwitcher;
	SetActiveWidgetIndex(index: number): void;
	SetActiveWidget(Widget: Widget): void;
	GetWidgetAtIndex(index: number): Widget;
	GetNumWidgets(): number;
	GetActiveWidgetIndex(): number;
	GetActiveWidget(): Widget;
	static C(Other: UObject | any): WidgetSwitcher;
}

declare class WindowTitleBarArea extends ContentWidget { 
	bWindowButtonsEnabled: boolean;
	bDoubleClickTogglesFullscreen: boolean;
	static Load(ResourceName: string): WindowTitleBarArea;
	static Find(Outer: UObject, ResourceName: string): WindowTitleBarArea;
	static GetDefaultObject(): WindowTitleBarArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowTitleBarArea;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): WindowTitleBarArea;
}

declare class WindowTitleBarAreaSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): WindowTitleBarAreaSlot;
	static Find(Outer: UObject, ResourceName: string): WindowTitleBarAreaSlot;
	static GetDefaultObject(): WindowTitleBarAreaSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowTitleBarAreaSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): WindowTitleBarAreaSlot;
}

declare class WrapBox extends PanelWidget { 
	InnerSlotPadding: Vector2D;
	WrapWidth: number;
	WrapSize: number;
	bExplicitWrapWidth: boolean;
	bExplicitWrapSize: boolean;
	HorizontalAlignment: EHorizontalAlignment;
	Orientation: EOrientation;
	static Load(ResourceName: string): WrapBox;
	static Find(Outer: UObject, ResourceName: string): WrapBox;
	static GetDefaultObject(): WrapBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WrapBox;
	SetInnerSlotPadding(InPadding: Vector2D): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	AddChildToWrapBox(Content: Widget): WrapBoxSlot;
	static C(Other: UObject | any): WrapBox;
}

declare class BlueprintEditorLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintEditorLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorLibrary;
	static GetDefaultObject(): BlueprintEditorLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorLibrary;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static RenameGraph(Graph: EdGraph,NewNameStr: string): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static GetBlueprintAsset(UObject: UObject): Blueprint;
	static GeneratedClass(BlueprintObj: Blueprint): UnrealEngineClass;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static C(Other: UObject | any): BlueprintEditorLibrary;
}

declare class ClassViewerProjectSettings extends UObject { 
	InternalOnlyPaths: DirectoryPath[];
	InternalOnlyClasses: SoftClassPath[];
	static Load(ResourceName: string): ClassViewerProjectSettings;
	static Find(Outer: UObject, ResourceName: string): ClassViewerProjectSettings;
	static GetDefaultObject(): ClassViewerProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClassViewerProjectSettings;
	static C(Other: UObject | any): ClassViewerProjectSettings;
}

declare type EContentBrowserDataMenuContext_AddNewMenuDomain = 'Toolbar' | 'AssetView' | 'PathView' | 'EContentBrowserDataMenuContext_MAX';
declare var EContentBrowserDataMenuContext_AddNewMenuDomain : { Toolbar:'Toolbar',AssetView:'AssetView',PathView:'PathView',EContentBrowserDataMenuContext_MAX:'EContentBrowserDataMenuContext_MAX', };
declare class ContentBrowserDataMenuContext_AddNewMenu extends UObject { 
	SelectedPaths: string[];
	bContainsValidPackagePath: boolean;
	bCanBeModified: boolean;
	OwnerDomain: EContentBrowserDataMenuContext_AddNewMenuDomain;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_AddNewMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_AddNewMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_AddNewMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_AddNewMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_AddNewMenu;
}

declare class ContentBrowserItem { 
	clone() : ContentBrowserItem;
	static C(Other: UObject | any): ContentBrowserItem;
	GetDisplayName(): string;
	GetVirtualPath(): string;
	IsFile(): boolean;
	IsFolder(): boolean;
	static GetDisplayName(Item: ContentBrowserItem): string;
	static GetVirtualPath(Item: ContentBrowserItem): string;
	static IsFile(Item: ContentBrowserItem): boolean;
	static IsFolder(Item: ContentBrowserItem): boolean;
}

declare class ContentBrowserDataMenuContext_FolderMenu extends UObject { 
	SelectedItems: ContentBrowserItem[];
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_FolderMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_FolderMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_FolderMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_FolderMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_FolderMenu;
}

declare class ContentBrowserDataMenuContext_FileMenu extends UObject { 
	SelectedItems: ContentBrowserItem[];
	bCanBeModified: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_FileMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_FileMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_FileMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_FileMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_FileMenu;
}

declare class ContentBrowserDataMenuContext_DragDropMenu extends UObject { 
	DropTargetItem: ContentBrowserItem;
	DraggedItems: ContentBrowserItem[];
	bCanMove: boolean;
	bCanCopy: boolean;
	static Load(ResourceName: string): ContentBrowserDataMenuContext_DragDropMenu;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataMenuContext_DragDropMenu;
	static GetDefaultObject(): ContentBrowserDataMenuContext_DragDropMenu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataMenuContext_DragDropMenu;
	static C(Other: UObject | any): ContentBrowserDataMenuContext_DragDropMenu;
}

declare class ContentBrowserDataSource extends UObject { 
	static Load(ResourceName: string): ContentBrowserDataSource;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataSource;
	static GetDefaultObject(): ContentBrowserDataSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataSource;
	static C(Other: UObject | any): ContentBrowserDataSource;
}

declare type EContentBrowserItemTypeFilter = 'IncludeNone' | 'IncludeFolders' | 'IncludeFiles' | 'IncludeAll' | 'EContentBrowserItemTypeFilter_MAX';
declare var EContentBrowserItemTypeFilter : { IncludeNone:'IncludeNone',IncludeFolders:'IncludeFolders',IncludeFiles:'IncludeFiles',IncludeAll:'IncludeAll',EContentBrowserItemTypeFilter_MAX:'EContentBrowserItemTypeFilter_MAX', };
declare type EContentBrowserItemCategoryFilter = 'IncludeNone' | 'IncludeAssets' | 'IncludeClasses' | 'IncludeCollections' | 'IncludeMisc' | 'IncludeAll' | 'EContentBrowserItemCategoryFilter_MAX';
declare var EContentBrowserItemCategoryFilter : { IncludeNone:'IncludeNone',IncludeAssets:'IncludeAssets',IncludeClasses:'IncludeClasses',IncludeCollections:'IncludeCollections',IncludeMisc:'IncludeMisc',IncludeAll:'IncludeAll',EContentBrowserItemCategoryFilter_MAX:'EContentBrowserItemCategoryFilter_MAX', };
declare type EContentBrowserItemAttributeFilter = 'IncludeNone' | 'IncludeProject' | 'IncludeEngine' | 'IncludePlugins' | 'IncludeDeveloper' | 'IncludeLocalized' | 'IncludeAll' | 'EContentBrowserItemAttributeFilter_MAX';
declare var EContentBrowserItemAttributeFilter : { IncludeNone:'IncludeNone',IncludeProject:'IncludeProject',IncludeEngine:'IncludeEngine',IncludePlugins:'IncludePlugins',IncludeDeveloper:'IncludeDeveloper',IncludeLocalized:'IncludeLocalized',IncludeAll:'IncludeAll',EContentBrowserItemAttributeFilter_MAX:'EContentBrowserItemAttributeFilter_MAX', };
declare class ContentBrowserDataFilter { 
	bRecursivePaths: boolean;
	ItemTypeFilter: EContentBrowserItemTypeFilter;
	ItemCategoryFilter: EContentBrowserItemCategoryFilter;
	ItemAttributeFilter: EContentBrowserItemAttributeFilter;
	clone() : ContentBrowserDataFilter;
	static C(Other: UObject | any): ContentBrowserDataFilter;
}

declare class ContentBrowserDataSubsystem extends EditorSubsystem { 
	EnabledDataSources: string[];
	static Load(ResourceName: string): ContentBrowserDataSubsystem;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserDataSubsystem;
	static GetDefaultObject(): ContentBrowserDataSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserDataSubsystem;
	GetItemsUnderPath(InPath: string,InFilter: ContentBrowserDataFilter): ContentBrowserItem[];
	GetItemsAtPath(InPath: string,InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem[];
	GetItemAtPath(InPath: string,InItemTypeFilter: EContentBrowserItemTypeFilter): ContentBrowserItem;
	GetAvailableDataSources(): string[];
	GetActiveDataSources(): string[];
	DeactivateDataSource(Name: string): boolean;
	DeactivateAllDataSources(): void;
	ActivateDataSource(Name: string): boolean;
	ActivateAllDataSources(): void;
	static C(Other: UObject | any): ContentBrowserDataSubsystem;
}

declare class ContentBrowserItemLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ContentBrowserItemLibrary;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserItemLibrary;
	static GetDefaultObject(): ContentBrowserItemLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserItemLibrary;
	static IsFolder(Item: ContentBrowserItem): boolean;
	static IsFile(Item: ContentBrowserItem): boolean;
	static GetVirtualPath(Item: ContentBrowserItem): string;
	static GetDisplayName(Item: ContentBrowserItem): string;
	static C(Other: UObject | any): ContentBrowserItemLibrary;
}

declare class EditorConfigBase extends UObject { 
	static Load(ResourceName: string): EditorConfigBase;
	static Find(Outer: UObject, ResourceName: string): EditorConfigBase;
	static GetDefaultObject(): EditorConfigBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigBase;
	static C(Other: UObject | any): EditorConfigBase;
}

declare class EditorConfigSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): EditorConfigSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorConfigSubsystem;
	static GetDefaultObject(): EditorConfigSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigSubsystem;
	static C(Other: UObject | any): EditorConfigSubsystem;
}

declare class EditorConfigTestStruct { 
	BoolProperty: boolean;
	IntProperty: number;
	StringProperty: string;
	FloatProperty: number;
	ArrayProperty: string[];
	clone() : EditorConfigTestStruct;
	static C(Other: UObject | any): EditorConfigTestStruct;
}

declare class EditorConfigTestObject extends UObject { 
	UObject: UObject;
	SoftObjectPath: SoftObjectPath;
	struct: EditorConfigTestStruct;
	Number: number;
	static Load(ResourceName: string): EditorConfigTestObject;
	static Find(Outer: UObject, ResourceName: string): EditorConfigTestObject;
	static GetDefaultObject(): EditorConfigTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorConfigTestObject;
	static C(Other: UObject | any): EditorConfigTestObject;
}

declare class EditorMetadataOverrides extends EditorSubsystem { 
	static Load(ResourceName: string): EditorMetadataOverrides;
	static Find(Outer: UObject, ResourceName: string): EditorMetadataOverrides;
	static GetDefaultObject(): EditorMetadataOverrides;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorMetadataOverrides;
	static C(Other: UObject | any): EditorMetadataOverrides;
}

declare class SourceControlState { 
	Filename: string;
	bIsValid: boolean;
	bIsUnknown: boolean;
	bCanCheckIn: boolean;
	bCanCheckOut: boolean;
	bIsCheckedOut: boolean;
	bIsCurrent: boolean;
	bIsSourceControlled: boolean;
	bIsAdded: boolean;
	bIsDeleted: boolean;
	bIsIgnored: boolean;
	bCanEdit: boolean;
	bCanDelete: boolean;
	bIsModified: boolean;
	bCanAdd: boolean;
	bIsConflicted: boolean;
	bCanRevert: boolean;
	bIsCheckedOutOther: boolean;
	CheckedOutOther: string;
	clone() : SourceControlState;
	static C(Other: UObject | any): SourceControlState;
}

declare class SourceControlHelpers extends UObject { 
	static Load(ResourceName: string): SourceControlHelpers;
	static Find(Outer: UObject, ResourceName: string): SourceControlHelpers;
	static GetDefaultObject(): SourceControlHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlHelpers;
	static SyncFiles(InFiles: string[],bSilent: boolean): boolean;
	static SyncFile(InFile: string,bSilent: boolean): boolean;
	static RevertUnchangedFiles(InFiles: string[],bSilent: boolean): boolean;
	static RevertUnchangedFile(InFile: string,bSilent: boolean): boolean;
	static RevertFiles(InFiles: string[],bSilent: boolean): boolean;
	static RevertFile(InFile: string,bSilent: boolean): boolean;
	static QueryFileState(InFile: string,bSilent: boolean): SourceControlState;
	static MarkFilesForDelete(InFiles: string[],bSilent: boolean): boolean;
	static MarkFilesForAdd(InFiles: string[],bSilent: boolean): boolean;
	static MarkFileForDelete(InFile: string,bSilent: boolean): boolean;
	static MarkFileForAdd(InFile: string,bSilent: boolean): boolean;
	static LastErrorMsg(): string;
	static IsEnabled(): boolean;
	static IsAvailable(): boolean;
	static CurrentProvider(): string;
	static CopyFile(InSourceFile: string,InDestFile: string,bSilent: boolean): boolean;
	static CheckOutOrAddFiles(InFiles: string[],bSilent: boolean): boolean;
	static CheckOutOrAddFile(InFile: string,bSilent: boolean): boolean;
	static CheckOutFiles(InFiles: string[],bSilent: boolean): boolean;
	static CheckOutFile(InFile: string,bSilent: boolean): boolean;
	static CheckInFiles(InFiles: string[],InDescription: string,bSilent: boolean): boolean;
	static CheckInFile(InFile: string,InDescription: string,bSilent: boolean): boolean;
	static C(Other: UObject | any): SourceControlHelpers;
}

declare class SourceControlPreferences extends DeveloperSettings { 
	bEnableValidationTag: boolean;
	bShouldDeleteNewFilesOnRevert: boolean;
	CollectionChangelistTags: string[];
	SpecificCollectionChangelistTags: any;
	static Load(ResourceName: string): SourceControlPreferences;
	static Find(Outer: UObject, ResourceName: string): SourceControlPreferences;
	static GetDefaultObject(): SourceControlPreferences;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceControlPreferences;
	static C(Other: UObject | any): SourceControlPreferences;
}

declare class ActorBrowsingModeSettings extends UObject { 
	bHideTemporaryActors: boolean;
	bShowOnlyActorsInCurrentLevel: boolean;
	bShowOnlySelectedActors: boolean;
	bHideActorComponents: boolean;
	bHideLevelInstanceHierarchy: boolean;
	bHideUnloadedActors: boolean;
	static Load(ResourceName: string): ActorBrowsingModeSettings;
	static Find(Outer: UObject, ResourceName: string): ActorBrowsingModeSettings;
	static GetDefaultObject(): ActorBrowsingModeSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorBrowsingModeSettings;
	static C(Other: UObject | any): ActorBrowsingModeSettings;
}

declare class OutlinerConfig extends EditorConfigBase { 
	Outliners: any;
	static Load(ResourceName: string): OutlinerConfig;
	static Find(Outer: UObject, ResourceName: string): OutlinerConfig;
	static GetDefaultObject(): OutlinerConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OutlinerConfig;
	static C(Other: UObject | any): OutlinerConfig;
}

declare class SceneOutlinerMenuContext extends UObject { 
	static Load(ResourceName: string): SceneOutlinerMenuContext;
	static Find(Outer: UObject, ResourceName: string): SceneOutlinerMenuContext;
	static GetDefaultObject(): SceneOutlinerMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneOutlinerMenuContext;
	static C(Other: UObject | any): SceneOutlinerMenuContext;
}

declare class DetailsConfig extends EditorConfigBase { 
	Views: any;
	static Load(ResourceName: string): DetailsConfig;
	static Find(Outer: UObject, ResourceName: string): DetailsConfig;
	static GetDefaultObject(): DetailsConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetailsConfig;
	static C(Other: UObject | any): DetailsConfig;
}

declare type EditConditionTestEnum = 'First' | 'Second' | 'EditConditionTestEnum_MAX';
declare var EditConditionTestEnum : { First:'First',Second:'Second',EditConditionTestEnum_MAX:'EditConditionTestEnum_MAX', };
declare type EditConditionByteEnum = 'First' | 'Second' | 'EditConditionByteEnum_MAX';
declare var EditConditionByteEnum : { First:'First',Second:'Second',EditConditionByteEnum_MAX:'EditConditionByteEnum_MAX', };
declare class EditConditionTestObject extends UObject { 
	BoolProperty: boolean;
	EnumProperty: EditConditionTestEnum;
	ByteEnumProperty: EditConditionByteEnum;
	DoubleProperty: any;
	IntegerProperty: number;
	UintBitfieldProperty: boolean;
	UObjectPtr: UObject;
	SoftClassPtr: Class;
	WeakObjectPtr: any;
	static Load(ResourceName: string): EditConditionTestObject;
	static Find(Outer: UObject, ResourceName: string): EditConditionTestObject;
	static GetDefaultObject(): EditConditionTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditConditionTestObject;
	static C(Other: UObject | any): EditConditionTestObject;
}

declare class BlueprintNodeSpawner extends UObject { 
	NodeClass: UnrealEngineClass;
	static Load(ResourceName: string): BlueprintNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintNodeSpawner;
	static GetDefaultObject(): BlueprintNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintNodeSpawner;
	static C(Other: UObject | any): BlueprintNodeSpawner;
}

declare class BlueprintEventNodeSpawner extends BlueprintNodeSpawner { 
	EventFunc: UFunction;
	CustomEventName: string;
	static Load(ResourceName: string): BlueprintEventNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintEventNodeSpawner;
	static GetDefaultObject(): BlueprintEventNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEventNodeSpawner;
	static C(Other: UObject | any): BlueprintEventNodeSpawner;
}

declare class BlueprintBoundEventNodeSpawner extends BlueprintEventNodeSpawner { 
	EventDelegate: any;
	static Load(ResourceName: string): BlueprintBoundEventNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintBoundEventNodeSpawner;
	static GetDefaultObject(): BlueprintBoundEventNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundEventNodeSpawner;
	static C(Other: UObject | any): BlueprintBoundEventNodeSpawner;
}

declare class BlueprintBoundNodeSpawner extends BlueprintNodeSpawner { 
	static Load(ResourceName: string): BlueprintBoundNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintBoundNodeSpawner;
	static GetDefaultObject(): BlueprintBoundNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintBoundNodeSpawner;
	static C(Other: UObject | any): BlueprintBoundNodeSpawner;
}

declare class BlueprintComponentNodeSpawner extends BlueprintNodeSpawner { 
	ComponentClass: UnrealEngineClass;
	ComponentName: string;
	ComponentAssetName: string;
	static Load(ResourceName: string): BlueprintComponentNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintComponentNodeSpawner;
	static GetDefaultObject(): BlueprintComponentNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintComponentNodeSpawner;
	static C(Other: UObject | any): BlueprintComponentNodeSpawner;
}

declare class BlueprintFieldNodeSpawner extends BlueprintNodeSpawner { 
	OwnerClass: UnrealEngineClass;
	Field: Field;
	Property: any;
	static Load(ResourceName: string): BlueprintFieldNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintFieldNodeSpawner;
	static GetDefaultObject(): BlueprintFieldNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFieldNodeSpawner;
	static C(Other: UObject | any): BlueprintFieldNodeSpawner;
}

declare class BlueprintDelegateNodeSpawner extends BlueprintFieldNodeSpawner { 
	static Load(ResourceName: string): BlueprintDelegateNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintDelegateNodeSpawner;
	static GetDefaultObject(): BlueprintDelegateNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintDelegateNodeSpawner;
	static C(Other: UObject | any): BlueprintDelegateNodeSpawner;
}

declare type EBlueprintBreakpointReloadMethod = 'RestoreAll' | 'RestoreAllAndDisable' | 'DiscardAll' | 'EBlueprintBreakpointReloadMethod_MAX';
declare var EBlueprintBreakpointReloadMethod : { RestoreAll:'RestoreAll',RestoreAllAndDisable:'RestoreAllAndDisable',DiscardAll:'DiscardAll',EBlueprintBreakpointReloadMethod_MAX:'EBlueprintBreakpointReloadMethod_MAX', };
declare type ESaveOnCompile = 'SoC_Never' | 'SoC_SuccessOnly' | 'SoC_Always' | 'SoC_MAX';
declare var ESaveOnCompile : { SoC_Never:'SoC_Never',SoC_SuccessOnly:'SoC_SuccessOnly',SoC_Always:'SoC_Always',SoC_MAX:'SoC_MAX', };
declare class BlueprintEditorSettings extends DeveloperSettings { 
	bDrawMidpointArrowsInBlueprints: boolean;
	bShowGraphInstructionText: boolean;
	bHideUnrelatedNodes: boolean;
	bShowShortTooltips: boolean;
	bSplitContextTargetSettings: boolean;
	bExposeAllMemberComponentFunctions: boolean;
	bShowContextualFavorites: boolean;
	bExposeDeprecatedFunctions: boolean;
	bCompactCallOnMemberNodes: boolean;
	bFlattenFavoritesMenus: boolean;
	bAutoCastObjectConnections: boolean;
	bShowViewportOnSimulate: boolean;
	bSpawnDefaultBlueprintNodes: boolean;
	bHideConstructionScriptComponentsInDetailsView: boolean;
	bHostFindInBlueprintsInGlobalTab: boolean;
	bNavigateToNativeFunctionsFromCallNodes: boolean;
	bDoubleClickNavigatesToParent: boolean;
	bEnableTypePromotion: boolean;
	TypePromotionPinDenyList: any;
	BreakpointReloadMethod: EBlueprintBreakpointReloadMethod;
	bEnablePinValueInspectionTooltips: boolean;
	bEnableNamespaceEditorFeatures: boolean;
	bEnableNamespaceFilteringFeatures: boolean;
	bEnableNamespaceImportingFeatures: boolean;
	NamespacesToAlwaysInclude: string[];
	bFavorPureCastNodes: boolean;
	SaveOnCompile: ESaveOnCompile;
	bJumpToNodeErrors: boolean;
	bAllowExplicitImpureNodeDisabling: boolean;
	bShowActionMenuItemSignatures: boolean;
	bBlueprintNodeUniqueNames: boolean;
	bShowDetailedCompileResults: boolean;
	CompileEventDisplayThresholdMs: number;
	NodeTemplateCacheCapMB: number;
	bShowInheritedVariables: boolean;
	bAlwaysShowInterfacesInOverrides: boolean;
	bShowParentClassInOverrides: boolean;
	bShowEmptySections: boolean;
	bShowAccessSpecifier: boolean;
	Bookmarks: any;
	BookmarkNodes: BPEditorBookmarkNode[];
	PerBlueprintSettings: any;
	bIncludeCommentNodesInBookmarksTab: boolean;
	bShowBookmarksForCurrentDocumentOnlyInTab: boolean;
	GraphEditorQuickJumps: any;
	BaseClassesToAllowRecompilingDuringPlayInEditor: Class[];
	static Load(ResourceName: string): BlueprintEditorSettings;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorSettings;
	static GetDefaultObject(): BlueprintEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorSettings;
	static C(Other: UObject | any): BlueprintEditorSettings;
}

declare class BlueprintFunctionNodeSpawner extends BlueprintFieldNodeSpawner { 
	static Load(ResourceName: string): BlueprintFunctionNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintFunctionNodeSpawner;
	static GetDefaultObject(): BlueprintFunctionNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintFunctionNodeSpawner;
	static C(Other: UObject | any): BlueprintFunctionNodeSpawner;
}

declare class BlueprintVariableNodeSpawner extends BlueprintFieldNodeSpawner { 
	LocalVarOuter: EdGraph;
	LocalVarDesc: BPVariableDescription;
	static Load(ResourceName: string): BlueprintVariableNodeSpawner;
	static Find(Outer: UObject, ResourceName: string): BlueprintVariableNodeSpawner;
	static GetDefaultObject(): BlueprintVariableNodeSpawner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintVariableNodeSpawner;
	static C(Other: UObject | any): BlueprintVariableNodeSpawner;
}

declare class BlueprintCallableFunctionRedirect { 
	ClassName: string;
	OldFunctionName: string;
	NewFunctionName: string;
	BlueprintParamName: string;
	ClassParamName: string;
	clone() : BlueprintCallableFunctionRedirect;
	static C(Other: UObject | any): BlueprintCallableFunctionRedirect;
}

declare class EdGraphSchema_K2 extends EdGraphSchema { 
	EditoronlyBPFunctionRedirects: BlueprintCallableFunctionRedirect[];
	static Load(ResourceName: string): EdGraphSchema_K2;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_K2;
	static GetDefaultObject(): EdGraphSchema_K2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_K2;
	static C(Other: UObject | any): EdGraphSchema_K2;
}

declare class K2Node_ActorBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	EventOwner: Actor;
	static Load(ResourceName: string): K2Node_ActorBoundEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_ActorBoundEvent;
	static GetDefaultObject(): K2Node_ActorBoundEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ActorBoundEvent;
	static C(Other: UObject | any): K2Node_ActorBoundEvent;
}

declare class K2Node_CallFunction extends K2Node { 
	bIsPureFunc: boolean;
	bIsConstFunc: boolean;
	bWantsEnumToExecExpansion: boolean;
	bIsInterfaceCall: boolean;
	bIsFinalFunction: boolean;
	bIsBeadFunction: boolean;
	FunctionReference: MemberReference;
	CallFunctionName: string;
	CallFunctionClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_CallFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallFunction;
	static GetDefaultObject(): K2Node_CallFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunction;
	static C(Other: UObject | any): K2Node_CallFunction;
}

declare class K2Node_AddComponent extends K2Node_CallFunction { 
	bHasExposedVariable: boolean;
	TemplateBlueprint: string;
	TemplateType: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_AddComponent;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddComponent;
	static GetDefaultObject(): K2Node_AddComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddComponent;
	static C(Other: UObject | any): K2Node_AddComponent;
}

declare class K2Node_ConstructObjectFromClass extends K2Node { 
	static Load(ResourceName: string): K2Node_ConstructObjectFromClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_ConstructObjectFromClass;
	static GetDefaultObject(): K2Node_ConstructObjectFromClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConstructObjectFromClass;
	static C(Other: UObject | any): K2Node_ConstructObjectFromClass;
}

declare class K2Node_AddComponentByClass extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_AddComponentByClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddComponentByClass;
	static GetDefaultObject(): K2Node_AddComponentByClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddComponentByClass;
	static C(Other: UObject | any): K2Node_AddComponentByClass;
}

declare class K2Node_BaseMCDelegate extends K2Node { 
	DelegateReference: MemberReference;
	static Load(ResourceName: string): K2Node_BaseMCDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_BaseMCDelegate;
	static GetDefaultObject(): K2Node_BaseMCDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseMCDelegate;
	static C(Other: UObject | any): K2Node_BaseMCDelegate;
}

declare class K2Node_AddDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_AddDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddDelegate;
	static GetDefaultObject(): K2Node_AddDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddDelegate;
	static C(Other: UObject | any): K2Node_AddDelegate;
}

declare class K2Node_AddPinInterface extends Interface { 
	static Load(ResourceName: string): K2Node_AddPinInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_AddPinInterface;
	static GetDefaultObject(): K2Node_AddPinInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AddPinInterface;
	static C(Other: UObject | any): K2Node_AddPinInterface;
}

declare class K2Node_AssignDelegate extends K2Node_AddDelegate { 
	static Load(ResourceName: string): K2Node_AssignDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_AssignDelegate;
	static GetDefaultObject(): K2Node_AssignDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignDelegate;
	static C(Other: UObject | any): K2Node_AssignDelegate;
}

declare class K2Node_AssignmentStatement extends K2Node { 
	static Load(ResourceName: string): K2Node_AssignmentStatement;
	static Find(Outer: UObject, ResourceName: string): K2Node_AssignmentStatement;
	static GetDefaultObject(): K2Node_AssignmentStatement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AssignmentStatement;
	static C(Other: UObject | any): K2Node_AssignmentStatement;
}

declare class K2Node_BaseAsyncTask extends K2Node { 
	ProxyFactoryFunctionName: string;
	ProxyFactoryClass: UnrealEngineClass;
	ProxyClass: UnrealEngineClass;
	ProxyActivateFunctionName: string;
	static Load(ResourceName: string): K2Node_BaseAsyncTask;
	static Find(Outer: UObject, ResourceName: string): K2Node_BaseAsyncTask;
	static GetDefaultObject(): K2Node_BaseAsyncTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BaseAsyncTask;
	static C(Other: UObject | any): K2Node_BaseAsyncTask;
}

declare class K2Node_AsyncAction extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_AsyncAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_AsyncAction;
	static GetDefaultObject(): K2Node_AsyncAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AsyncAction;
	static C(Other: UObject | any): K2Node_AsyncAction;
}

declare class K2Node_BitmaskLiteral extends K2Node { 
	BitflagsEnum: Enum;
	static Load(ResourceName: string): K2Node_BitmaskLiteral;
	static Find(Outer: UObject, ResourceName: string): K2Node_BitmaskLiteral;
	static GetDefaultObject(): K2Node_BitmaskLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BitmaskLiteral;
	static C(Other: UObject | any): K2Node_BitmaskLiteral;
}

declare type ESelfContextInfo = 'Unspecified' | 'NotSelfContext' | 'ESelfContextInfo_MAX';
declare var ESelfContextInfo : { Unspecified:'Unspecified',NotSelfContext:'NotSelfContext',ESelfContextInfo_MAX:'ESelfContextInfo_MAX', };
declare class K2Node_Variable extends K2Node { 
	VariableReference: MemberReference;
	SelfContextInfo: ESelfContextInfo;
	VariableSourceClass: UnrealEngineClass;
	VariableName: string;
	bSelfContext: boolean;
	static Load(ResourceName: string): K2Node_Variable;
	static Find(Outer: UObject, ResourceName: string): K2Node_Variable;
	static GetDefaultObject(): K2Node_Variable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Variable;
	static C(Other: UObject | any): K2Node_Variable;
}

declare class K2Node_StructOperation extends K2Node_Variable { 
	StructType: ScriptStruct;
	static Load(ResourceName: string): K2Node_StructOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructOperation;
	static GetDefaultObject(): K2Node_StructOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructOperation;
	static C(Other: UObject | any): K2Node_StructOperation;
}

declare class K2Node_StructMemberGet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): K2Node_StructMemberGet;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructMemberGet;
	static GetDefaultObject(): K2Node_StructMemberGet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberGet;
	static C(Other: UObject | any): K2Node_StructMemberGet;
}

declare class K2Node_BreakStruct extends K2Node_StructMemberGet { 
	bMadeAfterOverridePinRemoval: boolean;
	static Load(ResourceName: string): K2Node_BreakStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_BreakStruct;
	static GetDefaultObject(): K2Node_BreakStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_BreakStruct;
	static C(Other: UObject | any): K2Node_BreakStruct;
}

declare class K2Node_CallArrayFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallArrayFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallArrayFunction;
	static GetDefaultObject(): K2Node_CallArrayFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallArrayFunction;
	static C(Other: UObject | any): K2Node_CallArrayFunction;
}

declare class K2Node_CallDataTableFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallDataTableFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallDataTableFunction;
	static GetDefaultObject(): K2Node_CallDataTableFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDataTableFunction;
	static C(Other: UObject | any): K2Node_CallDataTableFunction;
}

declare class K2Node_CallDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_CallDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallDelegate;
	static GetDefaultObject(): K2Node_CallDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallDelegate;
	static C(Other: UObject | any): K2Node_CallDelegate;
}

declare class K2Node_CallFunctionOnMember extends K2Node_CallFunction { 
	MemberVariableToCallOn: MemberReference;
	static Load(ResourceName: string): K2Node_CallFunctionOnMember;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallFunctionOnMember;
	static GetDefaultObject(): K2Node_CallFunctionOnMember;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallFunctionOnMember;
	static C(Other: UObject | any): K2Node_CallFunctionOnMember;
}

declare class K2Node_CallMaterialParameterCollectionFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallMaterialParameterCollectionFunction;
	static GetDefaultObject(): K2Node_CallMaterialParameterCollectionFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallMaterialParameterCollectionFunction;
	static C(Other: UObject | any): K2Node_CallMaterialParameterCollectionFunction;
}

declare class K2Node_CallParentFunction extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_CallParentFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_CallParentFunction;
	static GetDefaultObject(): K2Node_CallParentFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CallParentFunction;
	static C(Other: UObject | any): K2Node_CallParentFunction;
}

declare class K2Node_CastByteToEnum extends K2Node { 
	Enum: Enum;
	bSafe: boolean;
	static Load(ResourceName: string): K2Node_CastByteToEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_CastByteToEnum;
	static GetDefaultObject(): K2Node_CastByteToEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CastByteToEnum;
	static C(Other: UObject | any): K2Node_CastByteToEnum;
}

declare class K2Node_DynamicCast extends K2Node { 
	TargetType: UnrealEngineClass;
	bIsPureCast: boolean;
	static Load(ResourceName: string): K2Node_DynamicCast;
	static Find(Outer: UObject, ResourceName: string): K2Node_DynamicCast;
	static GetDefaultObject(): K2Node_DynamicCast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DynamicCast;
	static C(Other: UObject | any): K2Node_DynamicCast;
}

declare class K2Node_ClassDynamicCast extends K2Node_DynamicCast { 
	static Load(ResourceName: string): K2Node_ClassDynamicCast;
	static Find(Outer: UObject, ResourceName: string): K2Node_ClassDynamicCast;
	static GetDefaultObject(): K2Node_ClassDynamicCast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClassDynamicCast;
	static C(Other: UObject | any): K2Node_ClassDynamicCast;
}

declare class K2Node_ClearDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_ClearDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_ClearDelegate;
	static GetDefaultObject(): K2Node_ClearDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ClearDelegate;
	static C(Other: UObject | any): K2Node_ClearDelegate;
}

declare class K2Node_CommutativeAssociativeBinaryOperator extends K2Node_CallFunction { 
	NumAdditionalInputs: number;
	static Load(ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static Find(Outer: UObject, ResourceName: string): K2Node_CommutativeAssociativeBinaryOperator;
	static GetDefaultObject(): K2Node_CommutativeAssociativeBinaryOperator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CommutativeAssociativeBinaryOperator;
	static C(Other: UObject | any): K2Node_CommutativeAssociativeBinaryOperator;
}

declare class K2Node_ComponentBoundEvent extends K2Node_Event { 
	DelegatePropertyName: string;
	DelegateOwnerClass: UnrealEngineClass;
	ComponentPropertyName: string;
	DelegatePropertyDisplayName: string;
	static Load(ResourceName: string): K2Node_ComponentBoundEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_ComponentBoundEvent;
	static GetDefaultObject(): K2Node_ComponentBoundEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ComponentBoundEvent;
	static C(Other: UObject | any): K2Node_ComponentBoundEvent;
}

declare class K2Node_Tunnel extends K2Node_EditablePinBase { 
	OutputSourceNode: K2Node_Tunnel;
	InputSinkNode: K2Node_Tunnel;
	bCanHaveInputs: boolean;
	bCanHaveOutputs: boolean;
	MetaData: KismetUserDeclaredFunctionMetadata;
	static Load(ResourceName: string): K2Node_Tunnel;
	static Find(Outer: UObject, ResourceName: string): K2Node_Tunnel;
	static GetDefaultObject(): K2Node_Tunnel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Tunnel;
	static C(Other: UObject | any): K2Node_Tunnel;
}

declare class K2Node_Composite extends K2Node_Tunnel { 
	BoundGraph: EdGraph;
	static Load(ResourceName: string): K2Node_Composite;
	static Find(Outer: UObject, ResourceName: string): K2Node_Composite;
	static GetDefaultObject(): K2Node_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Composite;
	static C(Other: UObject | any): K2Node_Composite;
}

declare class K2Node_ConvertAsset extends K2Node { 
	static Load(ResourceName: string): K2Node_ConvertAsset;
	static Find(Outer: UObject, ResourceName: string): K2Node_ConvertAsset;
	static GetDefaultObject(): K2Node_ConvertAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ConvertAsset;
	static C(Other: UObject | any): K2Node_ConvertAsset;
}

declare class K2Node_Copy extends K2Node { 
	static Load(ResourceName: string): K2Node_Copy;
	static Find(Outer: UObject, ResourceName: string): K2Node_Copy;
	static GetDefaultObject(): K2Node_Copy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Copy;
	static C(Other: UObject | any): K2Node_Copy;
}

declare class K2Node_CreateDelegate extends K2Node { 
	SelectedFunctionName: string;
	SelectedFunctionGuid: Guid;
	static Load(ResourceName: string): K2Node_CreateDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDelegate;
	static GetDefaultObject(): K2Node_CreateDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDelegate;
	static C(Other: UObject | any): K2Node_CreateDelegate;
}

declare class K2Node_DeadClass extends K2Node { 
	static Load(ResourceName: string): K2Node_DeadClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_DeadClass;
	static GetDefaultObject(): K2Node_DeadClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DeadClass;
	static C(Other: UObject | any): K2Node_DeadClass;
}

declare class K2Node_DelegateSet extends K2Node { 
	DelegatePropertyName: string;
	DelegatePropertyClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_DelegateSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_DelegateSet;
	static GetDefaultObject(): K2Node_DelegateSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DelegateSet;
	static C(Other: UObject | any): K2Node_DelegateSet;
}

declare class K2Node_TemporaryVariable extends K2Node { 
	VariableType: EdGraphPinType;
	bIsPersistent: boolean;
	static Load(ResourceName: string): K2Node_TemporaryVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_TemporaryVariable;
	static GetDefaultObject(): K2Node_TemporaryVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TemporaryVariable;
	static C(Other: UObject | any): K2Node_TemporaryVariable;
}

declare class K2Node_DoOnceMultiInput extends K2Node { 
	NumAdditionalInputs: number;
	DataNode: K2Node_TemporaryVariable;
	static Load(ResourceName: string): K2Node_DoOnceMultiInput;
	static Find(Outer: UObject, ResourceName: string): K2Node_DoOnceMultiInput;
	static GetDefaultObject(): K2Node_DoOnceMultiInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_DoOnceMultiInput;
	static C(Other: UObject | any): K2Node_DoOnceMultiInput;
}

declare class K2Node_EaseFunction extends K2Node { 
	EaseFunctionName: string;
	static Load(ResourceName: string): K2Node_EaseFunction;
	static Find(Outer: UObject, ResourceName: string): K2Node_EaseFunction;
	static GetDefaultObject(): K2Node_EaseFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EaseFunction;
	static C(Other: UObject | any): K2Node_EaseFunction;
}

declare class K2Node_EditorPropertyAccessBase extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_EditorPropertyAccessBase;
	static Find(Outer: UObject, ResourceName: string): K2Node_EditorPropertyAccessBase;
	static GetDefaultObject(): K2Node_EditorPropertyAccessBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EditorPropertyAccessBase;
	static C(Other: UObject | any): K2Node_EditorPropertyAccessBase;
}

declare class K2Node_GetEditorProperty extends K2Node_EditorPropertyAccessBase { 
	static Load(ResourceName: string): K2Node_GetEditorProperty;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEditorProperty;
	static GetDefaultObject(): K2Node_GetEditorProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEditorProperty;
	static C(Other: UObject | any): K2Node_GetEditorProperty;
}

declare class K2Node_SetEditorProperty extends K2Node_EditorPropertyAccessBase { 
	static Load(ResourceName: string): K2Node_SetEditorProperty;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetEditorProperty;
	static GetDefaultObject(): K2Node_SetEditorProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetEditorProperty;
	static C(Other: UObject | any): K2Node_SetEditorProperty;
}

declare class K2Node_EnumEquality extends K2Node { 
	static Load(ResourceName: string): K2Node_EnumEquality;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumEquality;
	static GetDefaultObject(): K2Node_EnumEquality;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumEquality;
	static C(Other: UObject | any): K2Node_EnumEquality;
}

declare class K2Node_EnumInequality extends K2Node_EnumEquality { 
	static Load(ResourceName: string): K2Node_EnumInequality;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumInequality;
	static GetDefaultObject(): K2Node_EnumInequality;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumInequality;
	static C(Other: UObject | any): K2Node_EnumInequality;
}

declare class K2Node_EnumLiteral extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_EnumLiteral;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnumLiteral;
	static GetDefaultObject(): K2Node_EnumLiteral;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnumLiteral;
	static C(Other: UObject | any): K2Node_EnumLiteral;
}

declare class K2Node_EventNodeInterface extends Interface { 
	static Load(ResourceName: string): K2Node_EventNodeInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_EventNodeInterface;
	static GetDefaultObject(): K2Node_EventNodeInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EventNodeInterface;
	static C(Other: UObject | any): K2Node_EventNodeInterface;
}

declare class K2Node_ExecutionSequence extends K2Node { 
	static Load(ResourceName: string): K2Node_ExecutionSequence;
	static Find(Outer: UObject, ResourceName: string): K2Node_ExecutionSequence;
	static GetDefaultObject(): K2Node_ExecutionSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ExecutionSequence;
	static C(Other: UObject | any): K2Node_ExecutionSequence;
}

declare class K2Node_ExternalGraphInterface extends Interface { 
	static Load(ResourceName: string): K2Node_ExternalGraphInterface;
	static Find(Outer: UObject, ResourceName: string): K2Node_ExternalGraphInterface;
	static GetDefaultObject(): K2Node_ExternalGraphInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ExternalGraphInterface;
	static C(Other: UObject | any): K2Node_ExternalGraphInterface;
}

declare class K2Node_ForEachElementInEnum extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_ForEachElementInEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_ForEachElementInEnum;
	static GetDefaultObject(): K2Node_ForEachElementInEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_ForEachElementInEnum;
	static C(Other: UObject | any): K2Node_ForEachElementInEnum;
}

declare class K2Node_FormatText extends K2Node { 
	PinNames: string[];
	static Load(ResourceName: string): K2Node_FormatText;
	static Find(Outer: UObject, ResourceName: string): K2Node_FormatText;
	static GetDefaultObject(): K2Node_FormatText;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FormatText;
	static C(Other: UObject | any): K2Node_FormatText;
}

declare class K2Node_FunctionTerminator extends K2Node_EditablePinBase { 
	FunctionReference: MemberReference;
	SignatureClass: UnrealEngineClass;
	SignatureName: string;
	static Load(ResourceName: string): K2Node_FunctionTerminator;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionTerminator;
	static GetDefaultObject(): K2Node_FunctionTerminator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionTerminator;
	static C(Other: UObject | any): K2Node_FunctionTerminator;
}

declare class K2Node_FunctionEntry extends K2Node_FunctionTerminator { 
	CustomGeneratedFunctionName: string;
	MetaData: KismetUserDeclaredFunctionMetadata;
	LocalVariables: BPVariableDescription[];
	bEnforceConstCorrectness: boolean;
	ExtraFlags: number;
	static Load(ResourceName: string): K2Node_FunctionEntry;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionEntry;
	static GetDefaultObject(): K2Node_FunctionEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionEntry;
	static C(Other: UObject | any): K2Node_FunctionEntry;
}

declare class K2Node_FunctionResult extends K2Node_FunctionTerminator { 
	static Load(ResourceName: string): K2Node_FunctionResult;
	static Find(Outer: UObject, ResourceName: string): K2Node_FunctionResult;
	static GetDefaultObject(): K2Node_FunctionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_FunctionResult;
	static C(Other: UObject | any): K2Node_FunctionResult;
}

declare class K2Node_GenericCreateObject extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_GenericCreateObject;
	static Find(Outer: UObject, ResourceName: string): K2Node_GenericCreateObject;
	static GetDefaultObject(): K2Node_GenericCreateObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GenericCreateObject;
	static C(Other: UObject | any): K2Node_GenericCreateObject;
}

declare class K2Node_GetArrayItem extends K2Node { 
	bReturnByRefDesired: boolean;
	static Load(ResourceName: string): K2Node_GetArrayItem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetArrayItem;
	static GetDefaultObject(): K2Node_GetArrayItem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetArrayItem;
	static C(Other: UObject | any): K2Node_GetArrayItem;
}

declare class K2Node_GetClassDefaults extends K2Node { 
	BlueprintSubscribedTo: Blueprint;
	ShowPinForProperties: OptionalPinFromProperty[];
	bExcludeObjectContainers: boolean;
	bExcludeObjectArrays: boolean;
	static Load(ResourceName: string): K2Node_GetClassDefaults;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetClassDefaults;
	static GetDefaultObject(): K2Node_GetClassDefaults;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetClassDefaults;
	static C(Other: UObject | any): K2Node_GetClassDefaults;
}

declare class K2Node_GetDataTableRow extends K2Node { 
	static Load(ResourceName: string): K2Node_GetDataTableRow;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetDataTableRow;
	static GetDefaultObject(): K2Node_GetDataTableRow;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetDataTableRow;
	static C(Other: UObject | any): K2Node_GetDataTableRow;
}

declare class K2Node_GetEnumeratorName extends K2Node { 
	static Load(ResourceName: string): K2Node_GetEnumeratorName;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEnumeratorName;
	static GetDefaultObject(): K2Node_GetEnumeratorName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorName;
	static C(Other: UObject | any): K2Node_GetEnumeratorName;
}

declare class K2Node_GetEnumeratorNameAsString extends K2Node_GetEnumeratorName { 
	static Load(ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEnumeratorNameAsString;
	static GetDefaultObject(): K2Node_GetEnumeratorNameAsString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEnumeratorNameAsString;
	static C(Other: UObject | any): K2Node_GetEnumeratorNameAsString;
}

declare class K2Node_GetInputAxisKeyValue extends K2Node_CallFunction { 
	InputAxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_GetInputAxisKeyValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputAxisKeyValue;
	static GetDefaultObject(): K2Node_GetInputAxisKeyValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisKeyValue;
	static C(Other: UObject | any): K2Node_GetInputAxisKeyValue;
}

declare class K2Node_GetInputAxisValue extends K2Node_CallFunction { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_GetInputAxisValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputAxisValue;
	static GetDefaultObject(): K2Node_GetInputAxisValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputAxisValue;
	static C(Other: UObject | any): K2Node_GetInputAxisValue;
}

declare class K2Node_GetInputVectorAxisValue extends K2Node_GetInputAxisKeyValue { 
	static Load(ResourceName: string): K2Node_GetInputVectorAxisValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputVectorAxisValue;
	static GetDefaultObject(): K2Node_GetInputVectorAxisValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputVectorAxisValue;
	static C(Other: UObject | any): K2Node_GetInputVectorAxisValue;
}

declare class K2Node_GetNumEnumEntries extends K2Node { 
	Enum: Enum;
	static Load(ResourceName: string): K2Node_GetNumEnumEntries;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetNumEnumEntries;
	static GetDefaultObject(): K2Node_GetNumEnumEntries;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetNumEnumEntries;
	static C(Other: UObject | any): K2Node_GetNumEnumEntries;
}

declare class K2Node_GetSubsystem extends K2Node { 
	CustomClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_GetSubsystem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSubsystem;
	static GetDefaultObject(): K2Node_GetSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSubsystem;
	static C(Other: UObject | any): K2Node_GetSubsystem;
}

declare class K2Node_GetSubsystemFromPC extends K2Node_GetSubsystem { 
	static Load(ResourceName: string): K2Node_GetSubsystemFromPC;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetSubsystemFromPC;
	static GetDefaultObject(): K2Node_GetSubsystemFromPC;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetSubsystemFromPC;
	static C(Other: UObject | any): K2Node_GetSubsystemFromPC;
}

declare class K2Node_GetEngineSubsystem extends K2Node_GetSubsystem { 
	static Load(ResourceName: string): K2Node_GetEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEngineSubsystem;
	static GetDefaultObject(): K2Node_GetEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEngineSubsystem;
	static C(Other: UObject | any): K2Node_GetEngineSubsystem;
}

declare class K2Node_GetEditorSubsystem extends K2Node_GetSubsystem { 
	static Load(ResourceName: string): K2Node_GetEditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetEditorSubsystem;
	static GetDefaultObject(): K2Node_GetEditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetEditorSubsystem;
	static C(Other: UObject | any): K2Node_GetEditorSubsystem;
}

declare class K2Node_IfThenElse extends K2Node { 
	static Load(ResourceName: string): K2Node_IfThenElse;
	static Find(Outer: UObject, ResourceName: string): K2Node_IfThenElse;
	static GetDefaultObject(): K2Node_IfThenElse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_IfThenElse;
	static C(Other: UObject | any): K2Node_IfThenElse;
}

declare class K2Node_InputAction extends K2Node { 
	InputActionName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAction;
	static GetDefaultObject(): K2Node_InputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAction;
	static C(Other: UObject | any): K2Node_InputAction;
}

declare class K2Node_InputActionEvent extends K2Node_Event { 
	InputActionName: string;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputActionEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputActionEvent;
	static GetDefaultObject(): K2Node_InputActionEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputActionEvent;
	static C(Other: UObject | any): K2Node_InputActionEvent;
}

declare class K2Node_InputAxisEvent extends K2Node_Event { 
	InputAxisName: string;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAxisEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAxisEvent;
	static GetDefaultObject(): K2Node_InputAxisEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisEvent;
	static C(Other: UObject | any): K2Node_InputAxisEvent;
}

declare class K2Node_InputAxisKeyEvent extends K2Node_Event { 
	AxisKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputAxisKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputAxisKeyEvent;
	static GetDefaultObject(): K2Node_InputAxisKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputAxisKeyEvent;
	static C(Other: UObject | any): K2Node_InputAxisKeyEvent;
}

declare class K2Node_InputKey extends K2Node { 
	InputKey: Key;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	bControl: boolean;
	bAlt: boolean;
	bShift: boolean;
	bCommand: boolean;
	static Load(ResourceName: string): K2Node_InputKey;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputKey;
	static GetDefaultObject(): K2Node_InputKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKey;
	static C(Other: UObject | any): K2Node_InputKey;
}

declare class K2Node_InputKeyEvent extends K2Node_Event { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputKeyEvent;
	static GetDefaultObject(): K2Node_InputKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputKeyEvent;
	static C(Other: UObject | any): K2Node_InputKeyEvent;
}

declare class K2Node_InputTouch extends K2Node { 
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputTouch;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputTouch;
	static GetDefaultObject(): K2Node_InputTouch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouch;
	static C(Other: UObject | any): K2Node_InputTouch;
}

declare class K2Node_InputTouchEvent extends K2Node_Event { 
	InputKeyEvent: EInputEvent;
	bConsumeInput: boolean;
	bExecuteWhenPaused: boolean;
	bOverrideParentBinding: boolean;
	static Load(ResourceName: string): K2Node_InputTouchEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputTouchEvent;
	static GetDefaultObject(): K2Node_InputTouchEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputTouchEvent;
	static C(Other: UObject | any): K2Node_InputTouchEvent;
}

declare class K2Node_InputVectorAxisEvent extends K2Node_InputAxisKeyEvent { 
	static Load(ResourceName: string): K2Node_InputVectorAxisEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputVectorAxisEvent;
	static GetDefaultObject(): K2Node_InputVectorAxisEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputVectorAxisEvent;
	static C(Other: UObject | any): K2Node_InputVectorAxisEvent;
}

declare class K2Node_Knot extends K2Node { 
	static Load(ResourceName: string): K2Node_Knot;
	static Find(Outer: UObject, ResourceName: string): K2Node_Knot;
	static GetDefaultObject(): K2Node_Knot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Knot;
	static C(Other: UObject | any): K2Node_Knot;
}

declare class K2Node_Literal extends K2Node { 
	ObjectRef: UObject;
	static Load(ResourceName: string): K2Node_Literal;
	static Find(Outer: UObject, ResourceName: string): K2Node_Literal;
	static GetDefaultObject(): K2Node_Literal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Literal;
	static C(Other: UObject | any): K2Node_Literal;
}

declare class K2Node_LoadAsset extends K2Node { 
	static Load(ResourceName: string): K2Node_LoadAsset;
	static Find(Outer: UObject, ResourceName: string): K2Node_LoadAsset;
	static GetDefaultObject(): K2Node_LoadAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAsset;
	static C(Other: UObject | any): K2Node_LoadAsset;
}

declare class K2Node_LoadAssetClass extends K2Node_LoadAsset { 
	static Load(ResourceName: string): K2Node_LoadAssetClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_LoadAssetClass;
	static GetDefaultObject(): K2Node_LoadAssetClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LoadAssetClass;
	static C(Other: UObject | any): K2Node_LoadAssetClass;
}

declare class K2Node_LocalVariable extends K2Node_TemporaryVariable { 
	CustomVariableName: string;
	VariableTooltip: string;
	static Load(ResourceName: string): K2Node_LocalVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_LocalVariable;
	static GetDefaultObject(): K2Node_LocalVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LocalVariable;
	static C(Other: UObject | any): K2Node_LocalVariable;
}

declare class GraphReference { 
	MacroGraph: EdGraph;
	GraphBlueprint: Blueprint;
	GraphGuid: Guid;
	clone() : GraphReference;
	static C(Other: UObject | any): GraphReference;
}

declare class K2Node_MacroInstance extends K2Node_Tunnel { 
	MacroGraph: EdGraph;
	MacroGraphReference: GraphReference;
	ResolvedWildcardType: EdGraphPinType;
	static Load(ResourceName: string): K2Node_MacroInstance;
	static Find(Outer: UObject, ResourceName: string): K2Node_MacroInstance;
	static GetDefaultObject(): K2Node_MacroInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MacroInstance;
	static C(Other: UObject | any): K2Node_MacroInstance;
}

declare class K2Node_MakeContainer extends K2Node { 
	NumInputs: number;
	static Load(ResourceName: string): K2Node_MakeContainer;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeContainer;
	static GetDefaultObject(): K2Node_MakeContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeContainer;
	static C(Other: UObject | any): K2Node_MakeContainer;
}

declare class K2Node_MakeArray extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeArray;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeArray;
	static GetDefaultObject(): K2Node_MakeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeArray;
	static C(Other: UObject | any): K2Node_MakeArray;
}

declare class K2Node_MakeMap extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeMap;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeMap;
	static GetDefaultObject(): K2Node_MakeMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeMap;
	static C(Other: UObject | any): K2Node_MakeMap;
}

declare class K2Node_MakeSet extends K2Node_MakeContainer { 
	static Load(ResourceName: string): K2Node_MakeSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeSet;
	static GetDefaultObject(): K2Node_MakeSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeSet;
	static C(Other: UObject | any): K2Node_MakeSet;
}

declare class K2Node_StructMemberSet extends K2Node_StructOperation { 
	ShowPinForProperties: OptionalPinFromProperty[];
	static Load(ResourceName: string): K2Node_StructMemberSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_StructMemberSet;
	static GetDefaultObject(): K2Node_StructMemberSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_StructMemberSet;
	static C(Other: UObject | any): K2Node_StructMemberSet;
}

declare class K2Node_MakeStruct extends K2Node_StructMemberSet { 
	bMadeAfterOverridePinRemoval: boolean;
	static Load(ResourceName: string): K2Node_MakeStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeStruct;
	static GetDefaultObject(): K2Node_MakeStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeStruct;
	static C(Other: UObject | any): K2Node_MakeStruct;
}

declare class K2Node_MakeVariable extends K2Node { 
	VariableType: BPVariableDescription;
	static Load(ResourceName: string): K2Node_MakeVariable;
	static Find(Outer: UObject, ResourceName: string): K2Node_MakeVariable;
	static GetDefaultObject(): K2Node_MakeVariable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MakeVariable;
	static C(Other: UObject | any): K2Node_MakeVariable;
}

declare class K2Node_MathExpression extends K2Node_Composite { 
	Expression: string;
	bMadeAfterRotChange: boolean;
	static Load(ResourceName: string): K2Node_MathExpression;
	static Find(Outer: UObject, ResourceName: string): K2Node_MathExpression;
	static GetDefaultObject(): K2Node_MathExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MathExpression;
	static C(Other: UObject | any): K2Node_MathExpression;
}

declare class InterpFilter extends UObject { 
	Caption: string;
	static Load(ResourceName: string): InterpFilter;
	static Find(Outer: UObject, ResourceName: string): InterpFilter;
	static GetDefaultObject(): InterpFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter;
	static C(Other: UObject | any): InterpFilter;
}

declare class InterpGroupDirector extends InterpGroup { 
	static Load(ResourceName: string): InterpGroupDirector;
	static Find(Outer: UObject, ResourceName: string): InterpGroupDirector;
	static GetDefaultObject(): InterpGroupDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupDirector;
	static C(Other: UObject | any): InterpGroupDirector;
}

declare class InterpData extends UObject { 
	InterpLength: number;
	PathBuildTime: number;
	InterpGroups: InterpGroup[];
	CurveEdSetup: InterpCurveEdSetup;
	InterpFilters: InterpFilter[];
	SelectedFilter: InterpFilter;
	DefaultFilters: InterpFilter[];
	EdSectionStart: number;
	EdSectionEnd: number;
	bShouldBakeAndPrune: boolean;
	CachedDirectorGroup: InterpGroupDirector;
	AllEventNames: string[];
	static Load(ResourceName: string): InterpData;
	static Find(Outer: UObject, ResourceName: string): InterpData;
	static GetDefaultObject(): InterpData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpData;
	static C(Other: UObject | any): InterpData;
}

declare class InterpGroupActorInfo { 
	ObjectName: string;
	Actors: Actor[];
	clone() : InterpGroupActorInfo;
	static C(Other: UObject | any): InterpGroupActorInfo;
}

declare class CameraCutInfo { 
	Location: Vector;
	Timestamp: number;
	clone() : CameraCutInfo;
	static C(Other: UObject | any): CameraCutInfo;
}

declare class MatineeActor extends Actor { 
	MatineeData: InterpData;
	MatineeControllerName: string;
	PlayRate: number;
	bPlayOnLevelLoad: boolean;
	bForceStartPos: boolean;
	ForceStartPosition: number;
	bLooping: boolean;
	bRewindOnPlay: boolean;
	bNoResetOnRewind: boolean;
	bRewindIfAlreadyPlaying: boolean;
	bDisableRadioFilter: boolean;
	bClientSideOnly: boolean;
	bSkipUpdateIfNotVisible: boolean;
	bIsSkippable: boolean;
	PreferredSplitScreenNum: number;
	bDisableMovementInput: boolean;
	bDisableLookAtInput: boolean;
	bHidePlayer: boolean;
	bHideHud: boolean;
	GroupActorInfos: InterpGroupActorInfo[];
	bShouldShowGore: boolean;
	GroupInst: InterpGroupInst[];
	CameraCuts: CameraCutInfo[];
	SpriteComponent: BillboardComponent;
	bIsBeingEdited: boolean;
	bIsScrubbing: boolean;
	bIsPlaying: boolean;
	bReversePlayback: boolean;
	bPaused: boolean;
	bPendingStop: boolean;
	InterpPosition: number;
	ReplicationForceIsPlaying: number;
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	static GetDefaultObject(): MatineeActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActor;
	Stop(): void;
	SetPosition(NewPosition: number,bJump: boolean): void;
	SetLoopingState(bNewLooping: boolean): void;
	Reverse(): void;
	Play(): void;
	Pause(): void;
	EnableGroupByName(GroupName: string,bEnable: boolean): void;
	ChangePlaybackDirection(): void;
	static C(Other: UObject | any): MatineeActor;
}

declare class K2Node_MatineeController extends K2Node { 
	MatineeActor: MatineeActor;
	static Load(ResourceName: string): K2Node_MatineeController;
	static Find(Outer: UObject, ResourceName: string): K2Node_MatineeController;
	static GetDefaultObject(): K2Node_MatineeController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MatineeController;
	static C(Other: UObject | any): K2Node_MatineeController;
}

declare class K2Node_Message extends K2Node_CallFunction { 
	static Load(ResourceName: string): K2Node_Message;
	static Find(Outer: UObject, ResourceName: string): K2Node_Message;
	static GetDefaultObject(): K2Node_Message;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Message;
	static C(Other: UObject | any): K2Node_Message;
}

declare class K2Node_MultiGate extends K2Node_ExecutionSequence { 
	DataNode: K2Node_TemporaryVariable;
	static Load(ResourceName: string): K2Node_MultiGate;
	static Find(Outer: UObject, ResourceName: string): K2Node_MultiGate;
	static GetDefaultObject(): K2Node_MultiGate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_MultiGate;
	static C(Other: UObject | any): K2Node_MultiGate;
}

declare class K2Node_PromotableOperator extends K2Node_CallFunction { 
	NumAdditionalInputs: number;
	static Load(ResourceName: string): K2Node_PromotableOperator;
	static Find(Outer: UObject, ResourceName: string): K2Node_PromotableOperator;
	static GetDefaultObject(): K2Node_PromotableOperator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PromotableOperator;
	static C(Other: UObject | any): K2Node_PromotableOperator;
}

declare class K2Node_PureAssignmentStatement extends K2Node { 
	static Load(ResourceName: string): K2Node_PureAssignmentStatement;
	static Find(Outer: UObject, ResourceName: string): K2Node_PureAssignmentStatement;
	static GetDefaultObject(): K2Node_PureAssignmentStatement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PureAssignmentStatement;
	static C(Other: UObject | any): K2Node_PureAssignmentStatement;
}

declare class K2Node_RemoveDelegate extends K2Node_BaseMCDelegate { 
	static Load(ResourceName: string): K2Node_RemoveDelegate;
	static Find(Outer: UObject, ResourceName: string): K2Node_RemoveDelegate;
	static GetDefaultObject(): K2Node_RemoveDelegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_RemoveDelegate;
	static C(Other: UObject | any): K2Node_RemoveDelegate;
}

declare class K2Node_Select extends K2Node { 
	NumOptionPins: number;
	IndexPinType: EdGraphPinType;
	Enum: Enum;
	EnumEntries: string[];
	EnumEntryFriendlyNames: string[];
	bReconstructNode: boolean;
	static Load(ResourceName: string): K2Node_Select;
	static Find(Outer: UObject, ResourceName: string): K2Node_Select;
	static GetDefaultObject(): K2Node_Select;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Select;
	static C(Other: UObject | any): K2Node_Select;
}

declare class K2Node_Self extends K2Node { 
	static Load(ResourceName: string): K2Node_Self;
	static Find(Outer: UObject, ResourceName: string): K2Node_Self;
	static GetDefaultObject(): K2Node_Self;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Self;
	static C(Other: UObject | any): K2Node_Self;
}

declare class K2Node_SetFieldsInStruct extends K2Node_MakeStruct { 
	static Load(ResourceName: string): K2Node_SetFieldsInStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetFieldsInStruct;
	static GetDefaultObject(): K2Node_SetFieldsInStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetFieldsInStruct;
	static C(Other: UObject | any): K2Node_SetFieldsInStruct;
}

declare class K2Node_SetVariableOnPersistentFrame extends K2Node { 
	static Load(ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static Find(Outer: UObject, ResourceName: string): K2Node_SetVariableOnPersistentFrame;
	static GetDefaultObject(): K2Node_SetVariableOnPersistentFrame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SetVariableOnPersistentFrame;
	static C(Other: UObject | any): K2Node_SetVariableOnPersistentFrame;
}

declare class K2Node_SpawnActor extends K2Node { 
	static Load(ResourceName: string): K2Node_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): K2Node_SpawnActor;
	static GetDefaultObject(): K2Node_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActor;
	static C(Other: UObject | any): K2Node_SpawnActor;
}

declare class K2Node_SpawnActorFromClass extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_SpawnActorFromClass;
	static Find(Outer: UObject, ResourceName: string): K2Node_SpawnActorFromClass;
	static GetDefaultObject(): K2Node_SpawnActorFromClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SpawnActorFromClass;
	static C(Other: UObject | any): K2Node_SpawnActorFromClass;
}

declare class K2Node_Switch extends K2Node { 
	bHasDefaultPin: boolean;
	FunctionName: string;
	FunctionClass: UnrealEngineClass;
	static Load(ResourceName: string): K2Node_Switch;
	static Find(Outer: UObject, ResourceName: string): K2Node_Switch;
	static GetDefaultObject(): K2Node_Switch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Switch;
	static C(Other: UObject | any): K2Node_Switch;
}

declare class K2Node_SwitchEnum extends K2Node_Switch { 
	Enum: Enum;
	EnumEntries: string[];
	EnumFriendlyNames: string[];
	static Load(ResourceName: string): K2Node_SwitchEnum;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchEnum;
	static GetDefaultObject(): K2Node_SwitchEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchEnum;
	static C(Other: UObject | any): K2Node_SwitchEnum;
}

declare class K2Node_SwitchInteger extends K2Node_Switch { 
	StartIndex: number;
	static Load(ResourceName: string): K2Node_SwitchInteger;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchInteger;
	static GetDefaultObject(): K2Node_SwitchInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchInteger;
	static C(Other: UObject | any): K2Node_SwitchInteger;
}

declare class K2Node_SwitchName extends K2Node_Switch { 
	PinNames: string[];
	static Load(ResourceName: string): K2Node_SwitchName;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchName;
	static GetDefaultObject(): K2Node_SwitchName;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchName;
	static C(Other: UObject | any): K2Node_SwitchName;
}

declare class K2Node_SwitchString extends K2Node_Switch { 
	PinNames: string[];
	bIsCaseSensitive: boolean;
	static Load(ResourceName: string): K2Node_SwitchString;
	static Find(Outer: UObject, ResourceName: string): K2Node_SwitchString;
	static GetDefaultObject(): K2Node_SwitchString;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_SwitchString;
	static C(Other: UObject | any): K2Node_SwitchString;
}

declare class K2Node_Timeline extends K2Node { 
	TimelineName: string;
	bAutoPlay: boolean;
	TimelineGuid: Guid;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): K2Node_Timeline;
	static Find(Outer: UObject, ResourceName: string): K2Node_Timeline;
	static GetDefaultObject(): K2Node_Timeline;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Timeline;
	static C(Other: UObject | any): K2Node_Timeline;
}

declare type ETunnelBoundaryType = 'Unknown' | 'EntrySite' | 'InputSite' | 'OutputSite' | 'ETunnelBoundaryType_MAX';
declare var ETunnelBoundaryType : { Unknown:'Unknown',EntrySite:'EntrySite',InputSite:'InputSite',OutputSite:'OutputSite',ETunnelBoundaryType_MAX:'ETunnelBoundaryType_MAX', };
declare class K2Node_TunnelBoundary extends K2Node { 
	BaseName: string;
	TunnelBoundaryType: ETunnelBoundaryType;
	static Load(ResourceName: string): K2Node_TunnelBoundary;
	static Find(Outer: UObject, ResourceName: string): K2Node_TunnelBoundary;
	static GetDefaultObject(): K2Node_TunnelBoundary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_TunnelBoundary;
	static C(Other: UObject | any): K2Node_TunnelBoundary;
}

declare class K2Node_VariableGet extends K2Node_Variable { 
	bIsPureGet: boolean;
	static Load(ResourceName: string): K2Node_VariableGet;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableGet;
	static GetDefaultObject(): K2Node_VariableGet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableGet;
	static C(Other: UObject | any): K2Node_VariableGet;
}

declare class K2Node_VariableSet extends K2Node_Variable { 
	static Load(ResourceName: string): K2Node_VariableSet;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableSet;
	static GetDefaultObject(): K2Node_VariableSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSet;
	static C(Other: UObject | any): K2Node_VariableSet;
}

declare class K2Node_VariableSetRef extends K2Node { 
	static Load(ResourceName: string): K2Node_VariableSetRef;
	static Find(Outer: UObject, ResourceName: string): K2Node_VariableSetRef;
	static GetDefaultObject(): K2Node_VariableSetRef;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_VariableSetRef;
	static C(Other: UObject | any): K2Node_VariableSetRef;
}

declare class NodeDependingOnEnumInterface extends Interface { 
	static Load(ResourceName: string): NodeDependingOnEnumInterface;
	static Find(Outer: UObject, ResourceName: string): NodeDependingOnEnumInterface;
	static GetDefaultObject(): NodeDependingOnEnumInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeDependingOnEnumInterface;
	static C(Other: UObject | any): NodeDependingOnEnumInterface;
}

declare class PinTypeSelectorFilter extends UObject { 
	FilterClass: Class;
	static Load(ResourceName: string): PinTypeSelectorFilter;
	static Find(Outer: UObject, ResourceName: string): PinTypeSelectorFilter;
	static GetDefaultObject(): PinTypeSelectorFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PinTypeSelectorFilter;
	static C(Other: UObject | any): PinTypeSelectorFilter;
}

declare class BlueprintCompilerExtension extends UObject { 
	static Load(ResourceName: string): BlueprintCompilerExtension;
	static Find(Outer: UObject, ResourceName: string): BlueprintCompilerExtension;
	static GetDefaultObject(): BlueprintCompilerExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintCompilerExtension;
	static C(Other: UObject | any): BlueprintCompilerExtension;
}

declare class BlueprintEditorToolMenuContext extends UObject { 
	static Load(ResourceName: string): BlueprintEditorToolMenuContext;
	static Find(Outer: UObject, ResourceName: string): BlueprintEditorToolMenuContext;
	static GetDefaultObject(): BlueprintEditorToolMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintEditorToolMenuContext;
	GetBlueprintObj(): Blueprint;
	static C(Other: UObject | any): BlueprintEditorToolMenuContext;
}

declare class FavoritedBlueprintPaletteItem { 
	clone() : FavoritedBlueprintPaletteItem;
	static C(Other: UObject | any): FavoritedBlueprintPaletteItem;
}

declare class BlueprintPaletteFavorites extends UObject { 
	CustomFavorites: string[];
	CurrentFavorites: FavoritedBlueprintPaletteItem[];
	CurrentProfile: string;
	static Load(ResourceName: string): BlueprintPaletteFavorites;
	static Find(Outer: UObject, ResourceName: string): BlueprintPaletteFavorites;
	static GetDefaultObject(): BlueprintPaletteFavorites;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintPaletteFavorites;
	static C(Other: UObject | any): BlueprintPaletteFavorites;
}

declare class SCSEditorExtensionContext extends UObject { 
	static Load(ResourceName: string): SCSEditorExtensionContext;
	static Find(Outer: UObject, ResourceName: string): SCSEditorExtensionContext;
	static GetDefaultObject(): SCSEditorExtensionContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCSEditorExtensionContext;
	static C(Other: UObject | any): SCSEditorExtensionContext;
}

declare class SSCSEditorMenuContext extends UObject { 
	static Load(ResourceName: string): SSCSEditorMenuContext;
	static Find(Outer: UObject, ResourceName: string): SSCSEditorMenuContext;
	static GetDefaultObject(): SSCSEditorMenuContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SSCSEditorMenuContext;
	static C(Other: UObject | any): SSCSEditorMenuContext;
}

declare class SubobjectEditorExtensionContext extends UObject { 
	static Load(ResourceName: string): SubobjectEditorExtensionContext;
	static Find(Outer: UObject, ResourceName: string): SubobjectEditorExtensionContext;
	static GetDefaultObject(): SubobjectEditorExtensionContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubobjectEditorExtensionContext;
	static C(Other: UObject | any): SubobjectEditorExtensionContext;
}

declare type EBlueprintPinStyleType = 'BPST_Original' | 'BPST_VariantA' | 'BPST_MAX';
declare var EBlueprintPinStyleType : { BPST_Original:'BPST_Original',BPST_VariantA:'BPST_VariantA',BPST_MAX:'BPST_MAX', };
declare type EGraphPanningMouseButton = 'Right' | 'Middle' | 'Both' | 'EGraphPanningMouseButton_MAX';
declare var EGraphPanningMouseButton : { Right:'Right',Middle:'Middle',Both:'Both',EGraphPanningMouseButton_MAX:'EGraphPanningMouseButton_MAX', };
declare type ECommentBoxMode = 'GroupMovement' | 'NoGroupMovement' | 'ECommentBoxMode_MAX';
declare var ECommentBoxMode : { GroupMovement:'GroupMovement',NoGroupMovement:'NoGroupMovement',ECommentBoxMode_MAX:'ECommentBoxMode_MAX', };
declare class GraphEditorSettings extends UObject { 
	DataPinStyle: EBlueprintPinStyleType;
	PanningMouseButton: EGraphPanningMouseButton;
	PaddingAbovePin: number;
	PaddingBelowPin: number;
	PaddingRightOfInput: number;
	PaddingLeftOfOutput: number;
	PaddingTowardsNodeEdge: number;
	bTreatSplinesLikePins: boolean;
	SplineHoverTolerance: number;
	SplineCloseTolerance: number;
	ForwardSplineHorizontalDeltaRange: number;
	ForwardSplineVerticalDeltaRange: number;
	ForwardSplineTangentFromHorizontalDelta: Vector2D;
	ForwardSplineTangentFromVerticalDelta: Vector2D;
	BackwardSplineHorizontalDeltaRange: number;
	BackwardSplineVerticalDeltaRange: number;
	BackwardSplineTangentFromHorizontalDelta: Vector2D;
	BackwardSplineTangentFromVerticalDelta: Vector2D;
	DefaultPinTypeColor: LinearColor;
	ExecutionPinTypeColor: LinearColor;
	BooleanPinTypeColor: LinearColor;
	BytePinTypeColor: LinearColor;
	ClassPinTypeColor: LinearColor;
	IntPinTypeColor: LinearColor;
	Int64PinTypeColor: LinearColor;
	FloatPinTypeColor: LinearColor;
	DoublePinTypeColor: LinearColor;
	RealPinTypeColor: LinearColor;
	NamePinTypeColor: LinearColor;
	SoftObjectPinTypeColor: LinearColor;
	SoftClassPinTypeColor: LinearColor;
	DelegatePinTypeColor: LinearColor;
	ObjectPinTypeColor: LinearColor;
	InterfacePinTypeColor: LinearColor;
	StringPinTypeColor: LinearColor;
	TextPinTypeColor: LinearColor;
	StructPinTypeColor: LinearColor;
	WildcardPinTypeColor: LinearColor;
	VectorPinTypeColor: LinearColor;
	RotatorPinTypeColor: LinearColor;
	TransformPinTypeColor: LinearColor;
	IndexPinTypeColor: LinearColor;
	EventNodeTitleColor: LinearColor;
	FunctionCallNodeTitleColor: LinearColor;
	PureFunctionCallNodeTitleColor: LinearColor;
	ParentFunctionCallNodeTitleColor: LinearColor;
	FunctionTerminatorNodeTitleColor: LinearColor;
	ExecBranchNodeTitleColor: LinearColor;
	ExecSequenceNodeTitleColor: LinearColor;
	ResultNodeTitleColor: LinearColor;
	DefaultCommentNodeTitleColor: LinearColor;
	PreviewNodeTitleColor: LinearColor;
	DefaultDataWireThickness: number;
	DefaultExecutionWireThickness: number;
	TraceAttackColor: LinearColor;
	TraceAttackWireThickness: number;
	TraceAttackHoldPeriod: number;
	TraceDecayPeriod: number;
	TraceDecayExponent: number;
	TraceSustainColor: LinearColor;
	TraceSustainWireThickness: number;
	TraceSustainHoldPeriod: number;
	TraceReleaseColor: LinearColor;
	TraceReleaseWireThickness: number;
	TraceReleasePeriod: number;
	TraceReleaseExponent: number;
	TracePositionBonusPeriod: number;
	TracePositionExponent: number;
	PaddingAutoCollateIncrement: number;
	bOpenCreateMenuOnBlankGraphAreas: boolean;
	DefaultCommentNodeMoveMode: ECommentBoxMode;
	bShowCommentBubbleWhenZoomedOut: boolean;
	static Load(ResourceName: string): GraphEditorSettings;
	static Find(Outer: UObject, ResourceName: string): GraphEditorSettings;
	static GetDefaultObject(): GraphEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GraphEditorSettings;
	static C(Other: UObject | any): GraphEditorSettings;
}

declare class AssetEditorContextInterface extends Interface { 
	static Load(ResourceName: string): AssetEditorContextInterface;
	static Find(Outer: UObject, ResourceName: string): AssetEditorContextInterface;
	static GetDefaultObject(): AssetEditorContextInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetEditorContextInterface;
	static C(Other: UObject | any): AssetEditorContextInterface;
}

declare class AssetFactoryInterface extends Interface { 
	static Load(ResourceName: string): AssetFactoryInterface;
	static Find(Outer: UObject, ResourceName: string): AssetFactoryInterface;
	static GetDefaultObject(): AssetFactoryInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetFactoryInterface;
	static C(Other: UObject | any): AssetFactoryInterface;
}

declare class EditorElementSubsystem extends EditorSubsystem { 
	static Load(ResourceName: string): EditorElementSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorElementSubsystem;
	static GetDefaultObject(): EditorElementSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorElementSubsystem;
	static C(Other: UObject | any): EditorElementSubsystem;
}

declare class PlacementSubsystem extends EditorSubsystem { 
	AssetFactories: any[];
	static Load(ResourceName: string): PlacementSubsystem;
	static Find(Outer: UObject, ResourceName: string): PlacementSubsystem;
	static GetDefaultObject(): PlacementSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlacementSubsystem;
	static C(Other: UObject | any): PlacementSubsystem;
}

declare class TypedElementDetailsInterface extends Interface { 
	static Load(ResourceName: string): TypedElementDetailsInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementDetailsInterface;
	static GetDefaultObject(): TypedElementDetailsInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementDetailsInterface;
	static C(Other: UObject | any): TypedElementDetailsInterface;
}

declare class TypedElementViewportInteraction extends UObject { 
	static Load(ResourceName: string): TypedElementViewportInteraction;
	static Find(Outer: UObject, ResourceName: string): TypedElementViewportInteraction;
	static GetDefaultObject(): TypedElementViewportInteraction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementViewportInteraction;
	static C(Other: UObject | any): TypedElementViewportInteraction;
}

declare class AnimNodeFunctionRef { 
	ClassName: string;
	FunctionName: string;
	Class: UnrealEngineClass;
	UFunction: UFunction;
	clone() : AnimNodeFunctionRef;
	static C(Other: UObject | any): AnimNodeFunctionRef;
}

declare class AnimNode_Base { 
	InitialUpdateFunction: AnimNodeFunctionRef;
	BecomeRelevantFunction: AnimNodeFunctionRef;
	UpdateFunction: AnimNodeFunctionRef;
	clone() : AnimNode_Base;
	static C(Other: UObject | any): AnimNode_Base;
}

declare class PoseLinkBase { 
	LinkID: number;
	SourceLinkID: number;
	clone() : PoseLinkBase;
	static C(Other: UObject | any): PoseLinkBase;
}

declare class PoseLink extends PoseLinkBase { 
	clone() : PoseLink;
	static C(Other: UObject | any): PoseLink;
}

declare class AnimNode_Root extends AnimNode_Base { 
	Result: PoseLink;
	Name: string;
	Group: string;
	clone() : AnimNode_Root;
	static C(Other: UObject | any): AnimNode_Root;
}

declare class AnimNode_BlendSpaceSampleResult extends AnimNode_Root { 
	clone() : AnimNode_BlendSpaceSampleResult;
	static C(Other: UObject | any): AnimNode_BlendSpaceSampleResult;
}

declare class AnimGraphNode_BlendSpaceSampleResult extends AnimGraphNode_Base { 
	UNode: AnimNode_BlendSpaceSampleResult;
	static Load(ResourceName: string): AnimGraphNode_BlendSpaceSampleResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_BlendSpaceSampleResult;
	static GetDefaultObject(): AnimGraphNode_BlendSpaceSampleResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_BlendSpaceSampleResult;
	static C(Other: UObject | any): AnimGraphNode_BlendSpaceSampleResult;
}

declare class AnimationBlendSpaceSampleGraph extends AnimationGraph { 
	ResultNode: AnimGraphNode_BlendSpaceSampleResult;
	static Load(ResourceName: string): AnimationBlendSpaceSampleGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationBlendSpaceSampleGraph;
	static GetDefaultObject(): AnimationBlendSpaceSampleGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationBlendSpaceSampleGraph;
	static C(Other: UObject | any): AnimationBlendSpaceSampleGraph;
}

declare class AnimationConduitGraphSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): AnimationConduitGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationConduitGraphSchema;
	static GetDefaultObject(): AnimationConduitGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationConduitGraphSchema;
	static C(Other: UObject | any): AnimationConduitGraphSchema;
}

declare class AnimNode_StateResult extends AnimNode_Root { 
	StateIndex: number;
	clone() : AnimNode_StateResult;
	static C(Other: UObject | any): AnimNode_StateResult;
}

declare class AnimGraphNode_StateResult extends AnimGraphNode_Base { 
	UNode: AnimNode_StateResult;
	static Load(ResourceName: string): AnimGraphNode_StateResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateResult;
	static GetDefaultObject(): AnimGraphNode_StateResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateResult;
	static C(Other: UObject | any): AnimGraphNode_StateResult;
}

declare class AnimGraphNode_CustomTransitionResult extends AnimGraphNode_StateResult { 
	static Load(ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_CustomTransitionResult;
	static GetDefaultObject(): AnimGraphNode_CustomTransitionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_CustomTransitionResult;
	static C(Other: UObject | any): AnimGraphNode_CustomTransitionResult;
}

declare class AnimationCustomTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_CustomTransitionResult;
	static Load(ResourceName: string): AnimationCustomTransitionGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationCustomTransitionGraph;
	static GetDefaultObject(): AnimationCustomTransitionGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionGraph;
	static C(Other: UObject | any): AnimationCustomTransitionGraph;
}

declare class AnimationGraphSchema extends EdGraphSchema_K2 { 
	PN_SequenceName: string;
	NAME_NeverAsPin: string;
	NAME_PinHiddenByDefault: string;
	NAME_PinShownByDefault: string;
	NAME_AlwaysAsPin: string;
	NAME_CustomizeProperty: string;
	NAME_OnEvaluate: string;
	DefaultEvaluationHandlerName: string;
	static Load(ResourceName: string): AnimationGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationGraphSchema;
	static GetDefaultObject(): AnimationGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraphSchema;
	static C(Other: UObject | any): AnimationGraphSchema;
}

declare class AnimationCustomTransitionSchema extends AnimationGraphSchema { 
	static Load(ResourceName: string): AnimationCustomTransitionSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationCustomTransitionSchema;
	static GetDefaultObject(): AnimationCustomTransitionSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationCustomTransitionSchema;
	static C(Other: UObject | any): AnimationCustomTransitionSchema;
}

declare class AnimationStateGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_StateResult;
	static Load(ResourceName: string): AnimationStateGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationStateGraph;
	static GetDefaultObject(): AnimationStateGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraph;
	static C(Other: UObject | any): AnimationStateGraph;
}

declare class AnimationStateGraphSchema extends AnimationGraphSchema { 
	static Load(ResourceName: string): AnimationStateGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationStateGraphSchema;
	static GetDefaultObject(): AnimationStateGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateGraphSchema;
	static C(Other: UObject | any): AnimationStateGraphSchema;
}

declare class AnimStateEntryNode extends EdGraphNode { 
	static Load(ResourceName: string): AnimStateEntryNode;
	static Find(Outer: UObject, ResourceName: string): AnimStateEntryNode;
	static GetDefaultObject(): AnimStateEntryNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimStateEntryNode;
	static C(Other: UObject | any): AnimStateEntryNode;
}

declare class AnimGraphNode_StateMachineBase extends AnimGraphNode_Base { 
	EditorStateMachineGraph: AnimationStateMachineGraph;
	static Load(ResourceName: string): AnimGraphNode_StateMachineBase;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StateMachineBase;
	static GetDefaultObject(): AnimGraphNode_StateMachineBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StateMachineBase;
	static C(Other: UObject | any): AnimGraphNode_StateMachineBase;
}

declare class AnimationStateMachineGraph extends EdGraph { 
	EntryNode: AnimStateEntryNode;
	OwnerAnimGraphNode: AnimGraphNode_StateMachineBase;
	static Load(ResourceName: string): AnimationStateMachineGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineGraph;
	static GetDefaultObject(): AnimationStateMachineGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineGraph;
	static C(Other: UObject | any): AnimationStateMachineGraph;
}

declare class AnimationStateMachineSchema extends EdGraphSchema { 
	static Load(ResourceName: string): AnimationStateMachineSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationStateMachineSchema;
	static GetDefaultObject(): AnimationStateMachineSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationStateMachineSchema;
	static C(Other: UObject | any): AnimationStateMachineSchema;
}

declare class AnimNode_TransitionResult extends AnimNode_Base { 
	bCanEnterTransition: boolean;
	clone() : AnimNode_TransitionResult;
	static C(Other: UObject | any): AnimNode_TransitionResult;
}

declare class AnimGraphNode_TransitionResult extends AnimGraphNode_Base { 
	UNode: AnimNode_TransitionResult;
	static Load(ResourceName: string): AnimGraphNode_TransitionResult;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_TransitionResult;
	static GetDefaultObject(): AnimGraphNode_TransitionResult;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_TransitionResult;
	static C(Other: UObject | any): AnimGraphNode_TransitionResult;
}

declare class AnimationTransitionGraph extends AnimationGraph { 
	MyResultNode: AnimGraphNode_TransitionResult;
	static Load(ResourceName: string): AnimationTransitionGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationTransitionGraph;
	static GetDefaultObject(): AnimationTransitionGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionGraph;
	static C(Other: UObject | any): AnimationTransitionGraph;
}

declare class AnimationTransitionSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): AnimationTransitionSchema;
	static Find(Outer: UObject, ResourceName: string): AnimationTransitionSchema;
	static GetDefaultObject(): AnimationTransitionSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationTransitionSchema;
	static C(Other: UObject | any): AnimationTransitionSchema;
}

declare class AnimBlueprintExtension extends BlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension;
	static GetDefaultObject(): AnimBlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension;
	static C(Other: UObject | any): AnimBlueprintExtension;
}

declare class AnimBlueprintExtension_Attributes extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_Attributes;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_Attributes;
	static GetDefaultObject(): AnimBlueprintExtension_Attributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_Attributes;
	static C(Other: UObject | any): AnimBlueprintExtension_Attributes;
}

declare class AnimSubsystem { 
	clone() : AnimSubsystem;
	static C(Other: UObject | any): AnimSubsystem;
}

declare type EPostCopyOperation = 'None' | 'LogicalNegateBool' | 'EPostCopyOperation_MAX';
declare var EPostCopyOperation : { None:'None',LogicalNegateBool:'LogicalNegateBool',EPostCopyOperation_MAX:'EPostCopyOperation_MAX', };
declare class ExposedValueCopyRecord { 
	CopyIndex: number;
	PostCopyOperation: EPostCopyOperation;
	clone() : ExposedValueCopyRecord;
	static C(Other: UObject | any): ExposedValueCopyRecord;
}

declare class ExposedValueHandler { 
	CopyRecords: ExposedValueCopyRecord[];
	UFunction: UFunction;
	BoundFunction: string;
	clone() : ExposedValueHandler;
	static C(Other: UObject | any): ExposedValueHandler;
}

declare class AnimSubsystem_Base extends AnimSubsystem { 
	ExposedValueHandlers: ExposedValueHandler[];
	clone() : AnimSubsystem_Base;
	static C(Other: UObject | any): AnimSubsystem_Base;
}

declare class AnimBlueprintExtension_Base extends AnimBlueprintExtension { 
	Subsystem: AnimSubsystem_Base;
	static Load(ResourceName: string): AnimBlueprintExtension_Base;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_Base;
	static GetDefaultObject(): AnimBlueprintExtension_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_Base;
	static C(Other: UObject | any): AnimBlueprintExtension_Base;
}

declare type EFilterInterpolationType = 'BSIT_Average' | 'BSIT_Linear' | 'BSIT_Cubic' | 'BSIT_EaseInOut' | 'BSIT_ExponentialDecay' | 'BSIT_SpringDamper' | 'BSIT_MAX';
declare var EFilterInterpolationType : { BSIT_Average:'BSIT_Average',BSIT_Linear:'BSIT_Linear',BSIT_Cubic:'BSIT_Cubic',BSIT_EaseInOut:'BSIT_EaseInOut',BSIT_ExponentialDecay:'BSIT_ExponentialDecay',BSIT_SpringDamper:'BSIT_SpringDamper',BSIT_MAX:'BSIT_MAX', };
declare class InterpolationParameter { 
	InterpolationTime: number;
	DampingRatio: number;
	MaxSpeed: number;
	InterpolationType: EFilterInterpolationType;
	clone() : InterpolationParameter;
	static C(Other: UObject | any): InterpolationParameter;
}

declare class AnalysisProperties extends UObject { 
	UFunction: string;
	static Load(ResourceName: string): AnalysisProperties;
	static Find(Outer: UObject, ResourceName: string): AnalysisProperties;
	static GetDefaultObject(): AnalysisProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnalysisProperties;
	static C(Other: UObject | any): AnalysisProperties;
}

declare type ENotifyTriggerMode = 'AllAnimations' | 'HighestWeightedAnimation' | 'None' | 'ENotifyTriggerMode_MAX';
declare var ENotifyTriggerMode : { AllAnimations:'AllAnimations',HighestWeightedAnimation:'HighestWeightedAnimation',None:'None',ENotifyTriggerMode_MAX:'ENotifyTriggerMode_MAX', };
declare type EPreferredTriangulationDirection = 'None' | 'Tangential' | 'Radial' | 'EPreferredTriangulationDirection_MAX';
declare var EPreferredTriangulationDirection : { None:'None',Tangential:'Tangential',Radial:'Radial',EPreferredTriangulationDirection_MAX:'EPreferredTriangulationDirection_MAX', };
declare class PerBoneInterpolation { 
	BoneReference: BoneReference;
	InterpolationSpeedPerSec: number;
	clone() : PerBoneInterpolation;
	static C(Other: UObject | any): PerBoneInterpolation;
}

declare class BlendSample { 
	Animation: AnimSequence;
	SampleValue: Vector;
	RateScale: number;
	bIsValid: boolean;
	clone() : BlendSample;
	static C(Other: UObject | any): BlendSample;
}

declare class EditorElement { 
	Indices: number;
	Weights: number;
	clone() : EditorElement;
	static C(Other: UObject | any): EditorElement;
}

declare class BlendSpaceSegment { 
	SampleIndices: number;
	Vertices: number;
	clone() : BlendSpaceSegment;
	static C(Other: UObject | any): BlendSpaceSegment;
}

declare class BlendSpaceTriangleEdgeInfo { 
	Normal: Vector2D;
	NeighbourTriangleIndex: number;
	AdjacentPerimeterTriangleIndices: number;
	AdjacentPerimeterVertexIndices: number;
	clone() : BlendSpaceTriangleEdgeInfo;
	static C(Other: UObject | any): BlendSpaceTriangleEdgeInfo;
}

declare class BlendSpaceTriangle { 
	SampleIndices: number;
	Vertices: Vector2D;
	EdgeInfo: BlendSpaceTriangleEdgeInfo;
	clone() : BlendSpaceTriangle;
	static C(Other: UObject | any): BlendSpaceTriangle;
}

declare class BlendSpaceData { 
	Segments: BlendSpaceSegment[];
	Triangles: BlendSpaceTriangle[];
	clone() : BlendSpaceData;
	static C(Other: UObject | any): BlendSpaceData;
}

declare class BlendParameter { 
	DisplayName: string;
	Min: number;
	Max: number;
	GridNum: number;
	bSnapToGrid: boolean;
	bWrapInput: boolean;
	clone() : BlendParameter;
	static C(Other: UObject | any): BlendParameter;
}

declare type EBlendSpaceAxis = 'BSA_None' | 'BSA_X' | 'BSA_Y' | 'BSA_MAX';
declare var EBlendSpaceAxis : { BSA_None:'BSA_None',BSA_X:'BSA_X',BSA_Y:'BSA_Y',BSA_MAX:'BSA_MAX', };
declare class BlendSpace extends AnimationAsset { 
	bRotationBlendInMeshSpace: boolean;
	InterpolationParam: InterpolationParameter;
	AnalysisProperties: AnalysisProperties;
	TargetWeightInterpolationSpeedPerSec: number;
	bTargetWeightInterpolationEaseInOut: boolean;
	PreviewBasePose: AnimSequence;
	AnimLength: number;
	NotifyTriggerMode: ENotifyTriggerMode;
	bInterpolateUsingGrid: boolean;
	PreferredTriangulationDirection: EPreferredTriangulationDirection;
	PerBoneBlend: PerBoneInterpolation[];
	SampleIndexWithMarkers: number;
	SampleData: BlendSample[];
	GridSamples: EditorElement[];
	BlendSpaceData: BlendSpaceData;
	BlendParameters: BlendParameter;
	AxisToScaleAnimation: EBlendSpaceAxis;
	DimensionIndices: number[];
	static Load(ResourceName: string): BlendSpace;
	static Find(Outer: UObject, ResourceName: string): BlendSpace;
	static GetDefaultObject(): BlendSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendSpace;
	static C(Other: UObject | any): BlendSpace;
}

declare class AnimSubsystem_BlendSpaceGraph extends AnimSubsystem { 
	BlendSpaces: BlendSpace[];
	clone() : AnimSubsystem_BlendSpaceGraph;
	static C(Other: UObject | any): AnimSubsystem_BlendSpaceGraph;
}

declare class AnimBlueprintExtension_BlendSpaceGraph extends AnimBlueprintExtension { 
	Class: UnrealEngineClass;
	Subsystem: AnimSubsystem_BlendSpaceGraph;
	static Load(ResourceName: string): AnimBlueprintExtension_BlendSpaceGraph;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_BlendSpaceGraph;
	static GetDefaultObject(): AnimBlueprintExtension_BlendSpaceGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_BlendSpaceGraph;
	static C(Other: UObject | any): AnimBlueprintExtension_BlendSpaceGraph;
}

declare class AnimBlueprintExtension_CachedPose extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_CachedPose;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_CachedPose;
	static GetDefaultObject(): AnimBlueprintExtension_CachedPose;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_CachedPose;
	static C(Other: UObject | any): AnimBlueprintExtension_CachedPose;
}

declare class AnimBlueprintExtension_CallFunction extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_CallFunction;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_CallFunction;
	static GetDefaultObject(): AnimBlueprintExtension_CallFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_CallFunction;
	static C(Other: UObject | any): AnimBlueprintExtension_CallFunction;
}

declare class AnimBlueprintExtension_LinkedAnimGraph extends AnimBlueprintExtension { 
	static Load(ResourceName: string): AnimBlueprintExtension_LinkedAnimGraph;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_LinkedAnimGraph;
	static GetDefaultObject(): AnimBlueprintExtension_LinkedAnimGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_LinkedAnimGraph;
	static C(Other: UObject | any): AnimBlueprintExtension_LinkedAnimGraph;
}

declare class AnimSubsystemInstance { 
	clone() : AnimSubsystemInstance;
	static C(Other: UObject | any): AnimSubsystemInstance;
}

declare class AnimSubsystemInstance_NodeRelevancy extends AnimSubsystemInstance { 
	clone() : AnimSubsystemInstance_NodeRelevancy;
	static C(Other: UObject | any): AnimSubsystemInstance_NodeRelevancy;
}

declare class AnimBlueprintExtension_NodeRelevancy extends AnimBlueprintExtension { 
	Subsystem: AnimSubsystemInstance_NodeRelevancy;
	static Load(ResourceName: string): AnimBlueprintExtension_NodeRelevancy;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintExtension_NodeRelevancy;
	static GetDefaultObject(): AnimBlueprintExtension_NodeRelevancy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintExtension_NodeRelevancy;
	static C(Other: UObject | any): AnimBlueprintExtension_NodeRelevancy;
}

declare class PropertyAccessSegment { 
	Name: string;
	struct: Struct;
	Property: any;
	UFunction: UFunction;
	ArrayIndex: number;
	Flags: any;
	clone() : PropertyAccessSegment;
	static C(Other: UObject | any): PropertyAccessSegment;
}

declare class PropertyAccessPath { 
	PathSegmentStartIndex: number;
	PathSegmentCount: number;
	clone() : PropertyAccessPath;
	static C(Other: UObject | any): PropertyAccessPath;
}

declare type EPropertyAccessCopyType = 'None' | 'Plain' | 'Complex' | 'Bool' | 'Struct' | 'Object' | 'Name' | 'Array' | 'PromoteBoolToByte' | 'PromoteBoolToInt32' | 'PromoteBoolToInt64' | 'PromoteBoolToFloat' | 'PromoteBoolToDouble' | 'PromoteByteToInt32' | 'PromoteByteToInt64' | 'PromoteByteToFloat' | 'PromoteByteToDouble' | 'PromoteInt32ToInt64' | 'PromoteInt32ToFloat' | 'PromoteInt32ToDouble' | 'PromoteFloatToDouble' | 'DemoteDoubleToFloat' | 'PromoteArrayFloatToDouble' | 'DemoteArrayDoubleToFloat' | 'EPropertyAccessCopyType_MAX';
declare var EPropertyAccessCopyType : { None:'None',Plain:'Plain',Complex:'Complex',Bool:'Bool',Struct:'Struct',Object:'Object',Name:'Name',Array:'Array',PromoteBoolToByte:'PromoteBoolToByte',PromoteBoolToInt32:'PromoteBoolToInt32',PromoteBoolToInt64:'PromoteBoolToInt64',PromoteBoolToFloat:'PromoteBoolToFloat',PromoteBoolToDouble:'PromoteBoolToDouble',PromoteByteToInt32:'PromoteByteToInt32',PromoteByteToInt64:'PromoteByteToInt64',PromoteByteToFloat:'PromoteByteToFloat',PromoteByteToDouble:'PromoteByteToDouble',PromoteInt32ToInt64:'PromoteInt32ToInt64',PromoteInt32ToFloat:'PromoteInt32ToFloat',PromoteInt32ToDouble:'PromoteInt32ToDouble',PromoteFloatToDouble:'PromoteFloatToDouble',DemoteDoubleToFloat:'DemoteDoubleToFloat',PromoteArrayFloatToDouble:'PromoteArrayFloatToDouble',DemoteArrayDoubleToFloat:'DemoteArrayDoubleToFloat',EPropertyAccessCopyType_MAX:'EPropertyAccessCopyType_MAX', };
declare class PropertyAccessCopy { 
	AccessIndex: number;
	DestAccessStartIndex: number;
	DestAccessEndIndex: number;
	Type: EPropertyAccessCopyType;
	clone() : PropertyAccessCopy;
	static C(Other: UObject | any): PropertyAccessCopy;
}

declare class PropertyAccessCopyBatch { 
	Copies: PropertyAccessCopy[];
	clone() : PropertyAccessCopyBatch;
	static C(Other: UObject | any): PropertyAccessCopyBatch;
}

declare class PropertyAccessIndirectionChain { 
	Property: any;
	IndirectionStartIndex: number;
	IndirectionEndIndex: number;
	clone() : PropertyAccessIndirectionChain;
	static C(Other: UObject | any): PropertyAccessIndirectionChain;
}

declare type EPropertyAccessObjectType = 'None' | 'Object' | 'WeakObject' | 'SoftObject' | 'EPropertyAccessObjectType_MAX';
declare var EPropertyAccessObjectType : { None:'None',Object:'Object',WeakObject:'WeakObject',SoftObject:'SoftObject',EPropertyAccessObjectType_MAX:'EPropertyAccessObjectType_MAX', };
declare type EPropertyAccessIndirectionType = 'Offset' | 'Object' | 'Array' | 'ScriptFunction' | 'NativeFunction' | 'EPropertyAccessIndirectionType_MAX';
declare var EPropertyAccessIndirectionType : { Offset:'Offset',Object:'Object',Array:'Array',ScriptFunction:'ScriptFunction',NativeFunction:'NativeFunction',EPropertyAccessIndirectionType_MAX:'EPropertyAccessIndirectionType_MAX', };
declare class PropertyAccessIndirection { 
	Property: any;
	UFunction: UFunction;
	ReturnBufferSize: number;
	ReturnBufferAlignment: number;
	ArrayIndex: number;
	Offset: any;
	ObjectType: EPropertyAccessObjectType;
	Type: EPropertyAccessIndirectionType;
	clone() : PropertyAccessIndirection;
	static C(Other: UObject | any): PropertyAccessIndirection;
}

declare class PropertyAccessLibrary { 
	PathSegments: PropertyAccessSegment[];
	SrcPaths: PropertyAccessPath[];
	DestPaths: PropertyAccessPath[];
	CopyBatches: PropertyAccessCopyBatch;
	CopyBatchArray: PropertyAccessCopyBatch[];
	SrcAccesses: PropertyAccessIndirectionChain[];
	DestAccesses: PropertyAccessIndirectionChain[];
	Indirections: PropertyAccessIndirection[];
	clone() : PropertyAccessLibrary;
	static C(Other: UObject | any): PropertyAccessLibrary;
}

